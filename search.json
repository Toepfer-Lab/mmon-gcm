[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MMON-GCM",
    "section": "",
    "text": "This code does not work with python 3.10 because of a dependency issue with Escher: https://github.com/zakandrewking/escher/issues/377 . So make sure you install the package in a venv with e.g. python 3.9.\n\nClone the repo from GitHub.\nMake a venv with e.g. conda: conda create --name mmon-gcm python=3.9\nInstall the package and dependencies in that virtualenv by running pip install -e . in the root of the repo\nRun the notebook scripts in the order that they are numbered.\n\nThe project uses nbdev2 to autocreate packages and documentation from jupyter notebooks.\n\n\nNoah Sprent developed and wrote the majority of the code. Maurice Cheung edited minor parts of the code for publication.",
    "crumbs": [
      "MMON-GCM"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "MMON-GCM",
    "section": "",
    "text": "This code does not work with python 3.10 because of a dependency issue with Escher: https://github.com/zakandrewking/escher/issues/377 . So make sure you install the package in a venv with e.g. python 3.9.\n\nClone the repo from GitHub.\nMake a venv with e.g. conda: conda create --name mmon-gcm python=3.9\nInstall the package and dependencies in that virtualenv by running pip install -e . in the root of the repo\nRun the notebook scripts in the order that they are numbered.\n\nThe project uses nbdev2 to autocreate packages and documentation from jupyter notebooks.\n\n\nNoah Sprent developed and wrote the majority of the code. Maurice Cheung edited minor parts of the code for publication.",
    "crumbs": [
      "MMON-GCM"
    ]
  },
  {
    "objectID": "2.0_compute_maintenance.html",
    "href": "2.0_compute_maintenance.html",
    "title": "Solving guard cell models for different parameters",
    "section": "",
    "text": "Remember to change maintenance ratio in 2.1 and supermodel.py"
  },
  {
    "objectID": "2.0_compute_maintenance.html#setup",
    "href": "2.0_compute_maintenance.html#setup",
    "title": "Solving guard cell models for different parameters",
    "section": "Setup",
    "text": "Setup\n\n# This cell isn't exported to the .py file, so define here if running in notebook rather than as .py on e.g.a cluster\n# This is where to adjust whether fva is run if running in notebook\nargs = {\n    \"run_fva\": \"True\",\n    \"no_processes\": 6,\n    \"output_dir\": \"../outputs/model_solutions/\",\n    \"model_file\": \"../models/4_stage_GC.xml\",\n    \"map_file\": \"../inputs/map.json\",\n    \"parameters_file\": \"../inputs/arabidopsis_parameters.csv\",\n}\n\nsys.argv = [\"script_name\"] + list(args.values())"
  },
  {
    "objectID": "2.0_compute_maintenance.html#instantiate-and-apply-base-constraints-to-model",
    "href": "2.0_compute_maintenance.html#instantiate-and-apply-base-constraints-to-model",
    "title": "Solving guard cell models for different parameters",
    "section": "Instantiate and apply base constraints to model",
    "text": "Instantiate and apply base constraints to model\n\nImport FBA model\nDecrease tolerance\n\n\nDefine reactions to use for FVA\n\n\nInstantiate Supermodel\nImport parameters from csv, created in parameters notebook\nThis is a little different to Jezek and Blatt (2017), where they have closed as 0.3-0.4pL and open as 0.5-0.65. Open apertures are on the small side but still within their range (2-6). Wang used a volume of 0.4pL.\n\n\nConstrain SuperModel\n\nConstrain osmolarity of the model using the equation from the OnGuard model (Hills et al 2012)\n\nimport numpy as np\n\n\nnp.array(arabidopsis_supermodel.get_osmolarities())\n\narray([0.03935933, 0.05492236, 0.03935933, 0.03935933])\n\n\n\nhelp(arabidopsis_supermodel.get_osmolarities)\n\nHelp on method get_osmolarities in module mmon_gcm.supermodel:\n\nget_osmolarities(apertures='default', equation='onguard', printouts=False) method of mmon_gcm.supermodel.SuperModel instance\n    Calculates the osmolarities at each phase of the model using the equation\n    specified, default is onguard. Adds these as an attribute to the SuperModel\n\n\n\n\nmmoles_per_m2 = np.array(arabidopsis_supermodel.get_osmolarities())\nmmoles_per_gc = mmoles_per_m2 / arabidopsis_supermodel.N_gcs\nmoles_per_gc = mmoles_per_gc * 10**-3\nfmoles_per_gc = moles_per_gc / 10**-15\nprint(f\"Closed fmoles: {fmoles_per_gc[0]}\")\nprint(f\"Open fmoles: {fmoles_per_gc[1]}\")\nprint(f\"Increase in fmoles: {fmoles_per_gc[1] - fmoles_per_gc[0]}\")\n\nClosed fmoles: 67.86090968309483\nOpen fmoles: 94.69373119804636\nIncrease in fmoles: 26.832821514951533\n\n\n\n\nConstrain photons using a PPFD of 150µmolm\\(^{-2}\\)s\\(^{-1}\\), same as used in Horrer et al (2016)"
  },
  {
    "objectID": "2.0_compute_maintenance.html#run-fba-without-maintenance-to-get-sum-of-fluxes",
    "href": "2.0_compute_maintenance.html#run-fba-without-maintenance-to-get-sum-of-fluxes",
    "title": "Solving guard cell models for different parameters",
    "section": "Run FBA without maintenance to get sum of fluxes",
    "text": "Run FBA without maintenance to get sum of fluxes\n\nno_maintenance_solutions = pd.DataFrame()\n\n### Blue Light Unconstrained H+-ATPase WT\n\narabidopsis_supermodel.constrain_photons(PPFD, printouts=False)\nwith arabidopsis_supermodel.fba_model as m:\n    m.reactions.Photon_tx_gc_2.upper_bound = 0\n    m.reactions.Photon_tx_me_2.upper_bound = 0\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"RXN_1827_p_gc\", 0, cobra.Configuration().upper_bound)\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"PROTON_ATPase_c_gc\", 0, cobra.Configuration().upper_bound) \n    (\n        blue_unconstrained_wt,\n        blue_unconstrained_wt_solution,\n    ) = mmon_gcm.solving.get_pfba_fva_solution(m, rxn_list=[], processes=no_processes)\nno_maintenance_solutions['blue_uncon_wt'] = blue_unconstrained_wt_solution['fluxes']\n\n### Blue Light Unconstrained H+-ATPase Starch KO\n\narabidopsis_supermodel.constrain_photons(PPFD, printouts=False)\nwith arabidopsis_supermodel.fba_model as m:\n    m.reactions.Photon_tx_gc_2.upper_bound = 0\n    m.reactions.Photon_tx_me_2.upper_bound = 0\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"RXN_1827_p_gc\", 0, 0)\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"PROTON_ATPase_c_gc\", 0, cobra.Configuration().upper_bound) \n    (\n        blue_unconstrained_ko,\n        blue_unconstrained_ko_solution,\n    ) = mmon_gcm.solving.get_pfba_fva_solution(m, rxn_list=[], processes=no_processes)\nno_maintenance_solutions['blue_uncon_ko'] = blue_unconstrained_ko_solution['fluxes']\n\n### Blue Light Constrained H+-ATPase WT\n\narabidopsis_supermodel.constrain_photons(PPFD, printouts=False)\nwith arabidopsis_supermodel.fba_model as m:\n    m.reactions.Photon_tx_gc_2.upper_bound = 0\n    m.reactions.Photon_tx_me_2.upper_bound = 0\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"RXN_1827_p_gc\", 0, cobra.Configuration().upper_bound)\n    gc_atpase_upper_bound = arabidopsis_supermodel.get_atpase_constraint_value(7.5)\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"PROTON_ATPase_c_gc\", 0, gc_atpase_upper_bound)\n    (\n        blue_constrained_wt,\n        blue_constrained_wt_solution,\n    ) = mmon_gcm.solving.get_pfba_fva_solution(m, rxn_list=[], processes=no_processes)\nno_maintenance_solutions['blue_con_wt'] = blue_constrained_wt_solution['fluxes']\n\n### Blue Light Constrained H+-ATPase Starch KO\n\narabidopsis_supermodel.constrain_photons(PPFD, printouts=False)\nwith arabidopsis_supermodel.fba_model as m:\n    m.reactions.Photon_tx_gc_2.upper_bound = 0\n    m.reactions.Photon_tx_me_2.upper_bound = 0\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"RXN_1827_p_gc\", 0, 0)\n    gc_atpase_upper_bound = arabidopsis_supermodel.get_atpase_constraint_value(7.5)\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"PROTON_ATPase_c_gc\", 0, gc_atpase_upper_bound) \n    (\n        blue_constrained_ko,\n        blue_constrained_ko_solution,\n    ) = mmon_gcm.solving.get_pfba_fva_solution(m, rxn_list=[], processes=no_processes)\nno_maintenance_solutions['blue_con_ko'] = blue_constrained_ko_solution['fluxes']\n\n### White Light Unconstrained H+-ATPase WT\n\narabidopsis_supermodel.constrain_photons(PPFD, printouts=False)\nwith arabidopsis_supermodel.fba_model as m:\n    #m.reactions.Photon_tx_gc_2.upper_bound = 0\n    #m.reactions.Photon_tx_me_2.upper_bound = 0\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"RXN_1827_p_gc\", 0, cobra.Configuration().upper_bound)\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"PROTON_ATPase_c_gc\", 0, cobra.Configuration().upper_bound) \n    (\n        white_unconstrained_wt,\n        white_unconstrained_wt_solution,\n    ) = mmon_gcm.solving.get_pfba_fva_solution(m, rxn_list=[], processes=no_processes)\nno_maintenance_solutions['white_uncon_wt'] = white_unconstrained_wt_solution['fluxes']\n\n### White Light Unconstrained H+-ATPase Starch KO\n\narabidopsis_supermodel.constrain_photons(PPFD, printouts=False)\nwith arabidopsis_supermodel.fba_model as m:\n    #m.reactions.Photon_tx_gc_2.upper_bound = 0\n    #m.reactions.Photon_tx_me_2.upper_bound = 0\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"RXN_1827_p_gc\", 0, 0)\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"PROTON_ATPase_c_gc\", 0, cobra.Configuration().upper_bound) \n    (\n        white_unconstrained_ko,\n        white_unconstrained_ko_solution,\n    ) = mmon_gcm.solving.get_pfba_fva_solution(m, rxn_list=[], processes=no_processes)\nno_maintenance_solutions['white_uncon_ko'] = white_unconstrained_ko_solution['fluxes']\n\n### White Light Constrained H+-ATPase WT\n\narabidopsis_supermodel.constrain_photons(PPFD, printouts=False)\nwith arabidopsis_supermodel.fba_model as m:\n    #m.reactions.Photon_tx_gc_2.upper_bound = 0\n    #m.reactions.Photon_tx_me_2.upper_bound = 0\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"RXN_1827_p_gc\", 0, cobra.Configuration().upper_bound)\n    gc_atpase_upper_bound = arabidopsis_supermodel.get_atpase_constraint_value(7.5)\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"PROTON_ATPase_c_gc\", 0, gc_atpase_upper_bound)\n    (\n        white_constrained_wt,\n        white_constrained_wt_solution,\n    ) = mmon_gcm.solving.get_pfba_fva_solution(m, rxn_list=[], processes=no_processes)\nno_maintenance_solutions['white_con_wt'] = white_constrained_wt_solution['fluxes']\n\n### White Light Constrained H+-ATPase Starch KO\n\narabidopsis_supermodel.constrain_photons(PPFD, printouts=False)\nwith arabidopsis_supermodel.fba_model as m:\n    #m.reactions.Photon_tx_gc_2.upper_bound = 0\n    #m.reactions.Photon_tx_me_2.upper_bound = 0\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"RXN_1827_p_gc\", 0, 0)\n    gc_atpase_upper_bound = arabidopsis_supermodel.get_atpase_constraint_value(7.5)\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"PROTON_ATPase_c_gc\", 0, gc_atpase_upper_bound) \n    (\n        white_constrained_ko,\n        white_constrained_ko_solution,\n    ) = mmon_gcm.solving.get_pfba_fva_solution(m, rxn_list=[], processes=no_processes)\nno_maintenance_solutions['white_con_ko'] = white_constrained_ko_solution['fluxes']\n\n### No PS Unconstrained H+-ATPase WT\n\narabidopsis_supermodel.constrain_photons(PPFD, printouts=False)\nwith arabidopsis_supermodel.fba_model as m:\n    #m.reactions.Photon_tx_gc_2.upper_bound = 0\n    #m.reactions.Photon_tx_me_2.upper_bound = 0\n    for p in [1, 2, 3, 4]:\n        m.reactions.get_by_id(f\"Photon_tx_gc_{p}\").bounds = (0, 0)\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"RXN_1827_p_gc\", 0, cobra.Configuration().upper_bound)\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"PROTON_ATPase_c_gc\", 0, cobra.Configuration().upper_bound) \n    (\n        nops_unconstrained_wt,\n        nops_unconstrained_wt_solution,\n    ) = mmon_gcm.solving.get_pfba_fva_solution(m, rxn_list=[], processes=no_processes)\nno_maintenance_solutions['nops_uncon_wt'] = nops_unconstrained_wt_solution['fluxes']\n\n### No PS Unconstrained H+-ATPase Starch KO\n\narabidopsis_supermodel.constrain_photons(PPFD, printouts=False)\nwith arabidopsis_supermodel.fba_model as m:\n    #m.reactions.Photon_tx_gc_2.upper_bound = 0\n    #m.reactions.Photon_tx_me_2.upper_bound = 0\n    for p in [1, 2, 3, 4]:\n        m.reactions.get_by_id(f\"Photon_tx_gc_{p}\").bounds = (0, 0)\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"RXN_1827_p_gc\", 0, 0)\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"PROTON_ATPase_c_gc\", 0, cobra.Configuration().upper_bound) \n    (\n        nops_unconstrained_ko,\n        nops_unconstrained_ko_solution,\n    ) = mmon_gcm.solving.get_pfba_fva_solution(m, rxn_list=[], processes=no_processes)\nno_maintenance_solutions['nops_uncon_ko'] = nops_unconstrained_ko_solution['fluxes']\n\n### No PS Constrained H+-ATPase WT\n\narabidopsis_supermodel.constrain_photons(PPFD, printouts=False)\nwith arabidopsis_supermodel.fba_model as m:\n    #m.reactions.Photon_tx_gc_2.upper_bound = 0\n    #m.reactions.Photon_tx_me_2.upper_bound = 0\n    for p in [1, 2, 3, 4]:\n        m.reactions.get_by_id(f\"Photon_tx_gc_{p}\").bounds = (0, 0)\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"RXN_1827_p_gc\", 0, cobra.Configuration().upper_bound)\n    gc_atpase_upper_bound = arabidopsis_supermodel.get_atpase_constraint_value(7.5)\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"PROTON_ATPase_c_gc\", 0, gc_atpase_upper_bound)\n    (\n        nops_constrained_wt,\n        nops_constrained_wt_solution,\n    ) = mmon_gcm.solving.get_pfba_fva_solution(m, rxn_list=[], processes=no_processes)\nno_maintenance_solutions['nops_con_wt'] = nops_constrained_wt_solution['fluxes']\n\n### No PS Constrained H+-ATPase Starch KO\n\narabidopsis_supermodel.constrain_photons(PPFD, printouts=False)\nwith arabidopsis_supermodel.fba_model as m:\n    #m.reactions.Photon_tx_gc_2.upper_bound = 0\n    #m.reactions.Photon_tx_me_2.upper_bound = 0\n    for p in [1, 2, 3, 4]:\n        m.reactions.get_by_id(f\"Photon_tx_gc_{p}\").bounds = (0, 0)\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"RXN_1827_p_gc\", 0, 0)\n    gc_atpase_upper_bound = arabidopsis_supermodel.get_atpase_constraint_value(7.5)\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"PROTON_ATPase_c_gc\", 0, gc_atpase_upper_bound) \n    (\n        nops_constrained_ko,\n        nops_constrained_ko_solution,\n    ) = mmon_gcm.solving.get_pfba_fva_solution(m, rxn_list=[], processes=no_processes)\nno_maintenance_solutions['nops_con_ko'] = nops_constrained_ko_solution['fluxes']\n\nStarted running pFBA (and FVA) @ 2024-05-29 11:00:18.771459\nRunning pFBA\nFVA list is empty\nFinished running pFBA (and FVA) @ 2024-05-29 11:00:32.121406, that took 0.2224991202354431 minutes\nStarted running pFBA (and FVA) @ 2024-05-29 11:00:32.142613\nRunning pFBA\nFVA list is empty\nFinished running pFBA (and FVA) @ 2024-05-29 11:00:45.305443, that took 0.21938050587972005 minutes\nStarted running pFBA (and FVA) @ 2024-05-29 11:00:45.317288\nRunning pFBA\nFVA list is empty\nFinished running pFBA (and FVA) @ 2024-05-29 11:01:01.051978, that took 0.26224482456843057 minutes\nStarted running pFBA (and FVA) @ 2024-05-29 11:01:01.061748\nRunning pFBA\nFVA list is empty\nFinished running pFBA (and FVA) @ 2024-05-29 11:01:16.650575, that took 0.25981378157933555 minutes\nStarted running pFBA (and FVA) @ 2024-05-29 11:01:16.676700\nRunning pFBA\nFVA list is empty\nFinished running pFBA (and FVA) @ 2024-05-29 11:01:31.049585, that took 0.23954807917277018 minutes\nStarted running pFBA (and FVA) @ 2024-05-29 11:01:31.059779\nRunning pFBA\nFVA list is empty\nFinished running pFBA (and FVA) @ 2024-05-29 11:01:43.139856, that took 0.20133462349573772 minutes\nStarted running pFBA (and FVA) @ 2024-05-29 11:01:43.147558\nRunning pFBA\nFVA list is empty\nFinished running pFBA (and FVA) @ 2024-05-29 11:01:56.033926, that took 0.21477279663085938 minutes\nStarted running pFBA (and FVA) @ 2024-05-29 11:01:56.054080\nRunning pFBA\nFVA list is empty\nFinished running pFBA (and FVA) @ 2024-05-29 11:02:08.338509, that took 0.20474048455556235 minutes\nStarted running pFBA (and FVA) @ 2024-05-29 11:02:08.346494\nRunning pFBA\nFVA list is empty\nFinished running pFBA (and FVA) @ 2024-05-29 11:02:21.707902, that took 0.22269012133280436 minutes\nStarted running pFBA (and FVA) @ 2024-05-29 11:02:21.716943\nRunning pFBA\nFVA list is empty\nFinished running pFBA (and FVA) @ 2024-05-29 11:02:34.071597, that took 0.20591090122858682 minutes\nStarted running pFBA (and FVA) @ 2024-05-29 11:02:34.083323\nRunning pFBA\nFVA list is empty\nFinished running pFBA (and FVA) @ 2024-05-29 11:02:45.305673, that took 0.18703916470209758 minutes\nStarted running pFBA (and FVA) @ 2024-05-29 11:02:45.319825\nRunning pFBA\nFVA list is empty\nFinished running pFBA (and FVA) @ 2024-05-29 11:02:57.736401, that took 0.20694292783737184 minutes\n\n\n\nGet the list of reactions to exclude from sum of fluxes calculation\n\nsum_fluxes_exclude = set()\nfor r in list(no_maintenance_solutions.index):\n    parts = r.split('_')\n    if parts[-1] in ['gc', 'me', 'day', 'overall', 'night']: # not in ['1', '2', '3', '4']\n        sum_fluxes_exclude.add(r)\n    else:\n        if parts[-2] in ['tx', 'pseudolinker', 'Linker', 'a']: # not in ['me', 'gc']\n            sum_fluxes_exclude.add(r)\n        else:\n            if parts[-3] in ['ae', 't', 'b', 'ep', 'tx', 'biomass']: # not in ['cv', 'p', 'xc', 'pc', 'mc', 'im', 'vc', 'mi', 'v', 'c', 'm', 'x', 'ec', 'pr', 'r', 'ce', 'cwINV']\n                sum_fluxes_exclude.add(r)\n            else:\n                if 'constraint' in r:\n                    sum_fluxes_exclude.add(r)\n\n\n# Filter solution with only metabolic reactions and transporters (with constrained H+-ATPase only)\nfiltered_df = no_maintenance_solutions.loc[~no_maintenance_solutions.index.isin(sum_fluxes_exclude), no_maintenance_solutions.columns.str.contains('_con_')]\n\n\nphase_length = {'1': 6, '2': 0.5, '3': 11.5, '4': 6}\n\ndef multiply_by_hours(row):\n    index_suffix = row.name.split('_')[-1]\n    factor = phase_length[index_suffix]\n    return row * factor\n\nscaled_df = filtered_df.apply(multiply_by_hours, axis=1)\n\n#gc_sum_flux = filtered_df[filtered_df.index.str.contains('|'.join(['_gc_1', '_gc_4']))].abs().sum()\n#me_sum_flux = filtered_df[filtered_df.index.str.contains('|'.join(['_me_1', '_me_4']))].abs().sum()\ngc_sum_flux = scaled_df[scaled_df.index.str.contains('_gc_')].abs().sum()\nme_sum_flux = scaled_df[scaled_df.index.str.contains('_me_')].abs().sum()\n\n\n#print(scaled_df)\nprint(gc_sum_flux)\nprint(me_sum_flux)\n\nblue_con_wt     0.901933\nblue_con_ko     0.899520\nwhite_con_wt    0.918848\nwhite_con_ko    0.921276\nnops_con_wt     0.201886\nnops_con_ko     0.214510\ndtype: float64\nblue_con_wt     20142.122686\nblue_con_ko     20142.122755\nwhite_con_wt    20994.863369\nwhite_con_ko    20994.863952\nnops_con_wt     20994.859108\nnops_con_ko     20994.859400\ndtype: float64\n\n\n\ngc_me_ratio = gc_sum_flux/me_sum_flux\nprint(gc_me_ratio)\n\nblue_con_wt     0.000045\nblue_con_ko     0.000045\nwhite_con_wt    0.000044\nwhite_con_ko    0.000044\nnops_con_wt     0.000010\nnops_con_ko     0.000010\ndtype: float64\n\n\n\ngc_me_ratio.head(4).mean()\n\n4.427086760474383e-05\n\n\nRatio of GC:ME maintenance = 4.427086760474383e-05 (Update value in 2.1_solvingmodel AND in supermodel.py)"
  },
  {
    "objectID": "1.2_defining_parameters.html",
    "href": "1.2_defining_parameters.html",
    "title": "Finding parameters",
    "section": "",
    "text": "In order to constrain the model using photons, osmolarity, and CO2 intake, it is necessary to have the required parameters\nimport pandas as pd\n\nmodelparameters = {}",
    "crumbs": [
      "Building model and defining parameters",
      "Finding parameters"
    ]
  },
  {
    "objectID": "1.2_defining_parameters.html#photons",
    "href": "1.2_defining_parameters.html#photons",
    "title": "Finding parameters",
    "section": "Photons",
    "text": "Photons\nThe value for photon reflectance and transmission from Zhu et al (2010)\n\n# proportion of photons absorbed by the leaf\nmodelparameters[\"P_abs\"] = [0.9, r\"Dimensionless\", \"Zhu, Long, and Ort (2010)\"]\n\nThe value for the thickness of an Arabidopsis leaf from Wuyts et al (2021)\n\nmodelparameters[\"T_l\"] = [0.017 * 10**-2, r\"m\", \"Wuyts et al. (2010)\"]\n\nThe are of the leaf being simulated was fixed at 1m\\(^2\\)\n\nmodelparameters[\"A_l\"] = [1, r\"m$^2$\", \"Fixed\"]\n\nThe average volume of an Arabidopsis guard cell as the midpoint of the values given in table 1 of Jezek and Blatt (2017)\n\nj_b_upper = 0.65\nj_b_lower = 0.3\nV_gc_ind = (j_b_lower + j_b_upper) / 2  # pL\nV_gc_ind = V_gc_ind * 10**-12  # dm3\nmodelparameters[\"V_gc_ind\"] = [V_gc_ind, r\"dm$^3$\", \"Jezek and Blatt (2017)\"]\n\nThe photosynthetic efficient of guard cells compared to the mesophyll was taken from Lawson (2003).\n\nIn leaves of all species the values of photosynthetic efficiency for guard cells were either indistinguishable from or only slightly lower (minimum of 79%) than those of the underlying, spongy mesophyll cells.\n\nI therefore took the average of 100% and 79%, 90%.\n\nmodelparameters[\"FqFm\"] = [0.9, r\"Dimensionless\", \"Lawson (2003)\"]\n\nThe proportion of the number of chloroplasts in guard cells compared to mesophyll cells is taken as the ratio of the midpoint of values for each cell type in Fujiwara et al (2019)\n\nupper_gc = 5.5\nlower_gc = 3.5\nmidpoint_gc = (lower_gc + upper_gc) / 2\n\nupper_me = 100\nlower_me = 30\nmidpoint_me = (upper_me + lower_me) / 2\n\nR_ch = midpoint_gc / midpoint_me\n\nmodelparameters[\"R_ch\"] = [R_ch, r\"Dimensionless\", \"Fujiwara, Sanjaya, and Itoh (2019)\"]\n\nThe proportion of chloroplast volumes between guard cells and mesophyll cells for Arabidopsis Col-0 based on Chl a data from Knoblauch et al. (2023) Table S1\n\nchl_vol_me = 88.24\nchl_vol_se_me = 1.58\n\nchl_vol_gc = 17.69\nchl_vol_se_gc = 0.21\n\nR_ch_vol = chl_vol_gc / chl_vol_me\n\nmodelparameters[\"R_ch_vol\"] = [R_ch_vol, r\"Dimensionless\", \"Knoblauch et al. (2023)\"]\n\nThe proportion of the leaf that is air from Earles et al (2018) for Guzmania zahnii from Table 2.\n\nmodelparameters[\"L_air\"] = [0.37, r\"Dimensionless\", \"Earles et al. (2018)\"]\n\nThe proportion of the leaf that is epidermis from Wuyts et al 2010\n\nmodelparameters[\"L_epidermis\"] = [0.15, r\"Dimensionless\", \"Wuyts et al. (2010)\"]",
    "crumbs": [
      "Building model and defining parameters",
      "Finding parameters"
    ]
  },
  {
    "objectID": "1.2_defining_parameters.html#osmolarity",
    "href": "1.2_defining_parameters.html#osmolarity",
    "title": "Finding parameters",
    "section": "Osmolarity",
    "text": "Osmolarity\nWang 2017 use a value of 0.751 to be the propotion of the Guard Cell that is vacuole\n\nmodelparameters[\"Vac_frac\"] = [\n    0.751,\n    r\"Dimensionless\",\n    \"Wang et al. (2017)\",\n]  # proportion of guard cell that is vacuole\n\nThe temperature in the model is taken to be 23C used by Horrer et al 2016.\n\nmodelparameters[\"T\"] = [273.15 + 23, \"K\", \"Horrer et al. (2016)\"]\n\nIdeal gas constant, from NIST, (reference Tiesinga2019)\n\nR = 8.205 * 10 ** (-5)  # m3atmK-1mol-1\nR = R * 10**3  # dm3atmK-1mol-1\nmodelparameters[\"R\"] = [R, r\"dm$^3$$\\cdot$atm$\\cdot$K$^{-1}$$\\cdot$mol$^{-1}$\", \"Tiesinga et al. (2019)\"]\n\nThe density of guard cells per m\\(^2\\) of leaf was taken by multiplying the density of stomata from Papanatsiou et al 2016 by two. This only takes into accound the abaxial surface of the leaf. Strangely, Flutsch et al (2020) had 98 mm\\(^2\\), which is significantly less.\n\nmodelparameters[\"N_gcs\"] = [290 * 10**6 * 2.0, r\"GCs$\\cdot$m$^{-2}$\", \"Papanatsiou, Amtmann, and Blatt (2016)\"]\n\nThe following parameters required for osmolarity are based on the updated OnGuard model (Wang et al 2017).\n\nmodelparameters[\"n\"] = [2.5, \"atm\", \"Wang et al. (2017)\"]\nmodelparameters[\"m\"] = [0.8, r\"atm$\\cdot$µm$^{-1}$\", \"Wang et al. (2017)\"]\nmodelparameters[\"r\"] = [0.05 * 10 ** (-12), r\"dm$^3$ µm$^{-1}$\", \"Wang et al. (2017)\"]\nmodelparameters[\"s\"] = [0.3 * 10 ** (-12), r\"dm$^3$\", \"Wang et al. (2017)\"]\n\n\napoplastic_concs_wang_2017 = {\n    \"K\": 10,\n    \"Ca\": 1,\n    \"Cl\": 12,\n    \"Suc\": 0.01,\n    \"MH2\": 3.2 * 10 ** (-6),\n    \"MH\": 7.9 * 10 ** (-5),\n    \"M\": 0.00999,\n}\napoplastic_conc_wang_2017 = sum(apoplastic_concs_wang_2017.values())\n\n\nmodelparameters[\"C_apo\"] = [\n    apoplastic_conc_wang_2017 * 10 ** (-3),\n    r\"mol$\\cdot$dm$^{-3}$\",\n    \"Wang et al. (2017)\",\n]  # concentration of osmolytes in the apoplast",
    "crumbs": [
      "Building model and defining parameters",
      "Finding parameters"
    ]
  },
  {
    "objectID": "1.2_defining_parameters.html#apertures",
    "href": "1.2_defining_parameters.html#apertures",
    "title": "Finding parameters",
    "section": "Apertures",
    "text": "Apertures\nWe use as a source of apertures those from Horrer et al (2016). The list is apertures for the four phases of the model.\n\nmodelparameters[\"A_closed\"] = [1.6, r\"µm\", \"Horrer et al. (2016)\"]\nmodelparameters[\"A_open\"] = [2.75, r\"µm\", \"Horrer et al. (2016)\"]\n\n\nmodelparameters_df = pd.DataFrame.from_dict(modelparameters, orient=\"index\", columns=[\"Value\", \"Units\", \"Source\"])\n\n\nmodelparameters_df\n\n\n\n\n\n\n\n\nValue\nUnits\nSource\n\n\n\n\nP_abs\n9.000000e-01\nDimensionless\nZhu, Long, and Ort (2010)\n\n\nT_l\n1.700000e-04\nm\nWuyts et al. (2010)\n\n\nA_l\n1.000000e+00\nm$^2$\nFixed\n\n\nV_gc_ind\n4.750000e-13\ndm$^3$\nJezek and Blatt (2017)\n\n\nFqFm\n9.000000e-01\nDimensionless\nLawson (2003)\n\n\nR_ch\n6.923077e-02\nDimensionless\nFujiwara, Sanjaya, and Itoh (2019)\n\n\nR_ch_vol\n2.004760e-01\nDimensionless\nKnoblauch et al. (2023)\n\n\nL_air\n3.700000e-01\nDimensionless\nEarles et al. (2018)\n\n\nL_epidermis\n1.500000e-01\nDimensionless\nWuyts et al. (2010)\n\n\nVac_frac\n7.510000e-01\nDimensionless\nWang et al. (2017)\n\n\nT\n2.961500e+02\nK\nHorrer et al. (2016)\n\n\nR\n8.205000e-02\ndm$^3$$\\cdot$atm$\\cdot$K$^{-1}$$\\cdot$mol$^{-1}$\nTiesinga et al. (2019)\n\n\nN_gcs\n5.800000e+08\nGCs$\\cdot$m$^{-2}$\nPapanatsiou, Amtmann, and Blatt (2016)\n\n\nn\n2.500000e+00\natm\nWang et al. (2017)\n\n\nm\n8.000000e-01\natm$\\cdot$µm$^{-1}$\nWang et al. (2017)\n\n\nr\n5.000000e-14\ndm$^3$ µm$^{-1}$\nWang et al. (2017)\n\n\ns\n3.000000e-13\ndm$^3$\nWang et al. (2017)\n\n\nC_apo\n2.302007e-02\nmol$\\cdot$dm$^{-3}$\nWang et al. (2017)\n\n\nA_closed\n1.600000e+00\nµm\nHorrer et al. (2016)\n\n\nA_open\n2.750000e+00\nµm\nHorrer et al. (2016)\n\n\n\n\n\n\n\n\nmodelparameters_df.to_csv(\"../inputs/arabidopsis_parameters.csv\")",
    "crumbs": [
      "Building model and defining parameters",
      "Finding parameters"
    ]
  },
  {
    "objectID": "1.0_generating_linkers.html",
    "href": "1.0_generating_linkers.html",
    "title": "Generating table for linkers/osmolytes",
    "section": "",
    "text": "This notebook describes the steps to generate the\nimport pandas as pd\nlinkers_dict = {}",
    "crumbs": [
      "Building model and defining parameters",
      "Generating table for linkers/osmolytes"
    ]
  },
  {
    "objectID": "1.0_generating_linkers.html#add-the-amino-acids-as-linker-reactions-in-the-vacuole-of-both-the-guard-cell-and-mesophyll-cell.-they-have-an-osmotic-effect-in-the-guard-cell-but-not-the-mesophyll",
    "href": "1.0_generating_linkers.html#add-the-amino-acids-as-linker-reactions-in-the-vacuole-of-both-the-guard-cell-and-mesophyll-cell.-they-have-an-osmotic-effect-in-the-guard-cell-but-not-the-mesophyll",
    "title": "Generating table for linkers/osmolytes",
    "section": "Add the amino acids as linker reactions in the vacuole of both the guard cell and mesophyll cell. They have an osmotic effect in the guard cell but not the mesophyll",
    "text": "Add the amino acids as linker reactions in the vacuole of both the guard cell and mesophyll cell. They have an osmotic effect in the guard cell but not the mesophyll\n\namino_acid_list = [\n    '4_AMINO_BUTYRATE',\n    'LEU',\n    'GLY',\n    'VAL',\n    'L_ALPHA_ALANINE',\n    'ASN',\n    'MET',\n    'LYS',\n    'THR',\n    'ILE',\n    'SER',\n    'GLT',\n    'TRP',\n    'GLN',\n    'TYR',\n    'L_ASPARTATE',\n    'PRO',\n    'PHE',\n    'HIS',\n    'bHIS',\n    'CYS',\n    'ARG',\n]\n\nfor cell, osmolarity in zip([\"me\", \"gc\"], [0, 1]):\n    for amino_acid in amino_acid_list:\n        linkers_dict[f\"{amino_acid}_v_{cell}\"] = osmolarity",
    "crumbs": [
      "Building model and defining parameters",
      "Generating table for linkers/osmolytes"
    ]
  },
  {
    "objectID": "1.0_generating_linkers.html#use-vacuolar-linkers-from-previous-diel-paper-for-mesophyll-non-osmotic-linkers",
    "href": "1.0_generating_linkers.html#use-vacuolar-linkers-from-previous-diel-paper-for-mesophyll-non-osmotic-linkers",
    "title": "Generating table for linkers/osmolytes",
    "section": "Use vacuolar linkers from previous diel paper for mesophyll non-osmotic linkers",
    "text": "Use vacuolar linkers from previous diel paper for mesophyll non-osmotic linkers\n\nme_linkers = [\n    \"MAL\",\n    \"aMAL\",\n    \"SUCROSE\",\n    \"CIT\",\n    \"aCIT\",\n]\n\nfor me_linker in me_linkers:\n    linkers_dict[f\"{me_linker}_v_me\"] = 0",
    "crumbs": [
      "Building model and defining parameters",
      "Generating table for linkers/osmolytes"
    ]
  },
  {
    "objectID": "1.0_generating_linkers.html#add-non-osmotic-apoplastic-linkers-based-on-what-has-been-found-to-be-present-in-the-apoplast-of-guard-cells",
    "href": "1.0_generating_linkers.html#add-non-osmotic-apoplastic-linkers-based-on-what-has-been-found-to-be-present-in-the-apoplast-of-guard-cells",
    "title": "Generating table for linkers/osmolytes",
    "section": "Add non-osmotic apoplastic linkers based on what has been found to be present in the apoplast of guard cells",
    "text": "Add non-osmotic apoplastic linkers based on what has been found to be present in the apoplast of guard cells\n\na_linkers = [\n    'Cl',\n    'FRU',\n    'GLC',\n    'K',\n    'MAL',\n    'NITRATE',\n    'SUCROSE',\n    'aMAL',\n]\n\nfor a_linker in a_linkers:\n    linkers_dict[f\"{a_linker}_a\"] = 0",
    "crumbs": [
      "Building model and defining parameters",
      "Generating table for linkers/osmolytes"
    ]
  },
  {
    "objectID": "1.0_generating_linkers.html#add-osmotic-linkers-to-cytoplasm-and-vacuole-of-gc-based-on-what-has-been-hypothesised-to-accumulate",
    "href": "1.0_generating_linkers.html#add-osmotic-linkers-to-cytoplasm-and-vacuole-of-gc-based-on-what-has-been-hypothesised-to-accumulate",
    "title": "Generating table for linkers/osmolytes",
    "section": "Add osmotic linkers to cytoplasm and vacuole of GC based on what has been hypothesised to accumulate",
    "text": "Add osmotic linkers to cytoplasm and vacuole of GC based on what has been hypothesised to accumulate\n\ngc_c_linkers = [\n    'CIT',\n    'Cl',\n    'FRU',\n    'GLC',\n    'K',\n    'MAL',\n    'NITRATE',\n    'SUCROSE',\n]\n\nfor gc_c_linker in gc_c_linkers:\n    linkers_dict[f\"{gc_c_linker}_c_gc\"] = 1\n\n\ngc_v_linkers = [\n    'CIT',\n    'Cl',\n    'FRU',\n    'GLC',\n    'K',\n    'MAL',\n    'NITRATE',\n    'SUCROSE',\n    'aCIT',\n    'aMAL',\n]\n\nfor gc_v_linker in gc_v_linkers:\n    linkers_dict[f\"{gc_v_linker}_v_gc\"] = 1",
    "crumbs": [
      "Building model and defining parameters",
      "Generating table for linkers/osmolytes"
    ]
  },
  {
    "objectID": "1.0_generating_linkers.html#add-starch-as-a-non-osmotic-linker-reaction-in-both-the-gc-and-me-plastid",
    "href": "1.0_generating_linkers.html#add-starch-as-a-non-osmotic-linker-reaction-in-both-the-gc-and-me-plastid",
    "title": "Generating table for linkers/osmolytes",
    "section": "Add starch as a non-osmotic linker reaction in both the gc and me plastid",
    "text": "Add starch as a non-osmotic linker reaction in both the gc and me plastid\n\nlinkers_dict[f\"STARCH_p_gc\"] = 0\nlinkers_dict[\"STARCH_p_me\"] = 0",
    "crumbs": [
      "Building model and defining parameters",
      "Generating table for linkers/osmolytes"
    ]
  },
  {
    "objectID": "1.0_generating_linkers.html#add-palmitate-fatty-acid-as-a-linker-reaction-to-the-gc-cytoplasm",
    "href": "1.0_generating_linkers.html#add-palmitate-fatty-acid-as-a-linker-reaction-to-the-gc-cytoplasm",
    "title": "Generating table for linkers/osmolytes",
    "section": "Add palmitate fatty acid as a linker reaction to the GC cytoplasm",
    "text": "Add palmitate fatty acid as a linker reaction to the GC cytoplasm\nPalmitate is the only fatty acid in the model. Adding other FAs and formation of lipids only makes a minor difference to energy costs involved (Unpublished work), so this is sufficient. Palmitate will not have an osmotic contribution because we assume it is stored in lipid droplets.\n\nlinkers_dict[f\"PALMITATE_c_gc\"] = 0",
    "crumbs": [
      "Building model and defining parameters",
      "Generating table for linkers/osmolytes"
    ]
  },
  {
    "objectID": "1.0_generating_linkers.html#add-maltose-as-a-linker-reaction-to-the-cytoplasm-of-gc-not-me",
    "href": "1.0_generating_linkers.html#add-maltose-as-a-linker-reaction-to-the-cytoplasm-of-gc-not-me",
    "title": "Generating table for linkers/osmolytes",
    "section": "Add maltose as a linker reaction to the cytoplasm of GC (not ME)",
    "text": "Add maltose as a linker reaction to the cytoplasm of GC (not ME)\nMaltose contributes to osmotic pressure with osmotic coefficient of 1 in GC.\n\n#linkers_dict[f\"MALTOSE_c_me\"] = 0\nlinkers_dict[f\"MALTOSE_c_gc\"] = 1",
    "crumbs": [
      "Building model and defining parameters",
      "Generating table for linkers/osmolytes"
    ]
  },
  {
    "objectID": "1.0_generating_linkers.html#save-as-.csv-file",
    "href": "1.0_generating_linkers.html#save-as-.csv-file",
    "title": "Generating table for linkers/osmolytes",
    "section": "Save as .csv file",
    "text": "Save as .csv file\n\nosmolytes_df = pd.DataFrame.from_dict(linkers_dict, orient=\"Index\", columns=[\"Osmotic Coefficient\"])\nosmolytes_df.index.name = \"Linker\"\nosmolytes_df.to_csv(\"../inputs/osmolytes.csv\")",
    "crumbs": [
      "Building model and defining parameters",
      "Generating table for linkers/osmolytes"
    ]
  },
  {
    "objectID": "1.0_generating_linkers.html#generate-a-prettier-df-for-investigating-here-if-wanted",
    "href": "1.0_generating_linkers.html#generate-a-prettier-df-for-investigating-here-if-wanted",
    "title": "Generating table for linkers/osmolytes",
    "section": "Generate a prettier DF for investigating here if wanted",
    "text": "Generate a prettier DF for investigating here if wanted\n\ndef get_compartment_cell(linker):\n\n    split_name = linker.split(\"_\")\n    cell = split_name[-1]\n    if cell != \"a\":\n        compartment = split_name[-2]\n        metabolite = split_name[:-2]\n    else:\n        compartment = \"NA\"\n        metabolite = split_name[:-1]\n\n    if type(metabolite) == list:\n        metabolite = \"_\".join(metabolite)\n\n    return metabolite, compartment, cell\n\n\nosmolytes_df_prettyindex = pd.MultiIndex.from_tuples([get_compartment_cell(i) for i in osmolytes_df.index], names=[\n                                                     \"Metabolite\", \"Compartment\", \"Cell\"])\nosmolytes_df.index = osmolytes_df_prettyindex\nosmolytes_df = osmolytes_df.sort_index()\nosmolytes_df\n\n\n\n\n\n\n\n\n\n\nOsmotic Coefficient\n\n\nMetabolite\nCompartment\nCell\n\n\n\n\n\n4_AMINO_BUTYRATE\nv\ngc\n1\n\n\nme\n0\n\n\nARG\nv\ngc\n1\n\n\nme\n0\n\n\nASN\nv\ngc\n1\n\n\n...\n...\n...\n...\n\n\naMAL\nNA\na\n0\n\n\nv\ngc\n1\n\n\nme\n0\n\n\nbHIS\nv\ngc\n1\n\n\nme\n0\n\n\n\n\n79 rows × 1 columns\n\n\n\n\ndef return_list_of_items(groupobject):\n    return \", \".join(list(groupobject.values.astype(\"str\")))\n\n\nlinkers_met_dict = {\n    \"SUCROSE\": \"Sucrose\",\n    \"GLC\": \"Glucose\",\n    \"FRU\": \"Fructose\",\n    \"MAL\": \"Malate\",\n    \"CIT\": \"Citrate\",\n    \"Cl\": \"Cl\",\n    \"K\": \"K\",\n    \"NITRATE\": \"Nitrate\",\n    \"aMAL\": \"aMalate\",\n    \"STARCH\": \"Starch\",\n    \"aCIT\": \"aCitrate\",\n    \"bHIS\": \"bHis\",\n}\n\nosmolytes_tidy = osmolytes_df.reset_index().set_index([\"Osmotic Coefficient\", \"Cell\", \"Compartment\"]).sort_index()\n\nleftovers = set(osmolytes_tidy.Metabolite) - set(linkers_met_dict.keys())\n\nfor l in leftovers:\n    linkers_met_dict[l] = l.capitalize()\n\nosmolytes_tidy.Metabolite = osmolytes_tidy.Metabolite.map(lambda x: linkers_met_dict[x])\nosmolytes_tidy = osmolytes_tidy.groupby([\"Osmotic Coefficient\", \"Cell\", \"Compartment\"]).agg(return_list_of_items)\nosmolytes_tidy.to_csv(\"../plant_cell_paper/supplemental_table_1.csv\")\nosmolytes_tidy\n\n\n\n\n\n\n\n\n\n\nMetabolite\n\n\nOsmotic Coefficient\nCell\nCompartment\n\n\n\n\n\n0\na\nNA\nCl, Fructose, Glucose, K, Malate, Nitrate, Suc...\n\n\ngc\nc\nPalmitate\n\n\np\nStarch\n\n\nme\np\nStarch\n\n\nv\n4_amino_butyrate, Arg, Asn, Citrate, Cys, Gln,...\n\n\n1\ngc\nc\nCitrate, Cl, Fructose, Glucose, K, Malate, Mal...\n\n\nv\n4_amino_butyrate, Arg, Asn, Citrate, Cys, Cl, ...",
    "crumbs": [
      "Building model and defining parameters",
      "Generating table for linkers/osmolytes"
    ]
  },
  {
    "objectID": "prep_plant_cell.html",
    "href": "prep_plant_cell.html",
    "title": "Preparing data for ‘The Plant Cell’ submission",
    "section": "",
    "text": "This is pretty slow as the files are large\n\nimport os\nimport cobra\n\nimport pandas as pd\n\n\ni = 1\n\n\nmodel = cobra.io.read_sbml_model(\"../models/4_stage_GC.xml\")\ncobra.io.write_sbml_model(model, f\"../plant_cell_paper/SupplementalDS{i}.xml\")\ni += 1\n\nNo objective coefficients in model. Unclear what should be optimized\n\n\n\nsup_num = f\"Supplemental Data Set {i}: Sprent at al., Metabolic modelling suggests distinct roles for sugars and carboxylic acids during stomatal opening and unexpected flux configurations in central carbon metabolism\"\nmodel_solutions_legend = \"Apart from this one, each sheet contains the solution to the scenario given by the sheet name in the format [light_scenario]_[atpase constrained or unconstrained]_[starch is wt or ko]. Rows are reaction ids, fluxes column is the solution, and minimum and maximum give the flux bounds from FVA for the reactions which it was carried out on. The following suffixes are appended to the reaction ID to indicate the cell type or time phase: _me (mesophyll); _gc (guard cell); _1, _2, _3, _4 (indicate the time phases as shown in Figure 1: night2, opening, day, night1, respectively)\"\n\n\nwith pd.ExcelWriter(f\"../plant_cell_paper/SupplementalDS{i}.xlsx\") as writer:\n    legend_df = pd.DataFrame([sup_num, model_solutions_legend])\n    legend_df.to_excel(writer, sheet_name=\"Legend\",index=False, header=False)\n    for file in os.listdir(\"../outputs/model_solutions\"):\n        filename = os.fsdecode(file)\n        if filename.endswith(\".csv\"):\n            solution_df = pd.read_csv(\"../outputs/model_solutions/\" + file, index_col=0)\n            solution_df.to_excel(writer, sheet_name=filename[:-4])\ni += 1\ni += 1 # Manually added SuppDS3\n\n\nfile_list = [\"../outputs/constraint_scan/constraints_df.csv\", \"../outputs/constraint_scan/constraint_scan_results_blue.csv\",\n             \"../outputs/constraint_scan/constraint_scan_results_white.csv\"]\nconstraints_df_legend = \"The data sheet contains the list of constraints used to constrain the model in the constraint scan\"\nscan_results_blue_legend = \"The data sheet contains the flux results for each set of constraints in the constraint scan for the model solved under blue light. The rows correspond to the constraints list and the columns to reaction IDs.\"\nscan_results_white_legend = \"The data sheet contains the flux results for each set of constraints in the constraint scan for the model solved under white light. The rows correspond to the constraints list and the columns to reaction IDs.\"\nlegend_list = [constraints_df_legend, scan_results_blue_legend, scan_results_white_legend]\n\n\nfor file, legend in zip(file_list, legend_list):\n    with pd.ExcelWriter(f\"../plant_cell_paper/SupplementalDS{i}.xlsx\") as writer:\n        sup_num = f\"Supplemental Data Set {i}: Sprent at al., Metabolic modelling suggests distinct roles for sugars and carboxylic acids during stomatal opening and unexpected flux configurations in central carbon metabolism\"\n        legend_df = pd.DataFrame([sup_num, legend])\n        legend_df.to_excel(writer, sheet_name=\"Legend\",index=False, header=False)\n        file_df = pd.read_csv(file, index_col=0)\n        #if \"constraints_df\" in file:\n            #file_df.drop('Maintenance', axis=1, inplace=True)\n        file_df.to_excel(writer, sheet_name=\"Data\")\n        i += 1\n\n\n#for light in [\"blue\", \"white\", \"nops\"]:\n#    for atpase in [\"unconstrained\", \"constrained\"]:\n#        for starch in [\"wt\", \"ko\"]:\n#            filename = f\"../outputs/alternative_weighting/solution_{light}_{atpase}_{starch}.csv\"\n#            legend = f\"The data sheet contains the results for solving the alternative weightings for the scenario with {light} light, {atpase} ATPase, and {starch} starch. The columns are reaction IDs and the rows match the alternative weights given in Supplemental Data Set 6\"\n#            try:\n#                with pd.ExcelWriter(f\"../plant_cell_paper/SupplementalDS{i}.xlsx\") as writer:\n#                    legend_df = pd.DataFrame([legend])\n#                    legend_df.to_excel(writer, sheet_name=\"Legend\",index=False, header=False)\n#                    solution_df = pd.read_csv(filename, index_col=0)\n#                    solution_df.to_excel(writer, sheet_name=\"Data\")\n#\n#                i += 1\n#\n#            except:\n#                print(f\"No solution for {light}, {atpase}, {starch}\")"
  },
  {
    "objectID": "2.1_solvingmodel.html",
    "href": "2.1_solvingmodel.html",
    "title": "Solving guard cell models for different parameters",
    "section": "",
    "text": "# This cell isn't exported to the .py file, so define here if running in notebook rather than as .py on e.g.a cluster\n# This is where to adjust whether fva is run if running in notebook\nargs = {\n    \"run_fva\": \"True\",\n    \"no_processes\": 4,\n    \"output_dir\": \"../outputs/model_solutions/\",\n    \"model_file\": \"../models/4_stage_GC.xml\",\n    \"map_file\": \"../inputs/map.json\",\n    \"parameters_file\": \"../inputs/arabidopsis_parameters.csv\",\n}\n\nsys.argv = [\"script_name\"] + list(args.values())",
    "crumbs": [
      "Solving and analysing specific scenarios for paper",
      "Solving guard cell models for different parameters"
    ]
  },
  {
    "objectID": "2.1_solvingmodel.html#setup",
    "href": "2.1_solvingmodel.html#setup",
    "title": "Solving guard cell models for different parameters",
    "section": "",
    "text": "# This cell isn't exported to the .py file, so define here if running in notebook rather than as .py on e.g.a cluster\n# This is where to adjust whether fva is run if running in notebook\nargs = {\n    \"run_fva\": \"True\",\n    \"no_processes\": 4,\n    \"output_dir\": \"../outputs/model_solutions/\",\n    \"model_file\": \"../models/4_stage_GC.xml\",\n    \"map_file\": \"../inputs/map.json\",\n    \"parameters_file\": \"../inputs/arabidopsis_parameters.csv\",\n}\n\nsys.argv = [\"script_name\"] + list(args.values())",
    "crumbs": [
      "Solving and analysing specific scenarios for paper",
      "Solving guard cell models for different parameters"
    ]
  },
  {
    "objectID": "2.1_solvingmodel.html#instantiate-and-apply-base-constraints-to-model",
    "href": "2.1_solvingmodel.html#instantiate-and-apply-base-constraints-to-model",
    "title": "Solving guard cell models for different parameters",
    "section": "Instantiate and apply base constraints to model",
    "text": "Instantiate and apply base constraints to model\n\nImport FBA model\nDecrease tolerance\n\n\nDefine reactions to use for FVA\n\n\nInstantiate Supermodel\nImport parameters from csv, created in parameters notebook\nThis is a little different to Jezek and Blatt (2017), where they have closed as 0.3-0.4pL and open as 0.5-0.65. Open apertures are on the small side but still within their range (2-6). Wang used a volume of 0.4pL.\n\n\nConstrain SuperModel\n\nConstrain osmolarity of the model using the equation from the OnGuard model (Hills et al 2012)\n\nimport numpy as np\n\n\nnp.array(arabidopsis_supermodel.get_osmolarities())\n\narray([0.03935933, 0.05492236, 0.03935933, 0.03935933])\n\n\n\nhelp(arabidopsis_supermodel.get_osmolarities)\n\nHelp on method get_osmolarities in module mmon_gcm.supermodel:\n\nget_osmolarities(apertures='default', equation='onguard', printouts=False) method of mmon_gcm.supermodel.SuperModel instance\n    Calculates the osmolarities at each phase of the model using the equation\n    specified, default is onguard. Adds these as an attribute to the SuperModel\n\n\n\n\nmmoles_per_m2 = np.array(arabidopsis_supermodel.get_osmolarities())\nmmoles_per_gc = mmoles_per_m2 / arabidopsis_supermodel.N_gcs\nmoles_per_gc = mmoles_per_gc * 10**-3\nfmoles_per_gc = moles_per_gc / 10**-15\nprint(f\"Closed fmoles: {fmoles_per_gc[0]}\")\nprint(f\"Open fmoles: {fmoles_per_gc[1]}\")\nprint(f\"Increase in fmoles: {fmoles_per_gc[1] - fmoles_per_gc[0]}\")\n\nClosed fmoles: 67.86090968309483\nOpen fmoles: 94.69373119804636\nIncrease in fmoles: 26.832821514951533\n\n\n\n\nConstrain photons using a PPFD of 150µmolm\\(^{-2}\\)s\\(^{-1}\\), same as used in Horrer et al (2016)",
    "crumbs": [
      "Solving and analysing specific scenarios for paper",
      "Solving guard cell models for different parameters"
    ]
  },
  {
    "objectID": "2.1_solvingmodel.html#add-maintenance-constraint-to-model",
    "href": "2.1_solvingmodel.html#add-maintenance-constraint-to-model",
    "title": "Solving guard cell models for different parameters",
    "section": "Add maintenance constraint to model",
    "text": "Add maintenance constraint to model\ngc_ratio is the ratio of gc vs me maintenance obtained from 2.0_compute_maintenance\n\nTest blocking Complex III in blue light WT\n\narabidopsis_supermodel.fba_model.reactions.get_by_id(\"SUCCINATE_DEHYDROGENASE_UBIQUINONE_RXN_mc_gc_2\").bounds = 0, 0\narabidopsis_supermodel.fba_model.reactions.get_by_id(\"SUCCINATE_DEHYDROGENASE_UBIQUINONE_RXN_mi_gc_2\").bounds = 0, 0\n\narabidopsis_supermodel.constrain_photons(PPFD, printouts=False)\nwith arabidopsis_supermodel.fba_model as m:\n    m.reactions.Photon_tx_gc_2.upper_bound = 0\n    m.reactions.Photon_tx_me_2.upper_bound = 0\n    # Added this line to explictly set bounds for starch degradation\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"RXN_1827_p_gc\", 0, cobra.Configuration().upper_bound)\n\n    gc_atpase_upper_bound = arabidopsis_supermodel.get_atpase_constraint_value(7.5)\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"PROTON_ATPase_c_gc\", 0, gc_atpase_upper_bound)\n\n    (no_CIII, no_CIII_sol) = mmon_gcm.solving.get_pfba_fva_solution(m, rxn_list=[], processes=no_processes)\n\nStarted running pFBA (and FVA) @ 2024-06-20 18:29:37.018698\nRunning pFBA\nFVA list is empty\nFinished running pFBA (and FVA) @ 2024-06-20 18:29:48.834174, that took 0.19692460695902506 minutes\n\n\n\narabidopsis_supermodel.fba_model.reactions.get_by_id(\"SUCCINATE_DEHYDROGENASE_UBIQUINONE_RXN_mc_gc_2\").bounds = 0, cobra.Configuration().upper_bound\narabidopsis_supermodel.fba_model.reactions.get_by_id(\"SUCCINATE_DEHYDROGENASE_UBIQUINONE_RXN_mi_gc_2\").bounds = 0, cobra.Configuration().upper_bound\n\narabidopsis_supermodel.constrain_photons(PPFD, printouts=False)\nwith arabidopsis_supermodel.fba_model as m:\n    m.reactions.Photon_tx_gc_2.upper_bound = 0\n    m.reactions.Photon_tx_me_2.upper_bound = 0\n    # Added this line to explictly set bounds for starch degradation\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"RXN_1827_p_gc\", 0, cobra.Configuration().upper_bound)\n\n    gc_atpase_upper_bound = arabidopsis_supermodel.get_atpase_constraint_value(7.5)\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"PROTON_ATPase_c_gc\", 0, gc_atpase_upper_bound)\n\n    (CIII, CIII_sol) = mmon_gcm.solving.get_pfba_fva_solution(m, rxn_list=[], processes=no_processes)\n\nStarted running pFBA (and FVA) @ 2024-06-20 18:29:25.458722\nRunning pFBA\nFVA list is empty\nFinished running pFBA (and FVA) @ 2024-06-20 18:29:37.003048, that took 0.19240544239679971 minutes\n\n\n\nCIII_sol.loc['Phloem_tx_overall'].loc['fluxes']\n\n14.25882479432091\n\n\n\nno_CIII_sol.loc['Phloem_tx_overall'].loc['fluxes']\n\n14.258823306193605\n\n\nPhloem_tx_overall: 14.258823306193605 without Complex III; 14.25882479432091 with Complex III\n\n\nTest for maltose degradation pathways\n\narabidopsis_supermodel.fba_model.reactions.get_by_id(\"RXN_2141_p_gc_2\").bounds = 0, 0\narabidopsis_supermodel.fba_model.reactions.get_by_id(\"RXN_2141_p_gc_2\").bounds = 0, 0\n\narabidopsis_supermodel.constrain_photons(PPFD, printouts=False)\nwith arabidopsis_supermodel.fba_model as m:\n    m.reactions.Photon_tx_gc_2.upper_bound = 0\n    m.reactions.Photon_tx_me_2.upper_bound = 0\n    # Added this line to explictly set bounds for starch degradation\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"RXN_1827_p_gc\", 0, cobra.Configuration().upper_bound)\n\n    gc_atpase_upper_bound = arabidopsis_supermodel.get_atpase_constraint_value(7.5)\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"PROTON_ATPase_c_gc\", 0, gc_atpase_upper_bound)\n\n    (maltose_c, maltose_c_sol) = mmon_gcm.solving.get_pfba_fva_solution(m, rxn_list=[], processes=no_processes)\n\nStarted running pFBA (and FVA) @ 2024-06-20 21:03:53.851992\nRunning pFBA\nFVA list is empty\nFinished running pFBA (and FVA) @ 2024-06-20 21:04:05.724912, that took 0.19788201252619425 minutes\n\n\n\narabidopsis_supermodel.fba_model.reactions.get_by_id(\"RXN_2141_p_gc_2\").bounds = 0, cobra.Configuration().upper_bound\narabidopsis_supermodel.fba_model.reactions.get_by_id(\"RXN_2141_p_gc_2\").bounds = 0, cobra.Configuration().upper_bound\n\narabidopsis_supermodel.constrain_photons(PPFD, printouts=False)\nwith arabidopsis_supermodel.fba_model as m:\n    m.reactions.Photon_tx_gc_2.upper_bound = 0\n    m.reactions.Photon_tx_me_2.upper_bound = 0\n    # Added this line to explictly set bounds for starch degradation\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"RXN_1827_p_gc\", 0, cobra.Configuration().upper_bound)\n\n    gc_atpase_upper_bound = arabidopsis_supermodel.get_atpase_constraint_value(7.5)\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"PROTON_ATPase_c_gc\", 0, gc_atpase_upper_bound)\n\n    (maltose_pc, maltose_pc_sol) = mmon_gcm.solving.get_pfba_fva_solution(m, rxn_list=[], processes=no_processes)\n\nStarted running pFBA (and FVA) @ 2024-06-20 21:03:40.588376\nRunning pFBA\nFVA list is empty\nFinished running pFBA (and FVA) @ 2024-06-20 21:03:53.784066, that took 0.21992816925048828 minutes\n\n\n\nmaltose_pc_sol.loc[['Phloem_tx_overall', 'RXN_2141_p_gc_2', 'MALTODEG_RXN_c_gc_2']]['fluxes']\n\nPhloem_tx_overall      1.425882e+01\nRXN_2141_p_gc_2        5.259830e-03\nMALTODEG_RXN_c_gc_2   -2.062496e-13\nName: fluxes, dtype: float64\n\n\n\nmaltose_pc_sol.loc['Phloem_tx_overall'].loc['fluxes']\n\n14.258823306193605\n\n\n\nmaltose_c_sol.loc[['Phloem_tx_overall', 'RXN_2141_p_gc_2', 'MALTODEG_RXN_c_gc_2']]['fluxes']\n\nPhloem_tx_overall      14.258821\nRXN_2141_p_gc_2         0.000000\nMALTODEG_RXN_c_gc_2     0.006945\nName: fluxes, dtype: float64\n\n\n\nmaltose_c_sol.loc['Phloem_tx_overall'].loc['fluxes']\n\n14.258821433564357\n\n\n\n(maltose_pc_sol.loc['Phloem_tx_overall'].loc['fluxes']-maltose_c_sol.loc['Phloem_tx_overall'].loc['fluxes'])/maltose_pc_sol.loc['Phloem_tx_overall'].loc['fluxes']\n\n1.3133126120572098e-07\n\n\n\nmaltose_c_sol.loc[['GLC_c_gc_Linker_2', 'MALTOSE_c_gc_Linker_2', 'GLC_c_gc_Linker_1', 'MALTOSE_c_gc_Linker_1']]['fluxes']\n\nGLC_c_gc_Linker_2        0.003473\nMALTOSE_c_gc_Linker_2    0.006744\nGLC_c_gc_Linker_1        0.000000\nMALTOSE_c_gc_Linker_1    0.006744\nName: fluxes, dtype: float64\n\n\n\nprint(maltose_c_sol[maltose_c_sol.index.str.contains(\"gc_2\") & (maltose_c_sol['fluxes'].abs() &gt; 0.0000001)].sort_values(by='fluxes').to_string())\n\n                                             fluxes  minimum  maximum\nPi_PROTON_mc_gc_2                         -0.010418      NaN      NaN\nH2O_pc_gc_2                               -0.007739      NaN      NaN\nEX_X_O2_t_gc_2                            -0.001810      NaN      NaN\nCO2_tx_gc_2                               -0.001810      NaN      NaN\nCO2_ec_gc_2                               -0.001810      NaN      NaN\nISOCITDEH_RXN_c_gc_2                      -0.001736      NaN      NaN\nOAA_MAL_pc_gc_2                           -0.001736      NaN      NaN\nO2_mc_gc_2                                -0.001736      NaN      NaN\nPGLUCISOM_RXN_p_gc_2                      -0.001207      NaN      NaN\nX5P_Pi_pc_gc_2                            -0.000868      NaN      NaN\nRIB5PISOM_RXN_p_gc_2                      -0.000603      NaN      NaN\n1TRANSKETO_RXN_p_gc_2                     -0.000603      NaN      NaN\nF16ALDOLASE_RXN_c_gc_2                    -0.000302      NaN      NaN\n2_PERIOD_7_PERIOD_1_PERIOD_90_RXN_c_gc_2  -0.000302      NaN      NaN\nGLUC1PURIDYLTRANS_RXN_c_gc_2              -0.000138      NaN      NaN\nUDPKIN_RXN_c_gc_2                         -0.000138      NaN      NaN\nO2_pc_gc_2                                -0.000074      NaN      NaN\nNADPHox_p_tx_gc_2                          0.000148      NaN      NaN\nPROTON_PPi_rev_vc_gc_2                     0.000164      NaN      NaN\nG6P_Pi_pc_gc_2                             0.000265      NaN      NaN\nTRIOSEPISOMERIZATION_RXN_p_gc_2            0.000302      NaN      NaN\nDHAP_Pi_pc_gc_2                            0.000302      NaN      NaN\nGAP_Pi_pc_gc_2                             0.000302      NaN      NaN\nRIBULP3EPIM_RXN_p_gc_2                     0.000339      NaN      NaN\nATPase_tx_gc_2                             0.000444      NaN      NaN\n2TRANSKETO_RXN_p_gc_2                      0.000603      NaN      NaN\nTRANSALDOL_RXN_p_gc_2                      0.000603      NaN      NaN\nGLU6PDEHYDROG_RXN_c_gc_2                   0.000868      NaN      NaN\n6PGLUCONOLACT_RXN_c_gc_2                   0.000868      NaN      NaN\nRIBULP3EPIM_RXN_c_gc_2                     0.000868      NaN      NaN\n6PGLUCONDEHYDROG_RXN_c_gc_2                0.000868      NaN      NaN\nCO2_pc_gc_2                                0.000942      NaN      NaN\n6PGLUCONDEHYDROG_RXN_p_gc_2                0.000942      NaN      NaN\nGLU6PDEHYDROG_RXN_p_gc_2                   0.000942      NaN      NaN\n6PGLUCONOLACT_RXN_p_gc_2                   0.000942      NaN      NaN\nMALATE_DEHYDROGENASE_NADPs_RXN_p_gc_2      0.001736      NaN      NaN\n2KG_MAL_mc_gc_2                            0.001736      NaN      NaN\nCO2_mc_gc_2                                0.001736      NaN      NaN\nMALATE_DEH_RXN_m_gc_2                      0.001736      NaN      NaN\nCYTOCHROME_C_OXIDASE_RXN_mi_gc_2           0.001736      NaN      NaN\nISOCITRATE_DEHYDROGENASE_NAD_RXN_m_gc_2    0.001736      NaN      NaN\nOAA_ISOCITRATE_mc_gc_2                     0.001736      NaN      NaN\nEX_X_CO2_t_gc_2                            0.001810      NaN      NaN\nO2_ec_gc_2                                 0.001810      NaN      NaN\nO2_tx_gc_2                                 0.001810      NaN      NaN\nMitochondrial_ATP_Synthase_m_gc_2          0.003473      NaN      NaN\n1_PERIOD_10_PERIOD_2_PERIOD_2_RXN_mi_gc_2  0.003473      NaN      NaN\nNADH_DEHYDROG_A_RXN_mi_gc_2                0.003473      NaN      NaN\nCl_PROTON_ec_gc_2                          0.004350      NaN      NaN\nPROTON_ATPase_c_gc_2                       0.004350      NaN      NaN\nPROTONATP_rev_vc_gc_2                      0.005762      NaN      NaN\nPGLUCISOM_RXN_c_gc_2                       0.006479      NaN      NaN\nSUCROSE_PHOSPHATE_SYNTHASE_RXN_c_gc_2      0.006781      NaN      NaN\nSUCROSE_PHOSPHATASE_RXN_c_gc_2             0.006781      NaN      NaN\nSUCROSE_SYNTHASE_RXN_c_gc_2                0.006919      NaN      NaN\nRXN_14351_pc_gc_2                          0.006945      NaN      NaN\nRXN_1827_p_gc_2                            0.006945      NaN      NaN\nMALTODEG_RXN_c_gc_2                        0.006945      NaN      NaN\nRXN0_5184_c_gc_2                           0.006945      NaN      NaN\nPHOSPHOGLUCMUT_RXN_c_gc_2                  0.007083      NaN      NaN\nCl_ae_gc_2                                 0.008700      NaN      NaN\nK_ec_gc_2                                  0.008700      NaN      NaN\nK_ae_gc_2                                  0.008700      NaN      NaN\nATP_ADP_mc_gc_2                            0.010418      NaN      NaN\nK_PROTON_cv_gc_2                           0.011688      NaN      NaN\nCl_cv_gc_2                                 0.011688      NaN      NaN\nH2O_ec_gc_2                                0.012217      NaN      NaN\nWATER_ae_gc_2                              0.012217      NaN      NaN\npseudoOs_constraint_c_gc_2                 0.013676      NaN      NaN\nH2O_mc_gc_2                                0.013891      NaN      NaN\npseudoOs_constraint_v_gc_2                 0.041247      NaN      NaN",
    "crumbs": [
      "Solving and analysing specific scenarios for paper",
      "Solving guard cell models for different parameters"
    ]
  },
  {
    "objectID": "2.1_solvingmodel.html#blue-light",
    "href": "2.1_solvingmodel.html#blue-light",
    "title": "Solving guard cell models for different parameters",
    "section": "Blue Light",
    "text": "Blue Light\n\nATPase unconstrained\n\nWT\n\n\nStarch KO\n\n\n\nConstrained ATPase\n\nWT\n\n\nStarch KO",
    "crumbs": [
      "Solving and analysing specific scenarios for paper",
      "Solving guard cell models for different parameters"
    ]
  },
  {
    "objectID": "2.1_solvingmodel.html#white-light",
    "href": "2.1_solvingmodel.html#white-light",
    "title": "Solving guard cell models for different parameters",
    "section": "White Light",
    "text": "White Light\n\nUnconstrained ATPase\n\nWT\n\n\nStarch KO\n\n\n\nConstrained ATPase\n\nWT\n\n\nStarch KO",
    "crumbs": [
      "Solving and analysing specific scenarios for paper",
      "Solving guard cell models for different parameters"
    ]
  },
  {
    "objectID": "2.1_solvingmodel.html#guard-cell-has-no-photosynthetic-capacity",
    "href": "2.1_solvingmodel.html#guard-cell-has-no-photosynthetic-capacity",
    "title": "Solving guard cell models for different parameters",
    "section": "Guard cell has no photosynthetic capacity",
    "text": "Guard cell has no photosynthetic capacity\n\nUnconstrained ATPase\n\nWT\n\n\nStarch KO\n\n\n\nConstrained ATPase\n\nWT\n\n\nStarch KO",
    "crumbs": [
      "Solving and analysing specific scenarios for paper",
      "Solving guard cell models for different parameters"
    ]
  },
  {
    "objectID": "2.1_solvingmodel.html#scan-gc-photon-influx-to-look-at-switch-of-glycolysis",
    "href": "2.1_solvingmodel.html#scan-gc-photon-influx-to-look-at-switch-of-glycolysis",
    "title": "Solving guard cell models for different parameters",
    "section": "Scan GC photon influx to look at switch of glycolysis",
    "text": "Scan GC photon influx to look at switch of glycolysis\n\nP_gc, P_me = arabidopsis_supermodel.get_photons(PPFD=PPFD, printouts=False)\n\nfor i, p in enumerate([0, P_me, P_me, 0], start=1):\n    arabidopsis_supermodel.fba_model.reactions.get_by_id(\"Photon_tx_me_\" + str(i)).bounds = 0, p\n\nwith arabidopsis_supermodel.fba_model as m:\n    # Added this line to explictly set bounds for starch degradation\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"RXN_1827_p_gc\", 0, cobra.Configuration().upper_bound)\n\n    gc_atpase_upper_bound = arabidopsis_supermodel.get_atpase_constraint_value(7.5)\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"PROTON_ATPase_c_gc\", 0, gc_atpase_upper_bound)\n\n    scan_df = pd.DataFrame()\n    for photon in range(PPFD+1):\n        P_gc, P_me = arabidopsis_supermodel.get_photons(PPFD=photon, printouts=False)\n        for i, p in enumerate([0, P_gc, P_gc, 0], start=1):\n            m.reactions.get_by_id(\"Photon_tx_gc_\" + str(i)).bounds = 0, p\n        cobra_model, solution = mmon_gcm.solving.pfba_Weighted(m, objective=\"Phloem_tx_overall\")\n        scan_df[photon] = solution.fluxes\n        print(photon, solution.fluxes['Photon_tx_gc_2'], solution.fluxes['Photon_tx_me_2'])\nscan_df.to_csv(\"../outputs/scans/gc_photon_scan.csv\")\n\n0 0.0 485.98162812525\n1 0.000122479164998293 485.98162812525\n2 0.000244958329996587 485.98162812525\n3 0.00036743749499488 485.98162812525\n4 0.000489916659993173 485.98162812525\n5 0.000612395824991467 485.98162812525\n6 0.00073487498998976 485.98162812525\n7 0.000857354154988053 485.98162812525\n8 0.000979833319986346 485.98162812525\n9 0.00110231248498464 485.98162812525\n10 0.00122479164998293 485.98162812525\n11 0.00134727081498123 485.98162812525\n12 0.00146974997997952 485.98162812525\n13 0.00159222914497781 485.98162812525\n14 0.00171470830997611 485.98162812525\n15 0.0018371874749744 485.98162812525\n16 0.00195966663997269 485.98162812525\n17 0.00208214580497099 485.98162812525\n18 0.00220462496996928 485.98162812525\n19 0.00232710413496757 485.98162812525\n20 0.00244958329996587 485.98162812525\n21 0.00257206246496416 485.98162812525\n22 0.00269454162996245 485.98162812525\n23 0.00281702079496075 485.98162812525\n24 0.00293949995995904 485.98162812525\n25 0.00306197912495733 485.98162812525\n26 0.00318445828995563 485.98162812525\n27 0.00330693745495392 485.98162812525\n28 0.00342941661995221 485.98162812525\n29 0.00355189578495051 485.98162812525\n30 0.0036743749499488 485.98162812525\n31 0.00379685411494709 485.98162812525\n32 0.00391933327994539 485.98162812525\n33 0.00404181244494368 485.98162812525\n34 0.00416429160994197 485.98162812525\n35 0.00428677077494027 485.98162812525\n36 0.00440924993993856 485.98162812525\n37 0.00453172910493685 485.98162812525\n38 0.00465420826993515 485.98162812525\n39 0.00477668743493344 485.98162812525\n40 0.00489916659993173 485.98162812525\n41 0.00502164576493003 485.98162812525\n42 0.00514412492992832 485.98162812525\n43 0.00526660409492661 485.98162812525\n44 0.00538908325992491 485.98162812525\n45 0.0055115624249232 485.98162812525\n46 0.00563404158992149 485.98162812525\n47 0.00575652075491979 485.98162812525\n48 0.00587899991991808 485.98162812525\n49 0.00600147908491637 485.98162812525\n50 0.00612395824991467 485.98162812525\n51 0.00624643741491296 485.98162812525\n52 0.00636891657991125 485.98162812525\n53 0.00649139574490955 485.98162812525\n54 0.00661387490990784 485.98162812525\n55 0.00673635407490613 485.98162812525\n56 0.00685883323990443 485.98162812525\n57 0.00698131240490272 485.98162812525\n58 0.00710379156990101 485.98162812525\n59 0.00722627073489931 485.98162812525\n60 0.0073487498998976 485.98162812525\n61 0.00747122906489589 485.98162812525\n62 0.00759370822989419 485.98162812525\n63 0.00771618739489248 485.98162812525\n64 0.00783866655989077 485.98162812525\n65 0.00796114572488907 485.98162812525\n66 0.00808362488988736 485.98162812525\n67 0.00820610405488565 485.98162812525\n68 0.00832858321988395 485.98162812525\n69 0.00845106238488224 485.98162812525\n70 0.00857354154988053 485.98162812525\n71 0.00869602071487883 485.98162812525\n72 0.00881849987987712 485.98162812525\n73 0.00894097904487541 485.98162812525\n74 0.00906345820987371 485.98162812525\n75 0.009185937374872 485.98162812525\n76 0.00930841653987029 485.98162812525\n77 0.00943089570486859 485.98162812525\n78 0.00955337486986688 485.98162812525\n79 0.00967585403486517 485.98162812525\n80 0.00979833319986347 485.98162812525\n81 0.00992081236486176 485.98162812525\n82 0.0100432915298601 485.98162812525\n83 0.0101657706948583 485.98162812525\n84 0.0102882498598566 485.98162812525\n85 0.0104107290248549 485.98162812525\n86 0.0105332081898532 485.98162812525\n87 0.0106556873548515 485.98162812525\n88 0.0107781665198498 485.98162812525\n89 0.0109006456848481 485.98162812525\n90 0.0110231248498464 485.98162812525\n91 0.0111456040148447 485.98162812525\n92 0.011268083179843 485.98162812525\n93 0.0113905623448413 485.98162812525\n94 0.0115130415098396 485.98162812525\n95 0.0116355206748379 485.98162812525\n96 0.0117579998398362 485.98162812525\n97 0.0118804790048345 485.98162812525\n98 0.0120029581698327 485.98162812525\n99 0.012125437334831 485.98162812525\n100 0.0122479164998293 485.98162812525\n101 0.0123703956648276 485.98162812525\n102 0.0124928748298259 485.98162812525\n103 0.0126153539948242 485.98162812525\n104 0.0127378331598225 485.98162812525\n105 0.0128603123248208 485.98162812525\n106 0.0129827914898191 485.98162812525\n107 0.0131052706548174 485.98162812525\n108 0.0132277498198157 485.98162812525\n109 0.013350228984814 485.98162812525\n110 0.0134727081498123 485.98162812525\n111 0.0135951873148106 485.98162812525\n112 0.0137176664798089 485.98162812525\n113 0.0138401456448071 485.98162812525\n114 0.0139626248098054 485.98162812525\n115 0.0140851039748037 485.98162812525\n116 0.014207583139802 485.98162812525\n117 0.0143300623048003 485.98162812525\n118 0.0144525414697986 485.98162812525\n119 0.0145750206347969 485.98162812525\n120 0.0146974997997952 485.98162812525\n121 0.0148199789647935 485.98162812525\n122 0.0149424581297918 485.98162812525\n123 0.0150649372947901 485.98162812525\n124 0.0151874164597884 485.98162812525\n125 0.0153098956247867 485.98162812525\n126 0.015432374789785 485.98162812525\n127 0.0155548539547832 485.98162812525\n128 0.0156773331197815 485.98162812525\n129 0.0157998122847798 485.98162812525\n130 0.0159222914497781 485.98162812525\n131 0.0160447706147764 485.98162812525\n132 0.0161672497797747 485.98162812525\n133 0.016289728944773 485.98162812525\n134 0.0164122081097713 485.98162812525\n135 0.0165346872747696 485.98162812525\n136 0.0166571664397679 485.98162812525\n137 0.0167796456047662 485.98162812525\n138 0.0169021247697645 485.98162812525\n139 0.0170246039347628 485.98162812525\n140 0.0171470830997611 485.98162812525\n141 0.0172695622647594 485.98162812525\n142 0.0173920414297577 485.98162812525\n143 0.0175145205947559 485.98162812525\n144 0.0176369997597542 485.98162812525\n145 0.0177594789247525 485.98162812525\n146 0.0178819580897508 485.98162812525\n147 0.0180044372547491 485.98162812525\n148 0.0181269164197474 485.98162812525\n149 0.0182493955847457 485.98162812525\n150 0.018371874749744 485.98162812525\n\n\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4142017668.py:19: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes",
    "crumbs": [
      "Solving and analysing specific scenarios for paper",
      "Solving guard cell models for different parameters"
    ]
  },
  {
    "objectID": "2.1_solvingmodel.html#scan-gc-me-photosynthesis-photon-influx-during-opening",
    "href": "2.1_solvingmodel.html#scan-gc-me-photosynthesis-photon-influx-during-opening",
    "title": "Solving guard cell models for different parameters",
    "section": "Scan GC & ME photosynthesis (photon influx) during Opening",
    "text": "Scan GC & ME photosynthesis (photon influx) during Opening\nIncrease upper bound of photon influx in GC & ME during blue light\n\nP_gc_day, P_me_day = arabidopsis_supermodel.get_photons(PPFD=PPFD, printouts=False)\n\nwith arabidopsis_supermodel.fba_model as m:\n    # Added this line to explictly set bounds for starch degradation\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"RXN_1827_p_gc\", 0, cobra.Configuration().upper_bound)\n\n    gc_atpase_upper_bound = arabidopsis_supermodel.get_atpase_constraint_value(7.5)\n    mmon_gcm.buildingediting.set_bounds_multi(m, \"PROTON_ATPase_c_gc\", 0, gc_atpase_upper_bound)\n\n    scan_df = pd.DataFrame()\n    for photon in range(PPFD+1):\n        P_gc_open, P_me_open = arabidopsis_supermodel.get_photons(PPFD=photon, printouts=False)\n        for i, p in enumerate([0, P_me_open, P_me_day, 0], start=1):\n            m.reactions.get_by_id(\"Photon_tx_me_\" + str(i)).bounds = 0, p\n        for i, p in enumerate([0, P_gc_open, P_gc_day, 0], start=1):\n            m.reactions.get_by_id(\"Photon_tx_gc_\" + str(i)).bounds = 0, p\n        cobra_model, solution = mmon_gcm.solving.pfba_Weighted(m, objective=\"Phloem_tx_overall\")\n        scan_df[photon] = solution.fluxes\n        print(photon, solution.fluxes['Photon_tx_gc_2'], solution.fluxes['Photon_tx_me_2'],\n              solution.fluxes['Photon_tx_gc_3'], solution.fluxes['Photon_tx_me_3'])\nscan_df.to_csv(\"../outputs/scans/opening_photon_scan.csv\")\n\n0 0.0 0.0 0.018371874749744 485.98162812525\n1 0.000122479164998293 3.239877520835 0.018371874749744 485.98162812525\n2 0.000244958329996587 6.47975504167 0.018371874749744 485.98162812525\n3 0.00036743749499488 9.71963256250501 0.018371874749744 485.98162812525\n4 0.000489916659993173 12.95951008334 0.018371874749744 485.98162812525\n5 0.000612395824991467 16.199387604175 0.018371874749744 485.98162812525\n6 0.00073487498998976 19.43926512501 0.018371874749744 485.98162812525\n7 0.000857354154988053 22.679142645845 0.018371874749744 485.98162812525\n8 0.000979833319986346 25.91902016668 0.018371874749744 485.98162812525\n9 0.00110231248498464 29.158897687515 0.018371874749744 485.98162812525\n10 0.00122479164998293 32.39877520835 0.018371874749744 485.98162812525\n11 0.00134727081498123 35.638652729185 0.018371874749744 485.98162812525\n12 0.00146974997997952 38.87853025002 0.018371874749744 485.98162812525\n13 0.00159222914497781 42.118407770855 0.018371874749744 485.98162812525\n14 0.00171470830997611 45.35828529169 0.018371874749744 485.98162812525\n15 0.0018371874749744 48.598162812525 0.018371874749744 485.98162812525\n16 0.00195966663997269 51.83804033336 0.018371874749744 485.98162812525\n17 0.00208214580497099 55.077917854195 0.018371874749744 485.98162812525\n18 0.00220462496996928 58.31779537503 0.018371874749744 485.98162812525\n19 0.00232710413496757 61.557672895865 0.018371874749744 485.98162812525\n20 0.00244958329996587 64.7975504167 0.018371874749744 485.98162812525\n21 0.00257206246496416 68.037427937535 0.018371874749744 485.98162812525\n22 0.00269454162996245 71.2773054583701 0.018371874749744 485.98162812525\n23 0.00281702079496075 74.517182979205 0.018371874749744 485.98162812525\n24 0.00293949995995904 77.75706050004 0.018371874749744 485.98162812525\n25 0.00306197912495733 80.996938020875 0.018371874749744 485.98162812525\n26 0.00318445828995563 84.2368155417101 0.018371874749744 485.98162812525\n27 0.00330693745495392 87.4766930625451 0.018371874749744 485.98162812525\n28 0.00342941661995221 90.71657058338 0.018371874749744 485.98162812525\n29 0.00355189578495051 93.9564481042151 0.018371874749744 485.98162812525\n30 0.0036743749499488 97.19632562505 0.018371874749744 485.98162812525\n31 0.00379685411494709 100.436203145885 0.018371874749744 485.98162812525\n32 0.00391933327994539 103.67608066672 0.018371874749744 485.98162812525\n33 0.00404181244494368 106.915958187555 0.018371874749744 485.98162812525\n34 0.00416429160994197 110.15583570839 0.018371874749744 485.98162812525\n35 0.00428677077494027 113.395713229225 0.018371874749744 485.98162812525\n36 0.00440924993993856 116.63559075006 0.018371874749744 485.98162812525\n37 0.00453172910493685 119.875468270895 0.018371874749744 485.98162812525\n38 0.00465420826993515 123.11534579173 0.018371874749744 485.98162812525\n39 0.00477668743493344 126.355223312565 0.018371874749744 485.98162812525\n40 0.00489916659993173 129.5951008334 0.018371874749744 485.98162812525\n41 0.00502164576493003 132.834978354235 0.018371874749744 485.98162812525\n42 0.00514412492992832 136.07485587507 0.018371874749744 485.98162812525\n43 0.00526660409492661 139.314733395905 0.018371874749744 485.98162812525\n44 0.00538908325992491 142.55461091674 0.018371874749744 485.98162812525\n45 0.0055115624249232 145.794488437575 0.018371874749744 485.98162812525\n46 0.00563404158992149 149.03436595841 0.018371874749744 485.98162812525\n47 0.00575652075491979 152.274243479245 0.018371874749744 485.98162812525\n48 0.00587899991991808 155.51412100008 0.018371874749744 485.98162812525\n49 0.00600147908491637 158.753998520915 0.018371874749744 485.98162812525\n50 0.00612395824991467 161.99387604175 0.018371874749744 485.98162812525\n51 0.00624643741491296 165.233753562585 0.018371874749744 485.98162812525\n52 0.00636891657991125 168.47363108342 0.018371874749744 485.98162812525\n53 0.00649139574490955 171.713508604255 0.018371874749744 485.98162812525\n54 0.00661387490990784 174.95338612509 0.018371874749744 485.98162812525\n55 0.00673635407490613 178.193263645925 0.018371874749744 485.98162812525\n56 0.00685883323990443 181.43314116676 0.018371874749744 485.98162812525\n57 0.00698131240490272 184.673018687595 0.018371874749744 485.98162812525\n58 0.00710379156990101 187.91289620843 0.018371874749744 485.98162812525\n59 0.00722627073489931 191.152773729265 0.018371874749744 485.98162812525\n60 0.0073487498998976 194.3926512501 0.018371874749744 485.98162812525\n61 0.00747122906489589 197.632528770935 0.018371874749744 485.98162812525\n62 0.00759370822989419 200.87240629177 0.018371874749744 485.98162812525\n63 0.00771618739489248 204.112283812605 0.018371874749744 485.98162812525\n64 0.00783866655989077 207.35216133344 0.018371874749744 485.98162812525\n65 0.00796114572488907 210.592038854275 0.018371874749744 485.98162812525\n66 0.00808362488988736 213.83191637511 0.018371874749744 485.98162812525\n67 0.00820610405488565 217.071793895945 0.018371874749744 485.98162812525\n68 0.00832858321988395 220.31167141678 0.018371874749744 485.98162812525\n69 0.00845106238488224 223.551548937615 0.018371874749744 485.98162812525\n70 0.00857354154988053 226.79142645845 0.018371874749744 485.98162812525\n71 0.00869602071487883 230.031303979285 0.018371874749744 485.98162812525\n72 0.00881849987987712 233.27118150012 0.018371874749744 485.98162812525\n73 0.00894097904487541 236.511059020955 0.018371874749744 485.98162812525\n74 0.00906345820987371 239.75093654179 0.018371874749744 485.98162812525\n75 0.009185937374872 242.990814062625 0.018371874749744 485.98162812525\n76 0.00930841653987029 246.23069158346 0.018371874749744 485.98162812525\n77 0.00943089570486859 249.470569104295 0.018371874749744 485.98162812525\n78 0.00955337486986688 252.71044662513 0.018371874749744 485.98162812525\n79 0.00967585403486517 255.950324145965 0.018371874749744 485.98162812525\n80 0.00979833319986347 259.1902016668 0.018371874749744 485.98162812525\n81 0.00992081236486176 262.430079187635 0.018371874749744 485.98162812525\n82 0.0100432915298601 265.66995670847 0.018371874749744 485.98162812525\n83 0.0101657706948583 268.909834229305 0.018371874749744 485.98162812525\n84 0.0102882498598566 272.14971175014 0.018371874749744 485.98162812525\n85 0.0104107290248549 275.389589270975 0.018371874749744 485.98162812525\n86 0.0105332081898532 278.62946679181 0.018371874749744 485.98162812525\n87 0.0106556873548515 281.869344312645 0.018371874749744 485.98162812525\n88 0.0107781665198498 285.10922183348 0.018371874749744 485.98162812525\n89 0.0109006456848481 288.349099354315 0.018371874749744 485.98162812525\n90 0.0110231248498464 291.58897687515 0.018371874749744 485.98162812525\n91 0.0111456040148447 294.828854395985 0.018371874749744 485.98162812525\n92 0.011268083179843 298.06873191682 0.018371874749744 485.98162812525\n93 0.0113905623448413 301.308609437655 0.018371874749744 485.98162812525\n94 0.0115130415098396 304.54848695849 0.018371874749744 485.98162812525\n95 0.0116355206748379 307.788364479325 0.018371874749744 485.98162812525\n96 0.0117579998398362 311.02824200016 0.018371874749744 485.98162812525\n97 0.0118804790048345 314.268119520995 0.018371874749744 485.98162812525\n98 0.0120029581698327 317.50799704183 0.018371874749744 485.98162812525\n99 0.012125437334831 320.747874562665 0.018371874749744 485.98162812525\n100 0.0122479164998293 323.9877520835 0.018371874749744 485.98162812525\n101 0.0123703956648276 327.227629604335 0.018371874749744 485.98162812525\n102 0.0124928748298259 330.46750712517 0.018371874749744 485.98162812525\n103 0.0126153539948242 333.707384646005 0.018371874749744 485.98162812525\n104 0.0127378331598225 336.94726216684 0.018371874749744 485.98162812525\n105 0.0128603123248208 340.187139687675 0.018371874749744 485.98162812525\n106 0.0129827914898191 343.42701720851 0.018371874749744 485.98162812525\n107 0.0131052706548174 346.666894729345 0.018371874749744 485.98162812525\n108 0.0132277498198157 349.90677225018 0.018371874749744 485.98162812525\n109 0.013350228984814 353.146649771015 0.018371874749744 485.98162812525\n110 0.0134727081498123 356.38652729185 0.018371874749744 485.98162812525\n111 0.0135951873148106 359.626404812685 0.018371874749744 485.98162812525\n112 0.0137176664798089 362.86628233352 0.018371874749744 485.98162812525\n113 0.0138401456448071 366.106159854355 0.018371874749744 485.98162812525\n114 0.0139626248098054 369.34603737519 0.018371874749744 485.98162812525\n115 0.0140851039748037 372.585914896025 0.018371874749744 485.98162812525\n116 0.014207583139802 375.82579241686 0.018371874749744 485.98162812525\n117 0.0143300623048003 379.065669937695 0.018371874749744 485.98162812525\n118 0.0144525414697986 382.30554745853 0.018371874749744 485.98162812525\n119 0.0145750206347969 385.545424979365 0.018371874749744 485.98162812525\n120 0.0146974997997952 388.7853025002 0.018371874749744 485.98162812525\n121 0.0148199789647935 392.025180021035 0.018371874749744 485.98162812525\n122 0.0149424581297918 395.26505754187 0.018371874749744 485.98162812525\n123 0.0150649372947901 398.504935062705 0.018371874749744 485.98162812525\n124 0.0151874164597884 401.74481258354 0.018371874749744 485.98162812525\n125 0.0153098956247867 404.984690104375 0.018371874749744 485.98162812525\n126 0.015432374789785 408.22456762521 0.018371874749744 485.98162812525\n127 0.0155548539547832 411.464445146045 0.018371874749744 485.98162812525\n128 0.0156773331197815 414.70432266688 0.018371874749744 485.98162812525\n129 0.0157998122847798 417.944200187715 0.018371874749744 485.98162812525\n130 0.0159222914497781 421.18407770855 0.018371874749744 485.98162812525\n131 0.0160447706147764 424.423955229385 0.018371874749744 485.98162812525\n132 0.0161672497797747 427.66383275022 0.018371874749744 485.98162812525\n133 0.016289728944773 430.903710271055 0.018371874749744 485.98162812525\n134 0.0164122081097713 434.14358779189 0.018371874749744 485.98162812525\n135 0.0165346872747696 437.383465312725 0.018371874749744 485.98162812525\n136 0.0166571664397679 440.62334283356 0.018371874749744 485.98162812525\n137 0.0167796456047662 443.863220354395 0.018371874749744 485.98162812525\n138 0.0169021247697645 447.10309787523 0.018371874749744 485.98162812525\n139 0.0170246039347628 450.342975396065 0.018371874749744 485.98162812525\n140 0.0171470830997611 453.5828529169 0.018371874749744 485.98162812525\n141 0.0172695622647594 456.822730437735 0.018371874749744 485.98162812525\n142 0.0173920414297577 460.06260795857 0.018371874749744 485.98162812525\n143 0.0175145205947559 463.302485479405 0.018371874749744 485.98162812525\n144 0.0176369997597542 466.54236300024 0.018371874749744 485.98162812525\n145 0.0177594789247525 469.782240521075 0.018371874749744 485.98162812525\n146 0.0178819580897508 473.02211804191 0.018371874749744 485.98162812525\n147 0.0180044372547491 476.261995562745 0.018371874749744 485.98162812525\n148 0.0181269164197474 479.50187308358 0.018371874749744 485.98162812525\n149 0.0182493955847457 482.741750604415 0.018371874749744 485.98162812525\n150 0.018371874749744 485.98162812525 0.018371874749744 485.98162812525\n\n\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes\n/tmp/ipykernel_4680/4218495784.py:18: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n  scan_df[photon] = solution.fluxes",
    "crumbs": [
      "Solving and analysing specific scenarios for paper",
      "Solving guard cell models for different parameters"
    ]
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html",
    "href": "3.3_analyse_constraint_scan.html",
    "title": "Analysing the results of the constraint scan",
    "section": "",
    "text": "import cobra\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom matplotlib.cm import ScalarMappable\nfrom matplotlib.colors import Normalize\nfrom matplotlib.ticker import AutoMinorLocator, MultipleLocator\nfrom mmon_gcm.analysing import get_phase_lengths\nfrom mmon_gcm.supermodel import SuperModel\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_squared_error, r2_score\nfrom sklearn.preprocessing import OneHotEncoder, StandardScaler\nsns.set_theme()\nsns.set_style(\"ticks\")\npalettes = {\n    \"tol_bright\": sns.color_palette(\n        [\"#4477AA\", \"#66CCEE\", \"#228833\", \"#CCBB44\", \"#EE6677\", \"#AA3377\", \"#BBBBBB\"]\n    ),\n    \"tol_muted\": sns.color_palette(\n        [\n            \"#332288\",\n            \"#88CCEE\",\n            \"#44AA99\",\n            \"#117733\",\n            \"#999933\",\n            \"#DDCC77\",\n            \"#CC6677\",\n            \"#882255\",\n            \"#AA4499\",\n        ]\n    ),\n}\nsns.set_palette(palettes[\"tol_muted\"])\n\ncolours = sns.color_palette()\n\nparams = {\n    \"xtick.labelsize\": \"large\",\n    \"ytick.labelsize\": \"large\",\n    \"axes.labelsize\": \"large\",\n    \"axes.titlesize\": \"x-large\",\n    \"font.family\": \"sans-serif\",\n    \"axes.spines.right\": False,\n    \"axes.spines.top\": False,\n    \"legend.frameon\": False,\n    \"savefig.bbox\": \"tight\",\n    \"lines.linewidth\": 2.5,\n    \"figure.figsize\": [5, 3.75],\n    \"figure.dpi\": 150,\n}\nplt.rcParams.update(params)\ndef get_bounds_in_model(constraints):\n    super_model = SuperModel(constraints)\n    volumes = super_model.get_volumes(per_guard_cell=False)\n    closed_volume = volumes[0]\n    open_volume = volumes[1]\n    osmolarities = super_model.get_osmolarities()\n    closed_osmolarity = osmolarities[0]\n    open_osmolarity = osmolarities[1]\n    photons = super_model.get_photons(150)\n    gc_photons = photons[0]\n    gc_atpase_upper_bound = super_model.get_atpase_constraint_value(\n        constraints.loc[\"ATPase\"]\n    )\n\n    return {\n        \"V_closed\": closed_volume,\n        \"V_open\": open_volume,\n        \"Os_closed\": closed_osmolarity,\n        \"Os_open\": open_osmolarity,\n        \"Photons\": gc_photons,\n        \"ATPase\": gc_atpase_upper_bound,\n    }",
    "crumbs": [
      "Running constraints scan",
      "Analysing the results of the constraint scan"
    ]
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#importing-results-and-constraints",
    "href": "3.3_analyse_constraint_scan.html#importing-results-and-constraints",
    "title": "Analysing the results of the constraint scan",
    "section": "Importing results and constraints",
    "text": "Importing results and constraints\n\n# import results files\nblue_results = pd.read_csv(\n    \"../outputs/constraint_scan/constraint_scan_results_blue.csv\", index_col=0\n)\nwhite_results = pd.read_csv(\n    \"../outputs/constraint_scan/constraint_scan_results_white.csv\", index_col=0\n)\nscan_results = pd.concat([white_results, blue_results])\nscan_results = scan_results.reset_index().drop(\"index\", axis=1)\n# remove solutions which were not feasible\ninfeasible_solutions = scan_results[scan_results.isna().any(axis=1)]\nfeasible_solutions = scan_results.dropna()\nscan_results = feasible_solutions\n\n\nlen(infeasible_solutions)\n\n2\n\n\n\nlen(feasible_solutions)\n\n1934\n\n\n\nscan_results.shape\n\n(1934, 7101)\n\n\n\n# convert any fluxes that are below 10^-6 to 0\nscan_results = scan_results.mask(abs(scan_results) &lt; 0.000001, other=0)\n\n\n# import constraints files\nwhite_constraints = pd.read_csv(\n    \"../outputs/constraint_scan/constraints_df.csv\", index_col=0\n)\nwhite_constraints[\"light\"] = \"white\"\nblue_constraints = pd.read_csv(\n    \"../outputs/constraint_scan/constraints_df.csv\", index_col=0\n)\nblue_constraints[\"light\"] = \"blue\"\nscan_constraints = pd.concat([white_constraints, blue_constraints])\nscan_constraints = scan_constraints.reset_index().drop(\"index\", axis=1)\n# remove infeasible constraints combinations\nfeasible_scan_constraints = scan_constraints.loc[feasible_solutions.index]\ninfeasible_scan_constraints = scan_constraints.loc[infeasible_solutions.index]\nscan_constraints = feasible_scan_constraints\n\n# Remove maintenance in scan_constraints\n#scan_constraints = scan_constraints.drop('Maintenance', axis=1)\n\n\nscan_constraints.columns\n\nIndex(['P_abs', 'T_l', 'A_l', 'V_gc_ind', 'FqFm', 'R_ch', 'R_ch_vol', 'L_air',\n       'L_epidermis', 'Vac_frac', 'T', 'R', 'N_gcs', 'n', 'm', 'r', 's',\n       'C_apo', 'A_closed', 'A_open', 'ATPase', 'light'],\n      dtype='object')\n\n\n\n# import constraints that were used in previous paper solutions\ndefault_constraints = pd.read_csv(\"../inputs/arabidopsis_parameters.csv\", index_col=0)[\n    \"Value\"\n]\n\npaper_constraints = []\nindex = []\nfor light in [\"white\", \"blue\", \"nops\"]:\n    for constraint in [\"unconstrained\", \"constrained\"]:\n        constraints = default_constraints.copy()\n        if constraint == \"unconstrained\":\n            constraints[\"ATPase\"] = 1000\n        elif constraint == \"constrained\":\n            constraints[\"ATPase\"] = 7.48\n        constraints[\"light\"] = light\n        index.append(f\"{light}_{constraint}_wt\")\n        paper_constraints.append(constraints)\npaper_constraints = pd.DataFrame(paper_constraints, index=index)\npaper_constraints = paper_constraints.iloc[1, :-1]\npaper_constraints\n\nP_abs                  0.9\nT_l                0.00017\nA_l                    1.0\nV_gc_ind               0.0\nFqFm                   0.9\nR_ch              0.069231\nR_ch_vol          0.200476\nL_air                 0.37\nL_epidermis           0.15\nVac_frac             0.751\nT                   296.15\nR                  0.08205\nN_gcs          580000000.0\nn                      2.5\nm                      0.8\nr                      0.0\ns                      0.0\nC_apo              0.02302\nA_closed               1.6\nA_open                2.75\nATPase                7.48\nName: white_constrained_wt, dtype: object\n\n\n\n# import results for previous simulations in paper\npaper_solution_files = []\n\nfor light in [\"white\", \"blue\", \"nops\"]:\n    for constraint in [\"unconstrained\", \"constrained\"]:\n        paper_solution_files.append(f\"{light}_{constraint}_wt.csv\")\nsolution_dfs = [\n    pd.read_csv(f\"../outputs/model_solutions/{file_name}\", index_col=0)[\"fluxes\"]\n    for file_name in paper_solution_files\n]\npaper_results = pd.concat(solution_dfs, axis=1).T\npaper_results.index = index\n\n\n# get a reduced get of constraints that are more specific to the guard cell\n\nscan_gc_constraints = pd.DataFrame.from_dict(\n    list(scan_constraints.apply(get_bounds_in_model, axis=1))\n)\nscan_gc_constraints[\"Os_dif\"] = (\n    scan_gc_constraints[\"Os_open\"] - scan_gc_constraints[\"Os_closed\"]\n)\nscan_gc_constraints.index = scan_constraints.index\nscan_gc_constraints.head()\n\n/home/maurice/Sync/GC/mmon-gcm/mmon_gcm/supermodel.py:23: UserWarning: No fba model added to the Supermodel, fine if that's what you want\n  warnings.warn(\"No fba model added to the Supermodel, fine if that's what you want\")\n\n\n\n\n\n\n\n\n\nV_closed\nV_open\nOs_closed\nOs_open\nPhotons\nATPase\nOs_dif\n\n\n\n\n0\n0.000157\n0.000476\n0.033212\n0.278138\n0.107908\n0.004851\n0.244926\n\n\n1\n0.000321\n0.000738\n0.067499\n0.370715\n0.106820\n0.000585\n0.303216\n\n\n2\n0.000248\n0.000268\n0.059662\n0.070491\n0.031490\n0.004505\n0.010828\n\n\n3\n0.000134\n0.000278\n0.033181\n0.140030\n0.013079\n0.004855\n0.106849\n\n\n4\n0.000438\n0.000786\n0.107888\n0.313097\n0.034626\n0.011479\n0.205209\n\n\n\n\n\n\n\n\npaper_gc_constraints = pd.Series(get_bounds_in_model(paper_constraints))\npaper_gc_constraints[\"Os_dif\"] = (\n    paper_gc_constraints[\"Os_open\"] - paper_gc_constraints[\"Os_closed\"]\n)\npaper_gc_constraints\n\n/home/maurice/Sync/GC/mmon-gcm/mmon_gcm/supermodel.py:23: UserWarning: No fba model added to the Supermodel, fine if that's what you want\n  warnings.warn(\"No fba model added to the Supermodel, fine if that's what you want\")\n\n\nV_closed     0.000220\nV_open       0.000254\nOs_closed    0.039359\nOs_open      0.054922\nPhotons      0.018372\nATPase       0.004338\nOs_dif       0.015563\ndtype: float64",
    "crumbs": [
      "Running constraints scan",
      "Analysing the results of the constraint scan"
    ]
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#a---what-contributes-to-phloem-output",
    "href": "3.3_analyse_constraint_scan.html#a---what-contributes-to-phloem-output",
    "title": "Analysing the results of the constraint scan",
    "section": "7a - What contributes to phloem output?",
    "text": "7a - What contributes to phloem output?\n\nSet up features for linear regression by\n\nConvert light using onehotencoder\n\nscan_constraints[[\"light\"]]\n\n\n\n\n\n\n\n\nlight\n\n\n\n\n0\nwhite\n\n\n1\nwhite\n\n\n2\nwhite\n\n\n3\nwhite\n\n\n4\nwhite\n\n\n...\n...\n\n\n1931\nblue\n\n\n1932\nblue\n\n\n1933\nblue\n\n\n1934\nblue\n\n\n1935\nblue\n\n\n\n\n1934 rows × 1 columns\n\n\n\n\n# extract the subject column as a pandas DataFrame\nlight = scan_constraints[[\"light\"]]\n# setting sparse=False means that enc.transform() will return an array\nenc = OneHotEncoder(sparse_output=False)\n\n# fit the encoder to the data\nenc.fit(light)\n\n# encode the data\nlight_enc = enc.transform(light)\nlight_columns = pd.DataFrame(light_enc, columns=\"light_\" + enc.categories_[0], index=scan_constraints.index) # Added index=scan_constraints.index \nfull_features = scan_constraints.drop(\"light\", axis=1).join(light_columns)\ngc_features = scan_gc_constraints.join(light_columns)\n\n\n\nAlso create scaled versions of features\n\nscaler = StandardScaler()\n\nscaler.fit(full_features)\nfull_features_scaled = scaler.transform(full_features)\n\nscaler.fit(gc_features)\ngc_features_scaled = scaler.transform(gc_features)\n\n\nfull_features[full_features.isna().any(axis=1)]\n\n\n\n\n\n\n\n\nP_abs\nT_l\nA_l\nV_gc_ind\nFqFm\nR_ch\nR_ch_vol\nL_air\nL_epidermis\nVac_frac\n...\nn\nm\nr\ns\nC_apo\nA_closed\nA_open\nATPase\nlight_blue\nlight_white\n\n\n\n\n\n\n0 rows × 23 columns\n\n\n\n\n\n\nCompare full and gc features\n\nresponse = scan_results.Phloem_tx_overall\n#response = scan_results.Photon_tx_gc_3\n\nlm_full = LinearRegression()\nlm_full.fit(full_features, response)\nfull_pred = lm_full.predict(full_features)\nprint(\"Mean squared error, MSE = %.5f\" % mean_squared_error(response, full_pred))\nprint(\"Coefficient of determination, r2 = %.5f\" % r2_score(response, full_pred))\n\nlm_gc = LinearRegression()\nlm_gc.fit(gc_features, response)\ngc_pred = lm_gc.predict(gc_features)\nprint(\"Mean squared error, MSE = %.5f\" % mean_squared_error(response, gc_pred))\nprint(\"Coefficient of determination, r2 = %.5f\" % r2_score(response, gc_pred))\n\nMean squared error, MSE = 0.00040\nCoefficient of determination, r2 = 0.99960\nMean squared error, MSE = 0.87829\nCoefficient of determination, r2 = 0.12388\n\n\nSo can’t predict phloem output using GC features, but can predict pretty well using the full set\n\nWhich features are most important?\n\npd.DataFrame(lm_full.coef_, index=full_features.columns).sort_values(by=0)\n\n\n\n\n\n\n\n\n0\n\n\n\n\nT_l\n-4.514050e-01\n\n\nlight_blue\n-3.533915e-01\n\n\nC_apo\n-1.320172e-03\n\n\nm\n-8.770751e-04\n\n\nVac_frac\n-7.229537e-04\n\n\nA_open\n-2.302990e-04\n\n\nFqFm\n-6.018903e-05\n\n\nn\n-5.320860e-05\n\n\nV_gc_ind\n-9.982424e-10\n\n\nr\n-6.477489e-12\n\n\nN_gcs\n-1.186773e-12\n\n\nA_l\n-2.997951e-13\n\n\nR\n-1.131064e-13\n\n\ns\n1.957373e-11\n\n\nT\n4.679942e-06\n\n\nATPase\n4.859983e-06\n\n\nA_closed\n1.710221e-04\n\n\nL_epidermis\n2.027958e-04\n\n\nL_air\n2.972018e-04\n\n\nR_ch_vol\n4.995322e-04\n\n\nR_ch\n1.383114e-03\n\n\nlight_white\n3.533915e-01\n\n\nP_abs\n1.800514e+01\n\n\n\n\n\n\n\nLots of unimportant features so we can use lasso regression to see which ones we really need\n\n\nTry different alphas for lasso to see r2\n\nfrom sklearn.linear_model import Lasso\n\nalphas = np.linspace(0.01, 0.1, 10)\nr2s = []\n\nfor alpha in alphas:\n    lasso = Lasso(alpha=alpha)\n    lasso.fit(full_features, response)\n    lasso_pred = lasso.predict(full_features)\n    r2s.append(r2_score(response, lasso_pred))\n\npd.Series(r2s, index=alphas)\n\n0.01    0.962288\n0.02    0.850360\n0.03    0.663812\n0.04    0.402646\n0.05    0.116440\n0.06    0.111850\n0.07    0.106593\n0.08    0.100528\n0.09    0.093654\n0.10    0.085972\ndtype: float64\n\n\n\nfrom sklearn.linear_model import Lasso\n\nalphas = np.linspace(0.001, 0.01, 10)\nr2s = []\n\nfor alpha in alphas:\n    lasso = Lasso(alpha=alpha)\n    lasso.fit(full_features, response)\n    lasso_pred = lasso.predict(full_features)\n    r2s.append(r2_score(response, lasso_pred))\n\npd.Series(r2s, index=alphas)\n\n0.001    0.999224\n0.002    0.998105\n0.003    0.996240\n0.004    0.993628\n0.005    0.990270\n0.006    0.986166\n0.007    0.981316\n0.008    0.975719\n0.009    0.969377\n0.010    0.962288\ndtype: float64\n\n\nLets take 0.03 as it’s highest that rounds to 0.999\n\n\nLasso with alpha = 0.003\n\nlasso = Lasso(alpha=0.003)\nlasso.fit(full_features, response)\nlasso_pred = lasso.predict(full_features)\nlass_coefs = pd.DataFrame(lasso.coef_, index=full_features.columns).sort_values(by=0)\n# display coefficients that aren't 0\nlass_coefs[abs(lass_coefs.loc[:, 0]) &gt; 0.00001]\n\n\n\n\n\n\n\n\n0\n\n\n\n\nlight_blue\n-0.694783\n\n\nT\n-0.000436\n\n\nA_open\n-0.000309\n\n\nP_abs\n16.894629\n\n\n\n\n\n\n\nP_abs and light are by far the largest coefficients\n\n\nTry scaled as well\n\nfrom sklearn.linear_model import Lasso\n\nalphas = np.linspace(0.01, 0.1, 10)\nr2s = []\n\nfor alpha in alphas:\n    lasso = Lasso(alpha=alpha)\n    lasso.fit(full_features_scaled, response)\n    lasso_pred = lasso.predict(full_features_scaled)\n    r2s.append(r2_score(response, lasso_pred))\n\npd.Series(r2s, index=alphas)\n\n0.01    0.999398\n0.02    0.998799\n0.03    0.997801\n0.04    0.996405\n0.05    0.994609\n0.06    0.992415\n0.07    0.989821\n0.08    0.986829\n0.09    0.983437\n0.10    0.979646\ndtype: float64\n\n\n\nlasso = Lasso(alpha=0.01)\nlasso.fit(full_features_scaled, response)\nlasso_pred = lasso.predict(full_features_scaled)\nlass_coefs = pd.DataFrame(lasso.coef_, index=full_features.columns).sort_values(by=0)\nprint(f\"r2 score: {r2_score(response, lasso_pred)}\")\n# display coefficients that aren't 0\nlass_coefs[abs(lass_coefs.loc[:, 0]) &gt; 0.00001]\n\nr2 score: 0.9993975321339854\n\n\n\n\n\n\n\n\n\n0\n\n\n\n\nlight_blue\n-0.343392\n\n\nP_abs\n0.926581\n\n\n\n\n\n\n\nWhen scaled this is even clearer\n\ndef phloemoutput_subfig(ax):\n    for light, colour in zip(\n        [\"white\", \"blue\"], [sns.color_palette()[1], sns.color_palette()[0]]\n    ):\n        constraints_light_df = scan_constraints[scan_constraints.light == light]\n        results_light_df = scan_results[scan_constraints.light == light]\n\n        ax.scatter(\n            constraints_light_df.P_abs,\n            results_light_df.Phloem_tx_overall,\n            label=light.capitalize(),\n            color=colour,\n        )\n\n    ax.legend(title=\"Light during opening\", loc=\"upper left\")  # Set loc to \"upper left\"\n    ax.set_xlabel(\"$P_{abs}$\\n(Prop. photons absorbed by leaf)\", size=\"medium\")\n    ax.set_ylabel(\n        \"Phloem output\\n(mmol$\\cdot$m$^{-2}$leaf$\\cdot$h$^{-1}$)\", size=\"medium\"\n    )\n\n    ax.set_ylim(11.9, 17)\n    ax.set_xlim(0.797, 1)\n    ax.spines[\"left\"].set_bounds(12, 17)\n    ax.spines[\"bottom\"].set_bounds(0.8, 1)\n    ax.xaxis.set_major_locator(MultipleLocator(0.1))\n    # ax.xaxis.set_minor_locator(AutoMinorLocator(2))\n    ax.yaxis.set_major_locator(MultipleLocator(1))\n    # ax.yaxis.set_minor_locator(AutoMinorLocator(2))\n\n    ax.set_aspect(abs(1 - 0.8) / abs(17 - 12))\n\n    return ax\n\n\nfig, ax = plt.subplots()\nphloemoutput_subfig(ax)",
    "crumbs": [
      "Running constraints scan",
      "Analysing the results of the constraint scan"
    ]
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#b---what-affects-hexose-export-from-the-guard-cell",
    "href": "3.3_analyse_constraint_scan.html#b---what-affects-hexose-export-from-the-guard-cell",
    "title": "Analysing the results of the constraint scan",
    "section": "7b - What affects hexose export from the guard cell?",
    "text": "7b - What affects hexose export from the guard cell?\n\nGenerate hexose export df\n\nfour_stage_GC_model = cobra.io.sbml.read_sbml_model(\n    \"../models/4_stage_GC.xml\"\n)  # read model\n\n# get total flux across all phases\nnet_carbon_dict = {}\nfor metabolite in [\"GLC\", \"FRU\", \"SUCROSE\"]:\n    net_metabolite = 0\n    for i, phase_length in enumerate(get_phase_lengths(four_stage_GC_model)):\n        phase_number = i + 1\n        net_metabolite = (\n            net_metabolite\n            + scan_results.loc[:, f\"{metabolite}_ae_gc_{phase_number}\"] * phase_length\n        )\n    net_carbon_dict[metabolite] = net_metabolite\nnet_carbon_df = pd.DataFrame.from_dict(net_carbon_dict)\n\n# correct for fact that sucrose is two hexoses\nnet_carbon = (\n    net_carbon_df.GLC + net_carbon_df.FRU + net_carbon_df.SUCROSE * 2\n) * -1  # mmol.m2-1\nnet_carbon = net_carbon * 10**-3  # moles.m2-1\ncarbon_per_gc = net_carbon / scan_constraints.N_gcs  # moles.gc-1\ncarbon_per_gc = carbon_per_gc * 10**15  # fmol.gc-1\n\nNo objective coefficients in model. Unclear what should be optimized\n\n\n\n\nFit model to hexose export\n\nresponse = carbon_per_gc\nfor features in [full_features, gc_features]:\n    lm_1 = LinearRegression()\n    lm_1.fit(features, response)\n    pred = lm_1.predict(features)\n    print(\"Mean squared error, MSE = %.2f\" % mean_squared_error(response, pred))\n    print(\"Coefficient of determination, r2 = %.2f\" % r2_score(response, pred))\n\nMean squared error, MSE = 392.25\nCoefficient of determination, r2 = 0.45\nMean squared error, MSE = 118.22\nCoefficient of determination, r2 = 0.83\n\n\nSo hexose export can be better predicted using the gc features compared to all the features. Is this because it’s hexose per gc?\n\nresponse = net_carbon\nfor features in [full_features, gc_features]:\n    lm_1 = LinearRegression()\n    lm_1.fit(features, response)\n    pred = lm_1.predict(features)\n    print(\"Mean squared error, MSE = %.2f\" % mean_squared_error(response, pred))\n    print(\"Coefficient of determination, r2 = %.2f\" % r2_score(response, pred))\n\nMean squared error, MSE = 0.00\nCoefficient of determination, r2 = 0.52\nMean squared error, MSE = 0.00\nCoefficient of determination, r2 = 1.00\n\n\nSeems so, as we’re confusing things by introducing the N_gcs division into the response\n\nresponse = net_carbon\nlm_1 = LinearRegression()\nlm_1.fit(gc_features, response)\npred = lm_1.predict(gc_features)\nlm_coefs = pd.DataFrame(lm_1.coef_, index=gc_features.columns).sort_values(by=0)\nlm_coefs[abs(lm_coefs.loc[:, 0]) &gt; 0.00001]\n\n\n\n\n\n\n\n\n0\n\n\n\n\nlight_blue\n-1.381741e+08\n\n\nlight_white\n-1.381741e+08\n\n\nOs_open\n-8.054295e+05\n\n\nV_closed\n-1.611919e-02\n\n\nATPase\n1.462491e-04\n\n\nPhotons\n2.354302e-04\n\n\nV_open\n6.360736e-03\n\n\nOs_dif\n8.054295e+05\n\n\nOs_closed\n8.054295e+05\n\n\n\n\n\n\n\nMainly different light colours as well as osmolarity. What if we correct for light colour?\n\n\nCreate a reponse for total photons into the GC, irrespective of blue or white light\n\nphoton_influx = scan_results.loc[:, \"Photon_tx_gc_3\"]\nphoton_hours = scan_constraints.loc[:, \"light\"].apply(\n    lambda x: 12 if x == \"white\" else 11.5\n)\ntotal_photons_per_day = photon_influx * photon_hours\n\n\nresponse = net_carbon\nfeatures = np.array([total_photons_per_day]).T\nlm_1 = LinearRegression()\nlm_1.fit(features, response)\npred = lm_1.predict(features)\nprint(\"Mean squared error, MSE = %.6f\" % mean_squared_error(response, pred))\nprint(\"Coefficient of determination, r2 = %.6f\" % r2_score(response, pred))\npd.DataFrame(lm_1.coef_, index=[\"Photons per day\"]).sort_values(by=0)\n\nMean squared error, MSE = 0.000000\nCoefficient of determination, r2 = 0.952128\n\n\n\n\n\n\n\n\n\n0\n\n\n\n\nPhotons per day\n0.000019\n\n\n\n\n\n\n\n\nresponse = net_carbon\nfeatures = np.array([total_photons_per_day, gc_features.Os_dif]).T\nlm_1 = LinearRegression()\nlm_1.fit(features, response)\npred = lm_1.predict(features)\nprint(\"Mean squared error, MSE = %.6f\" % mean_squared_error(response, pred))\nprint(\"Coefficient of determination, r2 = %.6f\" % r2_score(response, pred))\npd.DataFrame(lm_1.coef_, index=[\"Photons per day\", \"Os dif\"]).sort_values(by=0)\n\nMean squared error, MSE = 0.000000\nCoefficient of determination, r2 = 0.997839\n\n\n\n\n\n\n\n\n\n0\n\n\n\n\nOs dif\n-0.000042\n\n\nPhotons per day\n0.000020\n\n\n\n\n\n\n\nPretty good R2\n\nresponse = net_carbon\nfeatures = np.array(gc_features.ATPase).reshape(-1, 1)\nlm_1 = LinearRegression()\nlm_1.fit(features, response)\npred = lm_1.predict(features)\nprint(\"Mean squared error, MSE = %.6f\" % mean_squared_error(response, pred))\nprint(\"Coefficient of determination, r2 = %.6f\" % r2_score(response, pred))\npd.DataFrame(lm_1.coef_, index=[\"ATPase\"]).sort_values(by=0)\n\nMean squared error, MSE = 0.000000\nCoefficient of determination, r2 = 0.109253\n\n\n\n\n\n\n\n\n\n0\n\n\n\n\nATPase\n0.001702\n\n\n\n\n\n\n\nATPase can’t really predict hexose export, at least not by itself\n\ndef photons_vs_carbon_export_subfig(ax):\n    max_os_dif = scan_gc_constraints.Os_dif.max().round(1)\n    norm = Normalize(vmin=0, vmax=max_os_dif)\n    mappable = ScalarMappable(norm=norm, cmap=sns.color_palette(\"crest\", as_cmap=True))\n\n    net_carbon_mmol = net_carbon * 10**3\n\n    ax.scatter(\n        total_photons_per_day,\n        net_carbon_mmol,\n        c=scan_gc_constraints.Os_dif,\n        norm=norm,\n        s=10,\n        cmap=sns.color_palette(\"crest\", as_cmap=True),\n    )\n\n    cbaxes = ax.inset_axes([0.1, 0.93, 0.40, 0.05])\n    cbar = plt.colorbar(\n        mappable, cax=cbaxes, ticks=[0, max_os_dif], orientation=\"horizontal\"\n    )\n    cbar.set_label(\"Osmolarity increase\\n(mmol$\\cdot$m$^{-2}\\cdot$d$^{-1}$)\", size=10)\n\n    inset_ax = ax.inset_axes([0.7, 0.15, 0.3, 0.3])\n    inset_ax.scatter(\n        total_photons_per_day,\n        net_carbon_mmol,\n        c=scan_gc_constraints.Os_dif,\n        s=1,\n        cmap=sns.color_palette(\"crest\", as_cmap=True),\n    )\n    inset_ax.set_xlim([-0.3 / 10, 2])\n    inset_ax.set_ylim([-0.02 / 5, 0.04])\n    inset_ax.tick_params(labelsize=10)\n    inset_ax.spines[\"left\"].set_bounds(0, 0.04)\n    inset_ax.spines[\"bottom\"].set_bounds(0, 2)\n    inset_ax.yaxis.set_major_locator(MultipleLocator(0.04))\n    inset_ax.yaxis.set_minor_locator(AutoMinorLocator(2))\n    inset_ax.xaxis.set_major_locator(MultipleLocator(2))\n    inset_ax.xaxis.set_minor_locator(AutoMinorLocator(2))\n\n    ax.set_xlim([-0.5, 10])\n    ax.set_ylim([-0.02, 0.15])\n    ax.spines[\"left\"].set_bounds(0, 0.15)\n    ax.spines[\"bottom\"].set_bounds(0, 10)\n    ax.xaxis.set_major_locator(MultipleLocator(2))\n    ax.xaxis.set_minor_locator(AutoMinorLocator(2))\n    ax.yaxis.set_major_locator(MultipleLocator(0.05))\n    ax.set_aspect(abs(10 - 0) / abs(0.15 - 0))\n\n    ax.set_xlabel(\n        \"Photons per day into GC\\n\" + r\"(mmol$\\cdot$m$^{-2}\\cdot$d$^{-1}$)\",\n        size=\"medium\",\n    )\n    ax.set_ylabel(\n        \"Net hexose export flux from GC\\n\" + r\"(mmol$\\cdot$m$^{-2}\\cdot$h$^{-1}$)\",\n        size=\"medium\",\n    )\n\n    return ax\n\n\nfig, ax = plt.subplots()\nphotons_vs_carbon_export_subfig(ax)\n\n\n\n\n\n\n\n\n\n\nAre there any solutions where net carbon export are below 0?\n\n(net_carbon &lt; 0).sum()\n\n177\n\n\n\n(net_carbon &gt; 0).sum()\n\n1757\n\n\n\n(net_carbon == 0).sum()\n\n0\n\n\n\n1-((net_carbon &lt; 0).sum())/len(net_carbon)\n\n0.9084798345398138\n\n\nWhat’s interesting about them?\n\nscan_constraints.loc[net_carbon &lt; 0]\n\n\n\n\n\n\n\n\nP_abs\nT_l\nA_l\nV_gc_ind\nFqFm\nR_ch\nR_ch_vol\nL_air\nL_epidermis\nVac_frac\n...\nN_gcs\nn\nm\nr\ns\nC_apo\nA_closed\nA_open\nATPase\nlight\n\n\n\n\n3\n0.880998\n0.000192\n1.0\n8.629192e-13\n0.866582\n0.051244\n0.204472\n0.309538\n0.169957\n0.813726\n...\n3.851195e+08\n2.077401\n0.940848\n5.747590e-14\n1.515328e-13\n0.029770\n3.399462\n9.936390\n12.606738\nwhite\n\n\n30\n0.977490\n0.000213\n1.0\n8.097892e-13\n0.849340\n0.085944\n0.200220\n0.228127\n0.106448\n0.830654\n...\n6.380687e+08\n2.318837\n0.830687\n7.864234e-14\n1.643929e-13\n0.025288\n3.333199\n10.672109\n11.311688\nwhite\n\n\n35\n0.856504\n0.000237\n1.0\n1.360312e-12\n0.860652\n0.067374\n0.192203\n0.258071\n0.107286\n0.777399\n...\n8.423951e+08\n2.039681\n0.993173\n6.491681e-14\n2.153582e-13\n0.029056\n3.839122\n9.599664\n13.331786\nwhite\n\n\n45\n0.930783\n0.000189\n1.0\n1.489148e-12\n0.888709\n0.046345\n0.194218\n0.231172\n0.183409\n0.831117\n...\n1.105337e+09\n2.328963\n0.866898\n6.554262e-14\n2.276119e-13\n0.023463\n3.689994\n11.705067\n7.102036\nwhite\n\n\n64\n0.859688\n0.000235\n1.0\n3.426082e-12\n0.791894\n0.052688\n0.198979\n0.230128\n0.197351\n0.842065\n...\n3.647771e+08\n1.730236\n0.919254\n7.408027e-14\n2.148666e-13\n0.029782\n1.697687\n11.305181\n13.115608\nwhite\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n1882\n0.845869\n0.000172\n1.0\n1.048237e-12\n0.845831\n0.080705\n0.199110\n0.334855\n0.163015\n0.764383\n...\n2.061369e+08\n1.615056\n0.959637\n7.543702e-14\n2.598267e-13\n0.027358\n1.738303\n9.792686\n12.376386\nblue\n\n\n1910\n0.891865\n0.000236\n1.0\n1.587349e-12\n0.841325\n0.047596\n0.190368\n0.187888\n0.114146\n0.818767\n...\n8.062927e+08\n1.649409\n0.853218\n7.850763e-14\n2.357539e-13\n0.024782\n1.406129\n6.738719\n13.099119\nblue\n\n\n1917\n0.917349\n0.000172\n1.0\n6.231750e-13\n0.847565\n0.047245\n0.195349\n0.244040\n0.192836\n0.789315\n...\n9.777013e+08\n1.535770\n0.824097\n5.226121e-14\n2.318500e-13\n0.024413\n1.599696\n9.447559\n0.599285\nblue\n\n\n1918\n0.979824\n0.000215\n1.0\n7.663475e-13\n0.834459\n0.092777\n0.203782\n0.191754\n0.104075\n0.832115\n...\n2.886042e+08\n2.043540\n0.833630\n5.487253e-14\n1.306311e-13\n0.031694\n1.449804\n8.414919\n3.970192\nblue\n\n\n1926\n0.884257\n0.000212\n1.0\n9.887656e-13\n0.794346\n0.042550\n0.190401\n0.318149\n0.216369\n0.817676\n...\n5.898101e+08\n2.199278\n0.968034\n6.179313e-14\n2.376930e-13\n0.028122\n2.487448\n9.333051\n11.542919\nblue\n\n\n\n\n177 rows × 22 columns\n\n\n\n\nscan_gc_constraints.loc[net_carbon &lt; 0]\n\n\n\n\n\n\n\n\nV_closed\nV_open\nOs_closed\nOs_open\nPhotons\nATPase\nOs_dif\n\n\n\n\n3\n0.000134\n0.000278\n0.033181\n0.140030\n0.013079\n0.004855\n0.106849\n\n\n30\n0.000272\n0.000640\n0.063820\n0.310722\n0.027134\n0.007218\n0.246902\n\n\n35\n0.000391\n0.000706\n0.109738\n0.371630\n0.037644\n0.011231\n0.261892\n\n\n45\n0.000519\n0.001100\n0.133538\n0.606216\n0.055639\n0.007850\n0.472678\n\n\n64\n0.000124\n0.000384\n0.020705\n0.204952\n0.033219\n0.004784\n0.184247\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n1882\n0.000081\n0.000206\n0.013085\n0.098841\n0.013994\n0.002551\n0.085757\n\n\n1910\n0.000279\n0.000617\n0.040490\n0.207920\n0.027690\n0.010562\n0.167430\n\n\n1917\n0.000308\n0.000709\n0.044057\n0.291729\n0.022555\n0.000586\n0.247672\n\n\n1918\n0.000061\n0.000171\n0.010122\n0.069783\n0.011858\n0.001146\n0.059661\n\n\n1926\n0.000231\n0.000480\n0.050001\n0.234255\n0.015845\n0.006808\n0.184254\n\n\n\n\n177 rows × 7 columns\n\n\n\nOk they are the same just with different light colours. Is it the photon/od_dif ratio?\n\nscan_gc_constraints.loc[180, \"Photons\"] / scan_gc_constraints.loc[180, \"Os_dif\"]\n\n0.8286998886406594\n\n\n\n(scan_gc_constraints.loc[:, \"Photons\"] / scan_gc_constraints.loc[:, \"Os_dif\"]).min()\n\n0.028310817388733575\n\n\nYes, it has the lowest photon:od_diff ratio of any combination",
    "crumbs": [
      "Running constraints scan",
      "Analysing the results of the constraint scan"
    ]
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#at-our-predicted-level-of-osmolarity-and-other-guard-cell-parameters-what-would-fqfm.r_ch-need-to-be-for-guard-cell-to-act-as-a-sink",
    "href": "3.3_analyse_constraint_scan.html#at-our-predicted-level-of-osmolarity-and-other-guard-cell-parameters-what-would-fqfm.r_ch-need-to-be-for-guard-cell-to-act-as-a-sink",
    "title": "Analysing the results of the constraint scan",
    "section": "At our predicted level of osmolarity and other guard cell parameters, what would FqFm.R_ch need to be for guard cell to act as a sink?",
    "text": "At our predicted level of osmolarity and other guard cell parameters, what would FqFm.R_ch need to be for guard cell to act as a sink?\n\\(e = FqFm \\cdot R_{ch} \\cdot R_{ch_{vol}}\\) &lt;- We want to know e, that is the capacity of guard cell vs mesophyll. Function of efficiency, number of chloroplasts, and valume of chloroplasts\n\\(P_{gc} = e \\cdot v\\_prop_{gc} \\cdot P\\)\n\\(e = \\frac{P_{gc}}{v\\_prop_{gc} \\cdot P}\\)\n\nP = 150 * paper_constraints.P_abs\nP = P * 10**-3 * 60 * 60  # umolessec-1 -&gt; mmolhr-1\n\n\nV_l = (\n    paper_constraints.T_l * paper_constraints.A_l\n)  # volume of leaf is area x thickness\nV_l = V_l * 10**3  # (Total leaf volume) m3 -&gt; dm3 = 10**3\n\nV_gc = (\n    paper_constraints.V_gc_ind * paper_constraints.N_gcs\n)  # total volume of gc in leaf\n\n# volume of meosphyll is leaf that isn't epidermis or air\nV_me = V_l * (1 - paper_constraints.L_epidermis) * (1 - paper_constraints.L_air)\n\nv_prop_gc = V_gc / V_me  # volume of gc is negligable\n\n\nresponse = net_carbon\nfeatures = np.array([total_photons_per_day, gc_features.Os_dif]).T\nlm_1 = LinearRegression()\nlm_1.fit(features, response)\npred = lm_1.predict(features)\nprint(\"Mean squared error, MSE = %.6f\" % mean_squared_error(response, pred))\nprint(\"Coefficient of determination, r2 = %.6f\" % r2_score(response, pred))\nprint(f\"Intercept: {lm_1.intercept_}\")\npd.DataFrame(lm_1.coef_, index=[\"Photons per day\", \"Os dif\"]).sort_values(by=0)\n\nMean squared error, MSE = 0.000000\nCoefficient of determination, r2 = 0.997839\nIntercept: -2.9943170116709816e-07\n\n\n\n\n\n\n\n\n\n0\n\n\n\n\nOs dif\n-0.000042\n\n\nPhotons per day\n0.000020\n\n\n\n\n\n\n\n$ C_{net} = -3^{-5}Os_{dif} + 2^{-5}P_{day} - 6.80 ^{-8}$\n$ 0 = -3^{-5} + 2^{-5}P_{day} - 6.80 ^{-8}$\n$ = P_{day}$\n\nos_dif_coef = lm_1.coef_[1]\nphotons_per_day_coef = lm_1.coef_[0]\nos_in_selected_scenarios = paper_gc_constraints.Os_dif\nintercept = lm_1.intercept_\n\n\nphotons_needed = (\n    intercept - os_dif_coef * os_in_selected_scenarios\n) / photons_per_day_coef\nphotons_needed\n\n0.01766160051488187\n\n\n\ntotal_photons_per_day.min() / photons_needed\n\n2.1088116678656323\n\n\nSo at that osmolarity for the guard cell to act as sink tissue the total level of photons coming in would have to be 15x lower than we see in any of our scenarios, which will be for blue light\n\nphoton_influx = photons_needed / 11.5\n\n\\(e = \\frac{P_{gc}}{v\\_prop_{gc} \\cdot P}\\)\n\ne = photon_influx / (v_prop_gc * P)\ne * 100\n\n0.10441977210694658\n\n\nSo the capacity for photosynthesis in the guard cell only needs to be 0.1% of that of the mesophyll to act as a source tissue\n\nWhat is the range of photosynthetic capacities that we use?\n\ncapacity_percentages = (scan_constraints.FqFm * scan_constraints.R_ch) * 100\nprint(f\"High: {capacity_percentages.max()}\")\nprint(f\"Low: {capacity_percentages.min()}\")\n\nHigh: 16.086936580407595\nLow: 2.773358075436272",
    "crumbs": [
      "Running constraints scan",
      "Analysing the results of the constraint scan"
    ]
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#c---so-does-the-atpase-have-an-effect-on-starch-if-not-on-hexose-export-very-much",
    "href": "3.3_analyse_constraint_scan.html#c---so-does-the-atpase-have-an-effect-on-starch-if-not-on-hexose-export-very-much",
    "title": "Analysing the results of the constraint scan",
    "section": "7c - So does the ATPase have an effect on starch if not on hexose export very much?",
    "text": "7c - So does the ATPase have an effect on starch if not on hexose export very much?\n\nHow many solutions utilise starch?\n\nstarch = scan_results.STARCH_p_gc_Linker_1 - scan_results.STARCH_p_gc_Linker_2\nprint(f\"{(starch &gt; 0).sum()} or {(starch &gt; 0).sum()/len(starch) * 100:.0f}%\")\n\n1892 or 98%",
    "crumbs": [
      "Running constraints scan",
      "Analysing the results of the constraint scan"
    ]
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#in-how-many-of-those-solutions-is-the-atpase-constrained",
    "href": "3.3_analyse_constraint_scan.html#in-how-many-of-those-solutions-is-the-atpase-constrained",
    "title": "Analysing the results of the constraint scan",
    "section": "In how many of those solutions is the ATPase constrained?",
    "text": "In how many of those solutions is the ATPase constrained?\n\natpase_constrained = (\n    abs(scan_gc_constraints.ATPase - scan_results.PROTON_ATPase_c_gc_2) &lt; 0.000001\n)\n(atpase_constrained & starch &gt; 0).sum()\n\n1864\n\n\n\n((scan_gc_constraints.ATPase - scan_results.PROTON_ATPase_c_gc_2) &lt; 0.000001).sum() / (starch &gt; 0).sum()\n\n0.985200845665962\n\n\n\n(starch &lt;= 0).sum()\n\n42\n\n\n\nscan_gc_constraints[(atpase_constrained & (starch == 0))]\n\n\n\n\n\n\n\n\nV_closed\nV_open\nOs_closed\nOs_open\nPhotons\nATPase\nOs_dif\n\n\n\n\n\n\n\n\n\nSo there is one solution which doesn’t\n\nscan_gc_constraints[(atpase_constrained & starch &lt; 0)]\n\n\n\n\n\n\n\n\nV_closed\nV_open\nOs_closed\nOs_open\nPhotons\nATPase\nOs_dif\n\n\n\n\n\n\n\n\n\n\n#(scan_gc_constraints.loc[1685] - scan_gc_constraints.mean()) / scan_gc_constraints.std()\n\nHigh photons, high ATPase, low osmolarity dif",
    "crumbs": [
      "Running constraints scan",
      "Analysing the results of the constraint scan"
    ]
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#how-many-constrained-solutions-dont-use-starch",
    "href": "3.3_analyse_constraint_scan.html#how-many-constrained-solutions-dont-use-starch",
    "title": "Analysing the results of the constraint scan",
    "section": "How many constrained solutions don’t use starch?",
    "text": "How many constrained solutions don’t use starch?\n\n(atpase_constrained & (starch == 0)).sum()\n\n0\n\n\n\nscan_gc_constraints[(atpase_constrained & (starch == 0))]\n\n\n\n\n\n\n\n\nV_closed\nV_open\nOs_closed\nOs_open\nPhotons\nATPase\nOs_dif\n\n\n\n\n\n\n\n\n\n\n#(scan_gc_constraints.loc[1779] - scan_gc_constraints.mean()) / scan_gc_constraints.std()\n\nOsmolarity difference is low, photons are high, atpase is low. Closed osmolarity is high, forcing the use of something else?\nIncrease per GC allows comparison with literature values\n\nstarch_per_gc = starch * 10**-3 / scan_constraints.N_gcs * 10**15  # fmol.gc-1\n\n\nhorrer_starch_level = 184\n\n\nos_increase_per_gc = (\n    scan_gc_constraints.Os_dif * 10**-3 / scan_constraints.N_gcs * 10**15\n)\nprotons_moved_per_gc = (\n    scan_results.PROTON_ATPase_c_gc_2 * 10**-3 / scan_constraints.N_gcs * 10**15\n)\n\n\nprotons_moved_per_gc.max()\n\n16.983568453252616\n\n\n\ndef starch_vs_os_subfig(ax):\n    dot_size = 2\n\n    norm = Normalize(vmin=0, vmax=15)\n    mappable = ScalarMappable(norm=norm, cmap=sns.color_palette(\"crest\", as_cmap=True))\n\n    ax.plot([0, 600], [0, 600], c=\"grey\", alpha=0.5, clip_on=False, linewidth=1)\n\n    sc = ax.scatter(\n        os_increase_per_gc,\n        starch_per_gc,\n        s=dot_size,\n        c=protons_moved_per_gc,\n        norm=norm,\n        cmap=sns.color_palette(\"crest\", as_cmap=True),\n    )\n\n    cbaxes = ax.inset_axes([0.15, 0.93, 0.40, 0.05])\n    cbar = plt.colorbar(mappable, cax=cbaxes, ticks=[0, 15], orientation=\"horizontal\")\n    cbar.set_label(\"Total H$^{+}$ export\\n(fmol$\\cdot$GC$^{-1}$)\", size=10)\n\n    y_max = 600\n    y_min = -20\n    x_max = 600\n    x_min = -20\n    ax.set_ylim(y_min, y_max)\n    ax.set_xlim(x_min, x_max)\n    ax.spines[\"left\"].set_bounds(0, y_max)\n    ax.spines[\"bottom\"].set_bounds(0, x_max)\n    ax.xaxis.set_major_locator(MultipleLocator(200))\n    ax.xaxis.set_minor_locator(AutoMinorLocator(2))\n    ax.yaxis.set_major_locator(MultipleLocator(200))\n    ax.yaxis.set_minor_locator(AutoMinorLocator(2))\n    ax.set_aspect(1)\n\n    ax.set_xlabel(\"Osmolarity increase (fmol$\\cdot$GC$^{-1}$)\", size=\"medium\")\n    ax.set_ylabel(r\"Starch degradation (fmol$\\cdot$GC$^{-1}$)\", size=\"medium\")\n    # ax.hlines(-155, xmin=0.15, xmax=0.99, clip_on=False, linewidth=1, color='.15')\n\n#     ax.hlines(\n#         184,\n#         xmin=0,\n#         xmax=x_max,\n#         linewidth=1,\n#         linestyle=\"--\",\n#         color=sns.color_palette()[6],\n#     )\n#     ax.text(\n#         x_max,\n#         175,\n#         \"Horrer et al. (2016)\",\n#         ha=\"right\",\n#         va=\"top\",\n#         size=\"x-small\",\n#         color=sns.color_palette()[6],\n#     )\n\n#     paper_scenarios_colour = sns.color_palette()[2]\n#     ax.vlines(\n#         26.83,\n#         ymin=0,\n#         ymax=110,\n#         linewidth=1,\n#         linestyle=\"--\",\n#         color=paper_scenarios_colour,\n#     )\n#     ax.text(\n#         50,\n#         120,\n#         \"Paper\\nscenarios\",\n#         ha=\"center\",\n#         va=\"bottom\",\n#         size=\"x-small\",\n#         color=paper_scenarios_colour,\n#     )\n\n    return ax\n\n\nfig, ax = plt.subplots(figsize=(6, 4))\n\nstarch_vs_os_subfig(ax)\n\nfig.savefig(\"../outputs/constraint_scan/atpase_vs_starch.svg\")\nfig.savefig(\"../outputs/constraint_scan/atpase_vs_starch.png\")\n\n\n\n\n\n\n\n\n\nHow do starch levels vary with white/blue light?\n\nstarch_per_gc\n\n0       452.289024\n1       277.547788\n2         4.237398\n3       167.427081\n4        88.409571\n           ...    \n1931    401.554966\n1932    111.326430\n1933    269.642074\n1934     81.257996\n1935    271.281498\nLength: 1934, dtype: float64",
    "crumbs": [
      "Running constraints scan",
      "Analysing the results of the constraint scan"
    ]
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#how-is-starch-used",
    "href": "3.3_analyse_constraint_scan.html#how-is-starch-used",
    "title": "Analysing the results of the constraint scan",
    "section": "How is starch used?",
    "text": "How is starch used?\nWhat proportion of white light solutions that degrade starch use it for osmoticum?\n\n(\n    (\n        (scan_constraints[\"light\"] == \"white\")\n        & (starch &gt; 0)\n        & (scan_results.RXN_2141_p_gc_2 &gt; 0)\n    ).sum()\n) / ((scan_constraints[\"light\"] == \"white\") & (starch &gt; 0)).sum() * 100\n\n100.0\n\n\nWhat proportion of white light solutions that degrade starch use it for energy?\n\n(\n    (\n        (scan_constraints[\"light\"] == \"white\")\n        & (starch &gt; 0)\n        & (scan_results.MALTODEG_RXN_c_gc_2 &gt; 0)\n    ).sum()\n) / ((scan_constraints[\"light\"] == \"white\") & (starch &gt; 0)).sum() * 100\n\n37.379162191192265\n\n\nIn the solutions that use it for energy, what is the average % used for energy?\n\n(\n    (\n        (\n            scan_results[\n                (\n                    (\n                        (scan_constraints[\"light\"] == \"white\")\n                        & (starch &gt; 0)\n                        & (scan_results.MALTODEG_RXN_c_gc_2 &gt; 0)\n                    )\n                )\n            ].MALTODEG_RXN_c_gc_2\n        )\n        / starch[\n            (\n                (scan_constraints[\"light\"] == \"white\")\n                & (starch &gt; 0)\n                & (scan_results.MALTODEG_RXN_c_gc_2 &gt; 0)\n            )\n        ]\n    )\n    * 100\n).mean()\n\n3.390568533696099\n\n\nWhat proportion of blue light solutions that degrade starch use it for osmoticum?\n\n(\n    (\n        (scan_constraints[\"light\"] == \"blue\")\n        & (starch &gt; 0)\n        & (scan_results.RXN_2141_p_gc_2 &gt; 0)\n    ).sum()\n) / ((scan_constraints[\"light\"] == \"blue\") & (starch &gt; 0)).sum() * 100\n\n96.98231009365244\n\n\n\n((scan_constraints[\"light\"] == \"blue\") & (starch &gt; 0)).sum() - (\n    (\n        (scan_constraints[\"light\"] == \"blue\")\n        & (starch &gt; 0)\n        & (scan_results.RXN_2141_p_gc_2 &gt; 0)\n    ).sum()\n)\n\n29\n\n\n29 solutions doesn’t\n\nscan_constraints[\n    (\n        (scan_constraints[\"light\"] == \"blue\")\n        & (starch &gt; 0)\n        & ~(scan_results.RXN_2141_p_gc_2 &gt; 0)\n    )\n]\n\n\n\n\n\n\n\n\nP_abs\nT_l\nA_l\nV_gc_ind\nFqFm\nR_ch\nR_ch_vol\nL_air\nL_epidermis\nVac_frac\n...\nN_gcs\nn\nm\nr\ns\nC_apo\nA_closed\nA_open\nATPase\nlight\n\n\n\n\n1017\n0.982189\n0.000231\n1.0\n1.217851e-12\n0.806859\n0.073278\n0.211816\n0.312352\n0.170798\n0.850346\n...\n7.505322e+08\n2.216148\n0.988893\n7.629564e-14\n2.378212e-13\n0.036241\n3.213625\n3.269583\n5.188912\nblue\n\n\n1029\n0.987023\n0.000221\n1.0\n1.629365e-12\n0.838141\n0.096801\n0.204151\n0.251819\n0.217884\n0.765830\n...\n3.634520e+08\n1.950142\n0.846086\n7.725629e-14\n1.043478e-13\n0.028292\n2.862462\n3.198156\n13.387886\nblue\n\n\n1056\n0.833108\n0.000195\n1.0\n1.641114e-12\n0.848315\n0.162755\n0.206171\n0.278300\n0.189228\n0.863030\n...\n4.977284e+08\n1.533894\n0.896850\n7.795038e-14\n1.909829e-13\n0.034884\n3.554507\n3.763593\n14.205187\nblue\n\n\n1101\n0.986662\n0.000234\n1.0\n4.080272e-12\n0.833938\n0.038088\n0.195959\n0.208027\n0.195915\n0.851504\n...\n1.080920e+09\n2.176108\n0.871806\n6.374026e-14\n1.607315e-13\n0.031215\n2.021054\n2.957040\n13.642663\nblue\n\n\n1175\n0.845082\n0.000195\n1.0\n3.099346e-12\n0.858672\n0.105619\n0.192160\n0.271365\n0.122900\n0.805677\n...\n1.156622e+09\n1.676400\n0.938192\n7.393047e-14\n1.742883e-13\n0.034981\n3.772808\n3.898576\n11.481076\nblue\n\n\n1210\n0.979145\n0.000175\n1.0\n5.704240e-13\n0.888548\n0.072428\n0.191789\n0.325010\n0.203983\n0.860514\n...\n1.036523e+09\n1.899936\n0.859060\n5.463702e-14\n1.576704e-13\n0.028699\n3.722164\n4.071019\n8.231288\nblue\n\n\n1241\n0.964159\n0.000240\n1.0\n3.888226e-12\n0.849131\n0.040710\n0.202661\n0.308670\n0.218431\n0.872428\n...\n3.693487e+08\n2.243153\n0.842068\n6.859716e-14\n2.559610e-13\n0.035843\n3.687364\n3.924401\n16.420545\nblue\n\n\n1249\n0.936919\n0.000209\n1.0\n1.257865e-12\n0.826065\n0.170801\n0.201451\n0.200907\n0.221662\n0.862510\n...\n2.768268e+08\n1.579182\n0.975663\n7.358545e-14\n2.629005e-13\n0.034054\n2.918035\n3.666386\n16.455016\nblue\n\n\n1271\n0.894960\n0.000226\n1.0\n2.625296e-12\n0.794778\n0.090898\n0.192567\n0.205657\n0.192150\n0.771838\n...\n5.185705e+08\n1.732175\n0.982479\n5.191611e-14\n2.078991e-13\n0.033018\n2.881912\n3.278714\n10.054394\nblue\n\n\n1347\n0.937104\n0.000226\n1.0\n2.073399e-12\n0.877991\n0.157195\n0.191900\n0.227209\n0.225836\n0.794047\n...\n2.618422e+08\n1.733078\n0.888186\n5.059401e-14\n2.003447e-13\n0.023230\n3.869395\n4.290222\n12.594885\nblue\n\n\n1398\n0.924224\n0.000175\n1.0\n8.730863e-13\n0.804098\n0.113418\n0.198257\n0.249691\n0.188820\n0.869304\n...\n2.519070e+08\n2.475275\n0.986365\n5.905248e-14\n2.007580e-13\n0.035799\n3.375259\n3.767706\n13.067527\nblue\n\n\n1415\n0.980463\n0.000186\n1.0\n2.216273e-12\n0.833689\n0.123501\n0.191071\n0.215862\n0.172692\n0.880035\n...\n4.498390e+08\n1.516520\n0.868986\n6.725712e-14\n2.446887e-13\n0.029044\n2.734507\n3.267102\n15.278437\nblue\n\n\n1447\n0.936485\n0.000214\n1.0\n1.166534e-12\n0.804583\n0.064945\n0.212629\n0.306904\n0.192820\n0.899093\n...\n1.006072e+09\n2.229371\n0.889104\n7.800326e-14\n1.362171e-13\n0.025047\n3.167684\n3.208058\n2.280317\nblue\n\n\n1448\n0.966670\n0.000234\n1.0\n2.958310e-12\n0.880085\n0.164133\n0.208941\n0.256087\n0.185230\n0.857323\n...\n2.950038e+08\n2.331925\n0.969200\n6.444187e-14\n2.834842e-13\n0.033098\n2.317668\n3.042316\n16.947977\nblue\n\n\n1491\n0.974679\n0.000208\n1.0\n4.076222e-12\n0.854519\n0.064982\n0.193118\n0.366199\n0.142774\n0.786920\n...\n2.322279e+08\n2.420792\n0.998249\n7.561923e-14\n1.951285e-13\n0.028007\n3.455625\n3.655766\n5.111005\nblue\n\n\n1493\n0.963094\n0.000203\n1.0\n1.666351e-12\n0.804195\n0.045097\n0.201921\n0.242176\n0.169241\n0.808959\n...\n3.329225e+08\n2.363713\n0.949282\n6.266396e-14\n2.838072e-13\n0.030682\n3.007735\n3.103710\n5.312710\nblue\n\n\n1603\n0.828798\n0.000182\n1.0\n2.256641e-12\n0.823090\n0.156348\n0.190161\n0.341647\n0.136510\n0.863669\n...\n1.001502e+09\n2.262333\n0.826955\n5.891340e-14\n1.276337e-13\n0.037063\n1.408121\n2.911160\n16.306092\nblue\n\n\n1618\n0.860350\n0.000239\n1.0\n2.638787e-12\n0.805063\n0.075918\n0.202866\n0.263651\n0.217483\n0.822192\n...\n6.891091e+08\n1.943550\n0.962856\n5.344074e-14\n2.932053e-13\n0.023835\n2.757374\n2.839959\n13.055073\nblue\n\n\n1643\n0.976380\n0.000196\n1.0\n2.590073e-12\n0.880679\n0.112134\n0.197380\n0.199853\n0.194168\n0.888156\n...\n4.143898e+08\n2.315024\n0.956130\n7.757519e-14\n1.819379e-13\n0.024353\n2.559500\n3.075319\n11.496986\nblue\n\n\n1646\n0.904437\n0.000191\n1.0\n2.890408e-12\n0.855971\n0.090535\n0.211633\n0.204026\n0.171637\n0.763252\n...\n6.682905e+08\n2.352557\n0.989896\n6.372475e-14\n1.918218e-13\n0.033567\n3.435310\n3.815847\n11.200469\nblue\n\n\n1649\n0.884870\n0.000204\n1.0\n1.979075e-12\n0.893797\n0.126563\n0.192962\n0.217671\n0.227905\n0.830867\n...\n8.139443e+08\n1.620203\n0.873123\n5.074189e-14\n1.533827e-13\n0.031353\n2.452572\n2.999165\n15.016749\nblue\n\n\n1667\n0.899727\n0.000181\n1.0\n1.993103e-12\n0.800412\n0.172931\n0.202179\n0.349272\n0.208027\n0.798485\n...\n7.670398e+08\n1.800158\n0.835565\n6.995006e-14\n1.407586e-13\n0.031113\n3.087264\n3.514388\n7.141256\nblue\n\n\n1673\n0.892106\n0.000177\n1.0\n1.173797e-12\n0.899135\n0.163861\n0.211231\n0.285542\n0.130093\n0.825673\n...\n5.034766e+08\n2.221621\n0.883160\n6.236762e-14\n1.911845e-13\n0.033061\n2.937788\n3.420623\n11.979488\nblue\n\n\n1722\n0.912601\n0.000213\n1.0\n3.929522e-12\n0.857296\n0.115738\n0.199913\n0.219846\n0.168834\n0.820673\n...\n6.034846e+08\n1.885533\n0.834602\n5.926701e-14\n1.114504e-13\n0.026448\n3.925064\n4.209788\n9.645913\nblue\n\n\n1796\n0.960272\n0.000208\n1.0\n1.354988e-12\n0.818793\n0.089928\n0.194593\n0.186986\n0.128720\n0.791661\n...\n3.166402e+08\n1.704774\n0.950659\n5.391275e-14\n1.397527e-13\n0.036585\n1.860880\n2.862753\n14.719912\nblue\n\n\n1809\n0.983844\n0.000172\n1.0\n1.793328e-12\n0.839484\n0.139732\n0.211760\n0.273304\n0.175407\n0.804473\n...\n3.108818e+08\n2.147187\n0.931797\n7.462592e-14\n1.418139e-13\n0.031565\n2.515386\n2.979493\n14.923502\nblue\n\n\n1847\n0.887374\n0.000177\n1.0\n2.454361e-12\n0.885623\n0.064367\n0.204107\n0.344367\n0.161916\n0.755113\n...\n2.662198e+08\n2.351035\n0.805419\n5.355258e-14\n2.058304e-13\n0.028790\n3.046720\n3.561324\n12.764657\nblue\n\n\n1854\n0.961591\n0.000230\n1.0\n3.945766e-12\n0.869408\n0.117912\n0.202073\n0.199677\n0.153533\n0.896697\n...\n2.634596e+08\n1.580251\n0.963299\n5.448800e-14\n2.194085e-13\n0.032646\n2.411045\n2.771418\n15.957472\nblue\n\n\n1880\n0.943448\n0.000193\n1.0\n8.306288e-13\n0.858448\n0.095690\n0.190071\n0.213188\n0.205013\n0.835644\n...\n2.233424e+08\n1.547798\n0.803243\n7.226665e-14\n2.676576e-13\n0.025830\n3.005475\n3.303471\n12.003204\nblue\n\n\n\n\n29 rows × 22 columns\n\n\n\nWhat proportion of blue light solutions that degrade starch use it for energy?\n\n(\n    (\n        (scan_constraints[\"light\"] == \"blue\")\n        & (starch &gt; 0)\n        & (scan_results.MALTODEG_RXN_c_gc_2 &gt; 0)\n    ).sum()\n) / ((scan_constraints[\"light\"] == \"blue\") & (starch &gt; 0)).sum() * 100\n\n95.52549427679502\n\n\n\n(\n    (scan_constraints[\"light\"] == \"blue\")\n    & (starch &gt; 0)\n    & ~(scan_results.MALTODEG_RXN_c_gc_2 &gt; 0)\n).sum()\n\n43\n\n\n43 solutions that use starch in blue light don’t use the energy pathway\n\n(\n    (\n        (\n            scan_results[\n                (\n                    (scan_constraints[\"light\"] == \"blue\")\n                    & (starch &gt; 0)\n                    & (scan_results.MALTODEG_RXN_c_gc_2 &gt; 0)\n                )\n            ].MALTODEG_RXN_c_gc_2\n        )\n        / starch[\n            (\n                (scan_constraints[\"light\"] == \"blue\")\n                & (starch &gt; 0)\n                & (scan_results.MALTODEG_RXN_c_gc_2 &gt; 0)\n            )\n        ]\n    )\n    * 100\n).mean()\n\n6.917530468681961\n\n\nAverage of 6.9% of starch degraded was used for energy",
    "crumbs": [
      "Running constraints scan",
      "Analysing the results of the constraint scan"
    ]
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#d---how-does-glucose-increase-during-opening-vary-with-starch-and-why-isnt-it-totally-linear",
    "href": "3.3_analyse_constraint_scan.html#d---how-does-glucose-increase-during-opening-vary-with-starch-and-why-isnt-it-totally-linear",
    "title": "Analysing the results of the constraint scan",
    "section": "7d - How does glucose increase during opening vary with starch, and why isn’t it totally linear?",
    "text": "7d - How does glucose increase during opening vary with starch, and why isn’t it totally linear?\nIs sucrose degaded in the cytoplasm in any solutions?\n\n(scan_results[starch &gt; 0][\"RXN_1461_c_gc_2\"] &gt; 0).sum()\n\n0\n\n\nNo\n\nsucrose_degraded_v = scan_results[starch &gt; 0][\"RXN_1461_v_gc_2\"] &gt; 0.000001\nno_sucrose_degraded_v = scan_results[starch &gt; 0][\"RXN_1461_v_gc_2\"] &lt; 0.000001\nglucose_import_into_vacuole = (\n    scan_results[starch &gt; 0][\"GLC_PROTON_rev_cv_gc_2\"] &gt; 0.000001\n)\nno_glucose_import_into_vacuole = (\n    scan_results[starch &gt; 0][\"GLC_PROTON_rev_cv_gc_2\"] &lt; 0.000001\n)\n\n\nsucrose_deg_and_glc_import = sucrose_degraded_v & glucose_import_into_vacuole\nsucrose_deg_no_glc_import = sucrose_degraded_v & no_glucose_import_into_vacuole\nno_sucrose_deg_glc_import = no_sucrose_degraded_v & glucose_import_into_vacuole\nno_sucrose_deg_no_glc_import = no_sucrose_degraded_v & no_glucose_import_into_vacuole\n\n\nconditions = [\n    sucrose_deg_and_glc_import,\n    sucrose_deg_no_glc_import,\n    no_sucrose_deg_glc_import,\n    no_sucrose_deg_no_glc_import,\n]\nlabels = [\"+ S.d. + G.i.\", \"+ S.d - G.i.\", \"- S.d + G.i.\", \"- S.d - G.i.\"]\n\n\nfor condition, label in zip(conditions, labels):\n    print(f\"{label}:\")\n    print(\n        f\"Length: {(condition).sum()} ({((condition).sum()/len(scan_constraints[starch &gt; 0]) * 100).round(1)}%)\"\n    )\n    starch_proportion = (\n        (\n            scan_results[starch &gt; 0][condition].STARCH_p_gc_Linker_1\n            / scan_gc_constraints.loc[starch &gt; 0][condition].Os_dif\n        )\n        * 100\n    ).median()\n    print(f\"Starch median % of osmolarity: {starch_proportion}\")\n    starch_proportion = (\n        (\n            scan_results[starch &gt; 0][condition].STARCH_p_gc_Linker_1\n            / scan_gc_constraints.loc[starch &gt; 0][condition].Os_dif\n        )\n        * 100\n    ).mean()\n    print(f\"Starch mean % of osmolarity: {starch_proportion}\")\n    starch_proportion = (\n        (\n            scan_results[starch &gt; 0][condition].STARCH_p_gc_Linker_1\n            / scan_gc_constraints.loc[starch &gt; 0][condition].Os_dif\n        )\n        * 100\n    ).max()\n    print(f\"Starch max % of osmolarity: {starch_proportion}\")\n    starch_proportion = (\n        (\n            scan_results[starch &gt; 0][condition].STARCH_p_gc_Linker_1\n            / scan_gc_constraints.loc[starch &gt; 0][condition].Os_dif\n        )\n        * 100\n    ).min()\n    print(f\"Starch min % of osmolarity: {starch_proportion}\")\n\n+ S.d. + G.i.:\nLength: 1719 (90.9%)\nStarch median % of osmolarity: 70.715257356063\nStarch mean % of osmolarity: 70.75171038643512\nStarch max % of osmolarity: 100.98969258230284\nStarch min % of osmolarity: 33.70678055197705\n+ S.d - G.i.:\nLength: 48 (2.5%)\nStarch median % of osmolarity: 42.479873042042186\nStarch mean % of osmolarity: 40.49996318207206\nStarch max % of osmolarity: 71.26373430673459\nStarch min % of osmolarity: 19.421223452295543\n- S.d + G.i.:\nLength: 12 (0.6%)\nStarch median % of osmolarity: 27.90927615890679\nStarch mean % of osmolarity: 38.969721275346025\nStarch max % of osmolarity: 89.30464909167985\nStarch min % of osmolarity: 17.245084430356243\n- S.d - G.i.:\nLength: 113 (6.0%)\nStarch median % of osmolarity: 23.38726473224462\nStarch mean % of osmolarity: 26.19498288079809\nStarch max % of osmolarity: 88.4285135863311\nStarch min % of osmolarity: 0.010864363645033069\n\n\n\nglc_increase = (\n    scan_results[starch &gt; 0].GLC_total_pseudolinker_2\n    - scan_results[starch &gt; 0].GLC_total_pseudolinker_1\n)\nglc_increase_per_gc = glc_increase * 10**-3 / scan_constraints.N_gcs * 10**15\n\n\ndef glucose_vs_starch_subfig(ax):\n    x = [0, 600]\n    y = [0, 600]\n\n    size = 10\n\n    ax.plot(x, y, c=\"grey\", alpha=0.5, clip_on=False, linewidth=1)\n\n    conditions = [\n        sucrose_deg_and_glc_import,\n        sucrose_deg_no_glc_import,\n        no_sucrose_deg_glc_import,\n        no_sucrose_deg_no_glc_import,\n    ]\n    colours = [\n        sns.color_palette()[2],\n        sns.color_palette()[3],\n        sns.color_palette()[4],\n        sns.color_palette()[8],\n    ]\n    labels = [\"+ S.d. + G.i.\", \"+ S.d - G.i.\", \"- S.d + G.i.\", \"- S.d - G.i.\"]\n\n    glucose_increase_max = glc_increase_per_gc.max()\n\n    for condition, colour, label in zip(conditions, colours, labels):\n        ax.scatter(\n            starch_per_gc[starch &gt; 0][condition],\n            glc_increase_per_gc[starch &gt; 0][condition],\n            color=colour,\n            s=size,\n            label=label,\n            linewidths=0,\n            clip_on=False,\n        )\n\n    ax.set_xlabel(\"Starch degradation\\n\" r\"(fmol$\\cdot$GC$^{-1}$)\", size=\"medium\")\n    ax.set_ylabel(\"Increase in glucose (fmol$\\cdot$GC$^{-1}$)\", size=\"medium\")\n\n    y_max = glucose_increase_max\n    x_max = 600\n    major_increment = 200\n    ax.set_ylim(None, y_max)\n    ax.set_xlim(None, x_max)\n    ax.spines[\"left\"].set_bounds(0, y_max)\n    ax.spines[\"bottom\"].set_bounds(0, x_max)\n    ax.xaxis.set_major_locator(MultipleLocator(major_increment))\n    ax.xaxis.set_minor_locator(AutoMinorLocator(2))\n    ax.yaxis.set_major_locator(MultipleLocator(major_increment))\n    ax.yaxis.set_minor_locator(AutoMinorLocator(2))\n    ax.set_aspect(\"equal\")\n\n#     ax.vlines(\n#         184, ymin=0, ymax=570, linewidth=1, linestyle=\"--\", color=sns.color_palette()[6]\n#     )\n#     ax.text(\n#         184,\n#         570,\n#         \"Horrer et al. (2016)\",\n#         ha=\"center\",\n#         va=\"bottom\",\n#         size=\"x-small\",\n#         color=sns.color_palette()[6],\n#     )\n\n    ax.legend(\n        loc=\"lower right\", bbox_to_anchor=(1, 0), handletextpad=0, fontsize=\"x-small\"\n    )\n\n    return ax\n\n\nfig, ax = plt.subplots()\n\nglucose_vs_starch_subfig(ax)\n\nfig.savefig(\"../outputs/constraint_scan/starch_vs_glucose.svg\")\nfig.savefig(\"../outputs/constraint_scan/starch_vs_glucose.png\", dpi=300)\n\n\n\n\n\n\n\n\n\ndef glucose_vs_starch_subfig(ax):\n    x = [0, 600]\n    y = [0, 600]\n\n    size = 10\n\n    ax.plot(x, y, c=\"grey\", alpha=0.5, clip_on=False, linewidth=1)\n\n    conditions = [\n        sucrose_deg_and_glc_import,\n        no_sucrose_deg_glc_import,\n        no_sucrose_deg_no_glc_import,\n        sucrose_deg_no_glc_import,\n    ]\n    colours = [\n        sns.color_palette()[2],\n        sns.color_palette()[3],\n        sns.color_palette()[4],\n        sns.color_palette()[8],\n    ]\n    labels = [\"+ Suc deg + Glc import\", \"- Suc deg + Glc import\", \"- Suc deg - Glc import\", \"+ Suc deg - Glc import\"]\n\n    glucose_increase_max = glc_increase_per_gc.max()\n\n    for condition, colour, label in zip(conditions, colours, labels):\n        ax.scatter(\n            starch_per_gc[starch &gt; 0][condition],\n            glc_increase_per_gc[starch &gt; 0][condition],\n            color=colour,\n            s=size,\n            label=label,\n            linewidths=0,\n            clip_on=False,\n        )\n\n    ax.set_xlabel(\"Starch degradation\\n\" r\"(fmol$\\cdot$GC$^{-1}$)\", size=\"medium\")\n    ax.set_ylabel(\"Increase in glucose (fmol$\\cdot$GC$^{-1}$)\", size=\"medium\")\n\n    #y_max = glucose_increase_max\n    y_max = 600\n    x_max = 600\n    major_increment = 200\n    ax.set_ylim(None, y_max)\n    ax.set_xlim(None, x_max)\n    ax.spines[\"left\"].set_bounds(0, y_max)\n    ax.spines[\"bottom\"].set_bounds(0, x_max)\n    ax.xaxis.set_major_locator(MultipleLocator(major_increment))\n    ax.xaxis.set_minor_locator(AutoMinorLocator(2))\n    ax.yaxis.set_major_locator(MultipleLocator(major_increment))\n    ax.yaxis.set_minor_locator(AutoMinorLocator(2))\n    ax.set_aspect(\"equal\")\n\n#     ax.vlines(\n#         184, ymin=0, ymax=570, linewidth=1, linestyle=\"--\", color=sns.color_palette()[6]\n#     )\n#     ax.text(\n#         184,\n#         570,\n#         \"Horrer et al. (2016)\",\n#         ha=\"center\",\n#         va=\"bottom\",\n#         size=\"x-small\",\n#         color=sns.color_palette()[6],\n#     )\n\n    ax.legend(\n        loc=\"lower right\", bbox_to_anchor=(1, 0), handletextpad=0, fontsize='x-small'\n        #prop={'family': 'DejaVu Sans Mono', 'size': 'x-small'},\n    )\n\n    return ax\n\n\nfig, ax = plt.subplots()\n\nglucose_vs_starch_subfig(ax)\n\nfig.savefig(\"../outputs/constraint_scan/starch_vs_glucose.svg\")\nfig.savefig(\"../outputs/constraint_scan/starch_vs_glucose.png\", dpi=300)",
    "crumbs": [
      "Running constraints scan",
      "Analysing the results of the constraint scan"
    ]
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#combine-subfigures",
    "href": "3.3_analyse_constraint_scan.html#combine-subfigures",
    "title": "Analysing the results of the constraint scan",
    "section": "Combine subfigures",
    "text": "Combine subfigures\n\nfig, axs = plt.subplots(2, 2, figsize=(10, 10))\n\nplt.subplots_adjust(hspace=0.5, wspace=0.35)\n\nphloemoutput_subfig(axs[0][0])\n\nphotons_vs_carbon_export_subfig(axs[0][1])\n\nstarch_vs_os_subfig(axs[1][0])\n\nglucose_vs_starch_subfig(axs[1][1])\naxs[1][1].get_legend().remove()\n\nfor ax, letter in zip(\n    [axs[0][0], axs[0][1], axs[1][0], axs[1][1]], [\"A\", \"B\", \"C\", \"D\"]\n):\n    if letter != \"D\":\n        ax.text(-0.4, 1.06, letter, transform=ax.transAxes, size=20, weight=\"bold\")\n    else:\n        ax.text(-0.333, 1.06, letter, transform=ax.transAxes, size=20, weight=\"bold\")\n\nfig.savefig(\n    \"../outputs/constraint_scan/constraint_scan_analysis_plot.svg\", transparent=True\n)\nfig.savefig(\n    \"../outputs/constraint_scan/constraint_scan_analysis_plot.png\", transparent=True\n)",
    "crumbs": [
      "Running constraints scan",
      "Analysing the results of the constraint scan"
    ]
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#extra-analyses-not-included",
    "href": "3.3_analyse_constraint_scan.html#extra-analyses-not-included",
    "title": "Analysing the results of the constraint scan",
    "section": "Extra analyses not included",
    "text": "Extra analyses not included\n\nWhat is the ratio of mitochondrial to plastidic ATP synthase?\n\nfig, axs = plt.subplots(1, 2, figsize=(10, 4))\n\naxs[0].hist(\n    scan_results.Plastidial_ATP_Synthase_p_gc_2[scan_constraints.light == \"white\"]\n    / scan_results.Mitochondrial_ATP_Synthase_m_gc_2[scan_constraints.light == \"white\"],\n    bins=100,\n)\naxs[0].set_title(\"Opening in white light\")\naxs[0].set_xlabel(\"Plastidial ATP Synthase\\nMitochondrial ATP Synthase\")\naxs[1].hist(\n    scan_results.Plastidial_ATP_Synthase_p_gc_3\n    / scan_results.Mitochondrial_ATP_Synthase_m_gc_3,\n    bins=100,\n)\naxs[1].set_title(\"Day in both light types\")\naxs[1].set_xlabel(\"Plastidial ATP Synthase\\nMitochondrial ATP Synthase\")\n\nText(0.5, 0, 'Plastidial ATP Synthase\\nMitochondrial ATP Synthase')\n\n\n\n\n\n\n\n\n\n\nfig, ax = plt.subplots(1, figsize=(5, 4))\n\nplastidial_atp_max = scan_results.loc[\n    :, [\"Plastidial_ATP_Synthase_p_gc_3\", \"Plastidial_ATP_Synthase_p_gc_2\"]\n].max(axis=1)\nmitochondial_atp_max = scan_results.loc[\n    :, [\"Mitochondrial_ATP_Synthase_m_gc_3\", \"Mitochondrial_ATP_Synthase_m_gc_2\"]\n].max(axis=1)\n\nfor light in [\"blue\", \"white\"]:\n    ax.hist(\n        plastidial_atp_max[scan_constraints.light == light]\n        / mitochondial_atp_max[scan_constraints.light == light],\n        histtype=\"step\",\n        label=light,\n    )\n\nax.set_xlabel(\"Max plastidial ATP Synthase\\nMax mitochondrial ATP Synthase\")\n\nax.legend()\n\n\n\n\n\n\n\n\n\nfig, ax = plt.subplots()\n\nax.plot([0, 0.3], [0, 0.3], c=\"grey\", zorder=0)\nax.scatter(plastidial_atp_max, mitochondial_atp_max, s=1)\n\n\n\n\n\n\n\n\n\n(plastidial_atp_max / mitochondial_atp_max).min()\n\n0.016260605303926066",
    "crumbs": [
      "Running constraints scan",
      "Analysing the results of the constraint scan"
    ]
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#almost-all-starch-is-used-for-glucose-and-pep-carboxykinase-reaction-never-runs",
    "href": "3.3_analyse_constraint_scan.html#almost-all-starch-is-used-for-glucose-and-pep-carboxykinase-reaction-never-runs",
    "title": "Analysing the results of the constraint scan",
    "section": "Almost all starch is used for glucose, and PEP carboxykinase reaction never runs",
    "text": "Almost all starch is used for glucose, and PEP carboxykinase reaction never runs\n\n(scan_results.PEPCARBOX_RXN_c_gc_2 &gt; 0).sum()\n\n77\n\n\n\n(scan_results.PEPDEPHOS_RXN_c_gc_2 &gt; 0).sum()\n\n1237\n\n\n\n((scan_results.MALTODEG_RXN_c_gc_2 &gt; 0) & (scan_results.PEPDEPHOS_RXN_c_gc_2 &gt; 0)).sum()\n\n1227\n\n\n\n((scan_results.MALTODEG_RXN_c_gc_2 &gt; 0) & (scan_results.PYRUVDEH_RXN_m_gc_2 &gt; 0)).sum()\n\n1227\n\n\n\n(\n    (scan_results.MALTODEG_RXN_c_gc_2 &gt; 0)\n    & (scan_results.ISOCITRATE_DEHYDROGENASE_NAD_RXN_m_gc_2 &gt; 0)\n).sum()\n\n1266\n\n\n\n(\n    scan_results[(scan_results.MALTODEG_RXN_c_gc_2 &gt; 0)].MALTODEG_RXN_c_gc_2 / 2\n    - scan_results[(scan_results.MALTODEG_RXN_c_gc_2 &gt; 0)].PEPDEPHOS_RXN_c_gc_2\n).hist(bins=100)\n\n\n\n\n\n\n\n\n\n(\n    scan_results[(scan_results.MALTODEG_RXN_c_gc_2 &gt; 0)].MALTODEG_RXN_c_gc_2 / 2\n    - scan_results[(scan_results.MALTODEG_RXN_c_gc_2 &gt; 0)].PYRUVDEH_RXN_m_gc_2\n).hist(bins=100)\n\n\n\n\n\n\n\n\n\n(\n    scan_results[(scan_results.MALTODEG_RXN_c_gc_2 &gt; 0)].MALTODEG_RXN_c_gc_2\n    - scan_results[\n        (scan_results.MALTODEG_RXN_c_gc_2 &gt; 0)\n    ].ISOCITRATE_DEHYDROGENASE_NAD_RXN_m_gc_2\n)\n\n0       0.001622\n1       0.005446\n3       0.001043\n4       0.001028\n6       0.006612\n          ...   \n1931    0.003674\n1932    0.002604\n1933    0.007325\n1934    0.002005\n1935    0.005452\nLength: 1266, dtype: float64\n\n\n\n(scan_results.MAL_total_pseudolinker_2 &gt; 0).sum()\n\n433\n\n\n\nscan_constraints[\n    (\n        (scan_results.MAL_total_pseudolinker_2 - scan_results.MAL_total_pseudolinker_1)\n        &gt; 0\n    )\n]\n\n\n\n\n\n\n\n\nP_abs\nT_l\nA_l\nV_gc_ind\nFqFm\nR_ch\nR_ch_vol\nL_air\nL_epidermis\nVac_frac\n...\nN_gcs\nn\nm\nr\ns\nC_apo\nA_closed\nA_open\nATPase\nlight\n\n\n\n\n1\n0.923180\n0.000190\n1.0\n1.250880e-12\n0.889162\n0.093534\n0.195869\n0.337197\n0.196606\n0.837767\n...\n1.064044e+09\n2.025073\n0.946228\n5.400144e-14\n1.664063e-13\n0.023524\n2.500598\n9.754649\n0.549826\nwhite\n\n\n6\n0.912552\n0.000236\n1.0\n2.797833e-12\n0.791717\n0.122612\n0.211564\n0.203218\n0.121087\n0.788955\n...\n8.580407e+08\n1.718809\n0.985739\n6.484944e-14\n2.811758e-13\n0.028334\n1.156307\n11.339261\n2.620532\nwhite\n\n\n7\n0.811951\n0.000203\n1.0\n1.725438e-12\n0.862305\n0.134778\n0.202345\n0.342059\n0.149051\n0.886573\n...\n5.641395e+08\n2.345712\n0.922066\n7.661761e-14\n1.713217e-13\n0.024734\n3.836327\n11.685743\n0.807819\nwhite\n\n\n13\n0.868580\n0.000235\n1.0\n2.230336e-12\n0.813387\n0.143595\n0.210389\n0.231901\n0.233709\n0.788520\n...\n8.827028e+08\n1.563814\n0.955703\n5.755866e-14\n2.976694e-13\n0.032311\n2.576765\n10.693166\n4.401374\nwhite\n\n\n28\n0.905738\n0.000226\n1.0\n2.077161e-12\n0.858599\n0.065746\n0.199877\n0.232093\n0.200455\n0.892994\n...\n1.832267e+08\n2.259343\n0.879945\n6.486503e-14\n1.705626e-13\n0.027999\n2.573815\n6.189742\n0.199106\nwhite\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n1929\n0.963328\n0.000213\n1.0\n3.549447e-12\n0.822882\n0.088125\n0.207902\n0.284514\n0.172490\n0.882110\n...\n3.941232e+08\n1.836419\n0.800060\n7.761785e-14\n1.283119e-13\n0.025384\n3.250332\n8.157482\n5.580050\nblue\n\n\n1930\n0.878002\n0.000222\n1.0\n2.235053e-12\n0.861774\n0.132702\n0.209615\n0.209708\n0.145820\n0.865507\n...\n3.784323e+08\n2.348202\n0.814245\n5.768938e-14\n2.320267e-13\n0.030561\n2.664441\n11.247607\n3.675367\nblue\n\n\n1932\n0.957473\n0.000185\n1.0\n2.755496e-12\n0.798181\n0.097823\n0.201847\n0.193194\n0.138359\n0.823731\n...\n6.623405e+08\n1.889247\n0.969003\n6.787495e-14\n1.566538e-13\n0.032169\n1.321999\n5.766979\n2.750124\nblue\n\n\n1933\n0.816118\n0.000174\n1.0\n2.957736e-12\n0.825422\n0.149150\n0.200244\n0.323872\n0.209562\n0.830375\n...\n9.035571e+08\n1.971395\n0.971101\n7.917051e-14\n2.960270e-13\n0.031594\n1.293918\n7.247967\n1.492903\nblue\n\n\n1935\n0.953724\n0.000240\n1.0\n1.884973e-12\n0.894087\n0.135577\n0.189014\n0.241198\n0.137301\n0.844829\n...\n5.504971e+08\n1.561648\n0.977668\n6.731378e-14\n2.085531e-13\n0.036108\n2.326208\n9.325369\n4.832752\nblue\n\n\n\n\n375 rows × 22 columns\n\n\n\n\n#starch[1384]\n\n\n#(scan_constraints.loc[1384] - scan_constraints.mean()) / scan_constraints.std()\n\n\n#scan_constraints.loc[1384].ATPase\n\n\nscan_constraints.mean().ATPase\n\n/tmp/ipykernel_8731/856568451.py:1: FutureWarning: The default value of numeric_only in DataFrame.mean is deprecated. In a future version, it will default to False. In addition, specifying 'numeric_only=None' is deprecated. Select only valid columns or specify the value of numeric_only to silence this warning.\n  scan_constraints.mean().ATPase\n\n\n8.53114718372621\n\n\n\n#atpase_constrained[1384]\n\n\n#scan_results.loc[1384].MALTODEG_RXN_c_gc_2 / starch[1384] * 100\n\n\n#scan_results.loc[1384].RXN_2141_p_gc_2\n\n\n#scan_results.loc[1384].MALATE_DEH_RXN_m_gc_2\n\n\n#scan_results.loc[1384].ISOCITRATE_DEHYDROGENASE_NAD_RXN_m_gc_2\n\n\n#(scan_gc_constraints.loc[1384] - scan_gc_constraints.mean()) / scan_gc_constraints.std()\n\n\nfor i in [i+1 for i in range(4)]:\n    reaction = f\"PALMITATE_c_gc_Linker_{i}\"\n    print(reaction)\n    print(scan_results.loc[:, reaction].sum())\n\nPALMITATE_c_gc_Linker_1\n0.0\nPALMITATE_c_gc_Linker_2\n0.0\nPALMITATE_c_gc_Linker_3\n0.0\nPALMITATE_c_gc_Linker_4\n0.0\n\n\n\nscan_results.filter(like=\"ATPase\", axis=1)\n\n\n\n\n\n\n\n\nPROTON_ATPase_c_me_1\nPROTON_ATPase_c_me_2\nPROTON_ATPase_c_me_3\nPROTON_ATPase_c_me_4\nPROTON_ATPase_c_gc_1\nPROTON_ATPase_c_gc_2\nPROTON_ATPase_c_gc_3\nPROTON_ATPase_c_gc_4\nATPase_tx_me_1\nATPase_tx_me_2\nATPase_tx_me_3\nATPase_tx_me_4\nATPase_tx_gc_1\nATPase_tx_gc_2\nATPase_tx_gc_3\nATPase_tx_gc_4\n\n\n\n\n0\n1.107532\n3.646232\n3.763789\n1.104726\n0.000025\n0.004851\n0.004851\n0.000025\n10.025916\n12.182122\n12.182122\n10.025916\n0.000444\n0.000973\n0.000973\n0.000444\n\n\n1\n1.271757\n4.186898\n4.311376\n1.268535\n0.000057\n0.000585\n0.000585\n0.000057\n10.025916\n12.468127\n12.468127\n10.025916\n0.000444\n0.000967\n0.000967\n0.000444\n\n\n2\n1.131079\n3.723755\n3.832643\n1.128600\n0.000000\n0.004505\n0.000000\n0.000000\n10.025916\n12.223283\n12.223283\n10.025916\n0.000444\n0.000598\n0.000598\n0.000444\n\n\n3\n1.207758\n3.976199\n4.097909\n1.204698\n0.000583\n0.004855\n0.002277\n0.000583\n10.025916\n12.356973\n12.356973\n10.025916\n0.000444\n0.000508\n0.000508\n0.000444\n\n\n4\n1.260299\n4.149174\n4.286096\n1.257106\n0.000025\n0.011479\n0.007823\n0.000025\n10.025916\n12.448415\n12.448415\n10.025916\n0.000444\n0.000614\n0.000614\n0.000444\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n1931\n1.105102\n3.315307\n3.773362\n1.102419\n0.000025\n0.006605\n0.006605\n0.000025\n10.025916\n10.025916\n12.273932\n10.025916\n0.000444\n0.000444\n0.001019\n0.000444\n\n\n1932\n1.261907\n3.785721\n4.297397\n1.258843\n0.000057\n0.001822\n0.001822\n0.000057\n10.025916\n10.025916\n12.558822\n10.025916\n0.000444\n0.000444\n0.001011\n0.000444\n\n\n1933\n1.056017\n3.168052\n3.599472\n1.053454\n0.000057\n0.001349\n0.001349\n0.000057\n10.025916\n10.025916\n12.183832\n10.025916\n0.000444\n0.000444\n0.001976\n0.000444\n\n\n1934\n1.228512\n3.685537\n4.184889\n1.225530\n0.000025\n0.003092\n0.003092\n0.000215\n10.025916\n10.025916\n12.498539\n10.025916\n0.000444\n0.000444\n0.000641\n0.000444\n\n\n1935\n1.256399\n3.769198\n4.279254\n1.253349\n0.000057\n0.002660\n0.002660\n0.000057\n10.025916\n10.025916\n12.549088\n10.025916\n0.000444\n0.000444\n0.000826\n0.000444\n\n\n\n\n1934 rows × 16 columns\n\n\n\n\nscan_constraints\n\n\n\n\n\n\n\n\nP_abs\nT_l\nA_l\nV_gc_ind\nFqFm\nR_ch\nR_ch_vol\nL_air\nL_epidermis\nVac_frac\n...\nN_gcs\nn\nm\nr\ns\nC_apo\nA_closed\nA_open\nATPase\nlight\n\n\n\n\n0\n0.815093\n0.000194\n1.0\n2.262641e-12\n0.809297\n0.179970\n0.191527\n0.240879\n0.214860\n0.858645\n...\n4.484392e+08\n1.933548\n0.992641\n7.886553e-14\n1.678654e-13\n0.033679\n2.321339\n11.318979\n10.816668\nwhite\n\n\n1\n0.923180\n0.000190\n1.0\n1.250880e-12\n0.889162\n0.093534\n0.195869\n0.337197\n0.196606\n0.837767\n...\n1.064044e+09\n2.025073\n0.946228\n5.400144e-14\n1.664063e-13\n0.023524\n2.500598\n9.754649\n0.549826\nwhite\n\n\n2\n0.830507\n0.000220\n1.0\n5.035745e-13\n0.821060\n0.167889\n0.204824\n0.331556\n0.205674\n0.816618\n...\n5.758277e+08\n2.141889\n0.972835\n6.579620e-14\n2.457118e-13\n0.034062\n2.802180\n3.338120\n7.823891\nwhite\n\n\n3\n0.880998\n0.000192\n1.0\n8.629192e-13\n0.866582\n0.051244\n0.204472\n0.309538\n0.169957\n0.813726\n...\n3.851195e+08\n2.077401\n0.940848\n5.747590e-14\n1.515328e-13\n0.029770\n3.399462\n9.936390\n12.606738\nwhite\n\n\n4\n0.915597\n0.000220\n1.0\n7.391447e-13\n0.846358\n0.059969\n0.193449\n0.352066\n0.238671\n0.810491\n...\n1.046353e+09\n2.396012\n0.817798\n7.654181e-14\n1.652973e-13\n0.028420\n3.305233\n7.650706\n10.970481\nwhite\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n1931\n0.849808\n0.000174\n1.0\n2.640313e-12\n0.880585\n0.134355\n0.193583\n0.289995\n0.213762\n0.794641\n...\n4.117855e+08\n1.711337\n0.981658\n6.898412e-14\n1.062431e-13\n0.033170\n1.843784\n11.521533\n16.039577\nblue\n\n\n1932\n0.957473\n0.000185\n1.0\n2.755496e-12\n0.798181\n0.097823\n0.201847\n0.193194\n0.138359\n0.823731\n...\n6.623405e+08\n1.889247\n0.969003\n6.787495e-14\n1.566538e-13\n0.032169\n1.321999\n5.766979\n2.750124\nblue\n\n\n1933\n0.816118\n0.000174\n1.0\n2.957736e-12\n0.825422\n0.149150\n0.200244\n0.323872\n0.209562\n0.830375\n...\n9.035571e+08\n1.971395\n0.971101\n7.917051e-14\n2.960270e-13\n0.031594\n1.293918\n7.247967\n1.492903\nblue\n\n\n1934\n0.934550\n0.000234\n1.0\n1.122269e-12\n0.799613\n0.047919\n0.202674\n0.351210\n0.192651\n0.814861\n...\n1.121745e+09\n2.313188\n0.857276\n6.322405e-14\n1.450759e-13\n0.023108\n2.345988\n6.138390\n2.756515\nblue\n\n\n1935\n0.953724\n0.000240\n1.0\n1.884973e-12\n0.894087\n0.135577\n0.189014\n0.241198\n0.137301\n0.844829\n...\n5.504971e+08\n1.561648\n0.977668\n6.731378e-14\n2.085531e-13\n0.036108\n2.326208\n9.325369\n4.832752\nblue\n\n\n\n\n1934 rows × 22 columns\n\n\n\n\nprint(min(scan_constraints.P_abs))\nprint(min(scan_results.Phloem_tx_overall))\n\n0.8101673308967071\n12.675979574938289\n\n\n\nprint(max(scan_constraints.R_ch_vol))\nprint(min(scan_constraints.R_ch_vol))\n\n0.2128525606703812\n0.1889727321710271",
    "crumbs": [
      "Running constraints scan",
      "Analysing the results of the constraint scan"
    ]
  },
  {
    "objectID": "functions/osmolyteconstraints.html",
    "href": "functions/osmolyteconstraints.html",
    "title": "osmolyteconstraints",
    "section": "",
    "text": "def constrainosmolytelevels(model, osmolytelevels):\n    closedphaseos = model.osmolarities[0]/model.getvolumes(perguardcell = False)[0]\n\n    totallevel = 0\n    for osmolytelevel in osmolytelevels.values():\n        totallevel += osmolytelevel[0][1]\n    scaling_closed = closedphaseos/totallevel\n\n    openphaseos = model.osmolarities[1]/model.getvolumes(perguardcell = False)[1]\n\n    totallevel = 0\n    for osmolytelevel in osmolytelevels.values():\n        totallevel += osmolytelevel[1][1]\n    scaling_open = openphaseos/totallevel\n\n    print(scaling_closed, scaling_open)\n    \n    osmolytelevel_scaled = copy.deepcopy(osmolytelevels)\n\n    for osmolytelevel in osmolytelevel_scaled.values():\n        osmolytelevel[0][1] = osmolytelevel[0][1]*scaling_closed\n        osmolytelevel[1][1] = osmolytelevel[1][1]*scaling_open\n        osmolytelevel[0][1] = osmolytelevel[1][1] # IMPORTANT LINE ignores scaling closed\n\n    otherlist = []\n    skipother = [\"aMAL\", \"STARCH\"]\n\n    for reaction in model.model.reactions:\n        if \"gc_Linker_1\" in reaction.id:\n            osmolytename = \"_\".join(reaction.id.split(\"_\")[:-4])\n            if osmolytename in skipother:\n                continue\n            other = True\n            if osmolytename in osmolytelevel_scaled:\n                other = False\n            if other == True:\n                otherlist.append(osmolytename)\n    for osmolyte, concentration in osmolytelevel_scaled.items():\n\n        if osmolyte == \"Other\":\n            for other in otherlist:\n                try:\n                    constraints_open = [model.model.problem.Constraint((model.model.reactions.get_by_id(other + \"_v_gc_Linker_\" + str(phase)).flux_expression+model.model.reactions.get_by_id(other + \"_c_gc_Linker_\" + str(phase)).flux_expression)/model.getvolumes(perguardcell = False)[phase-1],\n                        lb=concentration[1][0],\n                        ub=concentration[1][1]) for phase in [2]]\n                    constraints_closed = [model.model.problem.Constraint((model.model.reactions.get_by_id(other + \"_v_gc_Linker_\" + str(phase)).flux_expression+model.model.reactions.get_by_id(other + \"_c_gc_Linker_\" + str(phase)).flux_expression)/model.getvolumes(perguardcell = False)[phase-1],\n                        lb=concentration[0][0],\n                        ub=concentration[0][1]) for phase in [1,3,4]]\n                except:\n                    constraints_open = [model.model.problem.Constraint((model.model.reactions.get_by_id(other + \"_v_gc_Linker_\" + str(phase)).flux_expression)/model.getvolumes(perguardcell = False)[phase-1],\n                        lb=concentration[1][0],\n                        ub=concentration[1][1]) for phase in [2]]\n                    constraints_closed = [model.model.problem.Constraint((model.model.reactions.get_by_id(other + \"_v_gc_Linker_\" + str(phase)).flux_expression)/model.getvolumes(perguardcell = False)[phase-1],\n                        lb=concentration[0][0],\n                        ub=concentration[0][1]) for phase in [1,3,4]]\n                for constraint in constraints_open+constraints_closed:\n                    model.model.add_cons_vars(constraint)\n\n        elif osmolyte == \"MAL\":\n            constraints_open = [model.model.problem.Constraint((model.model.reactions.get_by_id(osmolyte + \"_v_gc_Linker_\" + str(phase)).flux_expression+model.model.reactions.get_by_id(\"a\" + osmolyte + \"_v_gc_Linker_\" + str(phase)).flux_expression+model.model.reactions.get_by_id(osmolyte + \"_c_gc_Linker_\" + str(phase)).flux_expression)/model.getvolumes(perguardcell = False)[phase-1],\n                        lb=concentration[1][0],\n                        ub=concentration[1][1]) for phase in [2]]\n            constraints_closed = [model.model.problem.Constraint((model.model.reactions.get_by_id(osmolyte + \"_v_gc_Linker_\" + str(phase)).flux_expression+model.model.reactions.get_by_id(\"a\" + osmolyte + \"_v_gc_Linker_\" + str(phase)).flux_expression+model.model.reactions.get_by_id(osmolyte + \"_c_gc_Linker_\" + str(phase)).flux_expression)/model.getvolumes(perguardcell = False)[phase-1],\n                lb=concentration[0][0],\n                ub=concentration[0][1]) for phase in [1,3,4]]\n            for constraint in constraints_open+constraints_closed:\n                model.model.add_cons_vars(constraint)\n\n        else:\n            constraints_open = [model.model.problem.Constraint((model.model.reactions.get_by_id(osmolyte + \"_v_gc_Linker_\" + str(phase)).flux_expression+model.model.reactions.get_by_id(osmolyte + \"_c_gc_Linker_\" + str(phase)).flux_expression)/model.getvolumes(perguardcell = False)[phase-1],\n                        lb=concentration[1][0],\n                        ub=concentration[1][1]) for phase in [2]]\n            constraints_closed = [model.model.problem.Constraint((model.model.reactions.get_by_id(osmolyte + \"_v_gc_Linker_\" + str(phase)).flux_expression+model.model.reactions.get_by_id(osmolyte + \"_c_gc_Linker_\" + str(phase)).flux_expression)/model.getvolumes(perguardcell = False)[phase-1],\n                lb=concentration[0][0],\n                ub=concentration[0][1]) for phase in [1,3,4]]\n            for constraint in constraints_open+constraints_closed:\n                model.model.add_cons_vars(constraint)",
    "crumbs": [
      "functions",
      "osmolyteconstraints"
    ]
  },
  {
    "objectID": "functions/buildingediting.html",
    "href": "functions/buildingediting.html",
    "title": "buildingediting",
    "section": "",
    "text": "source\n\nadd_metabolite\n\n add_metabolite (model, name, compartment='default', multi=True)\n\nThis function adds a metabolite to the given model, and returns this metabolite. If multi is set to true it will be added to every phase of the model.\n\nsource\n\n\nadd_reaction\n\n add_reaction (model, name, multi=True)\n\nThis function adds a reaction to the given model, and returns this reaction. If multi is set to true it will be added to every phase of the model.\n\nsource\n\n\nsplit_model\n\n split_model (model, labels)\n\n*This function takes two arguments: the model to be split and the labels for the models to split it into. len(labels) number of models will be created, with the suffix “_label” to define them.*\n\nsource\n\n\ncheck_number_of_models\n\n check_number_of_models (model)\n\nThis function returns the number of phases of the model based on the maximal number of the last tag\n\nsource\n\n\nset_bounds_multi\n\n set_bounds_multi (model, reaction_id, lower_flux, upper_flux)\n\nConstrain a reaction’s flux in all phases\n\nsource\n\n\nadd_linkers\n\n add_linkers (model, linkers_file, compartments, cells, phase_times)\n\nThis function adds linker reactions for osmolytes to a phased model of guard cell, and adds osmolarity and charge linker pseudoreactions. It takes five arguments: model: the model to which linkers are to be added linkersfile: a .csv file with a list of osmolytes and their osmotic coefficients, leave the osmotic coefficient at 0 to add as a linker but not contribute to osmolarity compartments: a list of the compartments to add linker reactions to within cells cells: a list of cell tags to be used phase_times: a list of the lengths of each phase, for scaling of the linker reactions\n\nsource\n\n\ndef_linkers\n\n def_linkers (file)\n\nThis function creates a dict of osmolytes and their osmotic coefficients from the .csv file, and is used by addlinkers\n\nsource\n\n\nadd_metabolites_to_reaction_multi\n\n add_metabolites_to_reaction_multi (model, reaction, metabolites_dict)\n\nThis function adds a dictionary of metabolites to a reaction in every phase of the model",
    "crumbs": [
      "functions",
      "buildingediting"
    ]
  },
  {
    "objectID": "functions/constraintscan.html",
    "href": "functions/constraintscan.html",
    "title": "constraintscan",
    "section": "",
    "text": "source\n\nnormalise_within_bounds\n\n normalise_within_bounds (constraint_series, parameter_df)\n\n\nsource\n\n\ngenerate_constraints_df\n\n generate_constraints_df (constraints_df, params_df)\n\nThis functions takes a list of constraints along with a dataframe that contains the bounds for the parameters that these constraints should apply to It uses the bounds from the dataframe with the values from the constraints_list to generate a dataframe of constraints for running a constraint scan\n\nsource\n\n\nsolve_model_for_constraint_scan\n\n solve_model_for_constraint_scan (constraints, fba_model, light_colour,\n                                  printouts=False)",
    "crumbs": [
      "functions",
      "constraintscan"
    ]
  },
  {
    "objectID": "functions/solving.html",
    "href": "functions/solving.html",
    "title": "solving",
    "section": "",
    "text": "source\n\npfba_Weighted\n\n pfba_Weighted (model, weightings=None, fraction_of_optimum=1.0,\n                objective=None, reactions=None)\n\n*Perform basic pFBA (parsimonious Enzyme Usage Flux Balance Analysis) to minimize total flux. pFBA [1] adds the minimization of all fluxes the the objective of the model. This approach is motivated by the idea that high fluxes have a higher enzyme turn-over and that since producing enzymes is costly, the cell will try to minimize overall flux while still maximizing the original objective function, e.g. the growth rate.\n\nParameters:\nmodel : cobra.Model The model fraction_of_optimum : float, optional Fraction of optimum which must be maintained. The original objective reaction is constrained to be greater than maximal_value * fraction_of_optimum. objective : dict or model.problem.Objective A desired objective to use during optimization in addition to the pFBA objective. Dictionaries (reaction as key, coefficient as value) can be used for linear objectives. reactions : iterable List of reactions or reaction identifiers. Implies return_frame to be true. Only return fluxes for the given reactions. Faster than fetching all fluxes if only a few are needed.\n\n\nReturns:\ncobra.Solution\nThe solution object to the optimized model with pFBA constraints added.\nReferences: .. [1] Lewis, N. E., Hixson, K. K., Conrad, T. M., Lerman, J. A., Charusanti, P., Polpitiya, A. D., Palsson, B. O. (2010). Omic data from evolved E. coli are consistent with computed optimal growth from genome-scale models. Molecular Systems Biology, 6, 390. doi:10.1038/msb.2010.47*\n\nsource\n\n\n\nadd_pfba_Weighted\n\n add_pfba_Weighted (model, weightings=None, objective=None,\n                    fraction_of_optimum=1.0)\n\n*This function is a modified version of cobrapy add_pfba function\nAdd pFBA objective Add objective to minimize the summed flux of all reactions to the current objective.\nSee Also: pfba\nParameters: model : cobra.Model The model to add the objective to objective : An objective to set in combination with the pFBA objective. fraction_of_optimum : float Fraction of optimum which must be maintained. The original objective reaction is constrained to be greater than maximal_value  fraction_of_optimum.\n\nsource\n\n\nget_weightings\n\n get_weightings (model)\n\nThis function is used by pfba_weighted to generate default weightings for the guard cell model It takes the model as an argument and returns the weightings based on the phase lengths of the model.\n\nsource\n\n\nflux_variability_analysis\n\n flux_variability_analysis (model,\n                            reaction_list:Optional[List[Union[ForwardRef('\n                            Reaction'),str]]]=None, loopless:bool=False,\n                            fraction_of_optimum:float=1.0,\n                            pfba_factor:Optional[float]=None,\n                            processes:Optional[int]=None)\n\nDetermine the minimum and maximum flux value for each reaction.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmodel\ncobra.Model\n\nThe model for which to run the analysis. It will not be modified.\n\n\nreaction_list\nOptional\nNone\nThe reactions for which to obtain min/max fluxes. If None will useall reactions in the model (default None).\n\n\nloopless\nbool\nFalse\nWhether to return only loopless solutions. This is significantlyslower. Please also refer to the notes (default False).\n\n\nfraction_of_optimum\nfloat\n1.0\nMust be &lt;= 1.0. Requires that the objective value is at least thefraction times maximum objective value. A value of 0.85 for instancemeans that the objective has to be at least at 85% percent of itsmaximum (default 1.0).\n\n\npfba_factor\nOptional\nNone\nAdd an additional constraint to the model that requires the total sumof absolute fluxes must not be larger than this value times thesmallest possible sum of absolute fluxes, i.e., by setting the valueto 1.1 the total sum of absolute fluxes must not be more than10% larger than the pFBA solution. Since the pFBA solution is theone that optimally minimizes the total flux sum, the pfba_factorshould, if set, be larger than one. Setting this value may lead tomore realistic predictions of the effective flux bounds(default None).\n\n\nprocesses\nOptional\nNone\nThe number of parallel processes to run. If not explicitly passed,will be set from the global configuration singleton (default None).\n\n\nReturns\nDataFrame\n\nA data frame with reaction identifiers as the index and two columns:- maximum: indicating the highest possible flux- minimum: indicating the lowest possible flux\n\n\n\n\nsource\n\n\npFBA_FVA_run\n\n pFBA_FVA_run (cobra_model, obj, rxnlist=[], processes=3,\n               fix_sof_for_fva=False)\n\n\nsource\n\n\nget_sum_of_fluxes\n\n get_sum_of_fluxes (model)\n\n\nsource\n\n\nrev2irrev\n\n rev2irrev (cobra_model)\n\n*Function to convert any model with reversible reactions to a copy of the same m- -odel with only irreversible reactions. ID of reverse reactions are generated by suffixing “_reverse” to the ID of the orignal reaction. args: 1) a cobra model output: a cobra model with only irreversible reactions*\n\nsource\n\n\ncheck_fba_fva_run\n\n check_fba_fva_run (fba_model, pfba_solution)\n\nThis is a test that checks if the fluxes that are returned by the fba model are different to those by the pFBA\n\nsource\n\n\nget_pfba_fva_solution\n\n get_pfba_fva_solution (fba_model, rxn_list=[],\n                        objective='Phloem_tx_overall', processes=3,\n                        fix_sof_for_fva=False)\n\nTake FBA model and solve weighted FVA on a list of reactions. Returns a dataframe with flux of all reactions and minimum and maximum if they were in the fva list",
    "crumbs": [
      "functions",
      "solving"
    ]
  },
  {
    "objectID": "2.3_flux_map_values.html",
    "href": "2.3_flux_map_values.html",
    "title": "Calculating line widths for flux maps",
    "section": "",
    "text": "For this, rather than taking values from solutions the values are inputted manually from the escher maps. It would be better from the solution dfs but I don’t fancy coding this at the moment…\nimport itertools\n\nimport numpy as np\nimport pandas as pd\nconditions_permutations = [\n    [\"blue\", \"white\", \"nops\"],\n    [\"unconstrained\", \"constrained\"],\n    [\"wt\", \"starchko\"],\n    [\"fluxes\", \"minimum\", \"maximum\"],\n]\n\nsolutions_df_columns = pd.MultiIndex.from_product(\n    conditions_permutations, names=[\"Light\", \"ATPase\", \"Starch\", \"Solution\"]\n)\nsolutions_df = pd.DataFrame(columns=solutions_df_columns)\n\nconditions_list_of_lists = [\n    [\"blue\", \"white\", \"nops\"],\n    [\"unconstrained\", \"constrained\"],\n    [\"wt\", \"starchko\"],\n]\nconditions_iterations = list(itertools.product(*conditions_list_of_lists))\n\ncols_to_drop = []\nfor conditions in conditions_iterations:\n    light_condition, atpase_condition, starch_condition = conditions\n    file_name = f\"../outputs/model_solutions/{light_condition}_{atpase_condition}_{starch_condition}.csv\"\n    try:\n        condition_df = pd.read_csv(file_name, index_col=0)\n        for col in [\"fluxes\", \"minimum\", \"maximum\"]:\n            solutions_df.loc[\n                :, (light_condition, atpase_condition, starch_condition, col)\n            ] = condition_df.loc[:, col]\n    except:\n        cols_to_drop.append(conditions)\n        print(f\"File {file_name} doesn't exist, skipping\")\n\n\nsolutions_df_unphased = solutions_df.copy()\nindex_phased = pd.MultiIndex.from_tuples(\n    [\n        (reaction[:-2], int(reaction[-1]))\n        if reaction[-1] in [\"1\", \"2\", \"3\", \"4\"]\n        else (reaction, None)\n        for reaction in solutions_df.index\n    ],\n    names=[\"Reaction\", \"Phase\"],\n)\nsolutions_df.index = index_phased\nsolutions_df = solutions_df.drop(cols_to_drop, axis=1)\n\n/tmp/ipykernel_4834/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\n/tmp/ipykernel_4834/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\n/tmp/ipykernel_4834/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\n/tmp/ipykernel_4834/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\n/tmp/ipykernel_4834/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\n/tmp/ipykernel_4834/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\n/tmp/ipykernel_4834/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\n/tmp/ipykernel_4834/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\n/tmp/ipykernel_4834/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\n/tmp/ipykernel_4834/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\n/tmp/ipykernel_4834/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\n/tmp/ipykernel_4834/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\nsolutions_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).xs(2, level=\"Phase\")\nsolutions_df\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\nATPase\nunconstrained\nconstrained\nunconstrained\nconstrained\nunconstrained\nconstrained\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEX_X_pi_t_me\n0.000000\n0.000000e+00\n0.000000e+00\n0.000000\n0.000000e+00\n0.000000\n0.000000\n0.000000e+00\n0.000000\n0.000000\n0.000000\n0.000000\n\n\nEX_X_pi_t_gc\n0.000000\n0.000000e+00\n0.000000e+00\n0.000000\n0.000000e+00\n0.000000\n0.000000\n0.000000e+00\n0.000000\n0.000000\n0.000000\n0.000000\n\n\nEX_X_CO2_t_me\n4.128357\n4.128357e+00\n4.128356e+00\n4.128355\n-5.388402e+01\n-53.884016\n-53.884016\n-5.388402e+01\n-53.884046\n-53.884046\n-53.884048\n-53.884048\n\n\nEX_X_CO2_t_gc\n0.003663\n4.036220e-03\n2.176874e-03\n0.001631\n1.156296e-03\n0.001168\n-0.001087\n-1.371060e-03\n0.002922\n0.002922\n0.001837\n0.002173\n\n\nEX_X_Mg_t_me\n0.000000\n0.000000e+00\n0.000000e+00\n0.000000\n0.000000e+00\n0.000000\n0.000000\n0.000000e+00\n0.000000\n0.000000\n0.000000\n0.000000\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nMAL_total_pseudolinker\n0.004445\n4.525811e-03\n2.358282e-03\n0.001766\n4.455754e-03\n0.004487\n0.000000\n-6.494415e-10\n0.002314\n0.002314\n0.000918\n0.002355\n\n\nFRU_total_pseudolinker\n0.000000\n0.000000e+00\n1.737018e-03\n0.006863\n0.000000e+00\n0.000000\n0.001898\n6.805909e-03\n0.000347\n0.000347\n0.004141\n0.006863\n\n\nK_total_pseudolinker\n0.013250\n1.303211e-02\n9.057052e-03\n0.005820\n1.292071e-02\n0.012970\n0.005393\n4.495170e-03\n0.009849\n0.009849\n0.006187\n0.005980\n\n\nCl_total_pseudolinker\n0.011572\n1.303197e-02\n7.424397e-03\n0.004597\n1.292071e-02\n0.012970\n0.005393\n4.495170e-03\n0.008247\n0.008247\n0.004350\n0.004350\n\n\nCIT_total_pseudolinker\n0.000000\n4.690523e-08\n-4.632768e-10\n0.000000\n-2.844564e-18\n0.000000\n0.000000\n0.000000e+00\n0.000000\n0.000000\n0.000000\n0.000000\n\n\n\n\n1774 rows × 12 columns\nreaction_dict = {\n    \"starch_to_glc\": \"RXN_1827_p_gc_2\",\n    \"starch_to_mal\": \"MALTODEG_RXN_c_gc_2\",\n    #\"starch_to_glc_mal\": \"MALTODEG_RXN_c_gc_2\",\n    \"mal_deg\": \"MALIC_NAD_RXN_m_gc_2\",\n    \"mal_v_c\": \"MAL_vc_gc_2\",\n    \"ps_to_suc\": \"SUCROSE_PHOSPHATE_SYNTHASE_RXN_c_gc_2\",\n    #\"ps_to_glc\": \"GLUC1PURIDYLTRANS_RXN_c_gc_2\",\n    #\"cit_to_mal\": \"FUMHYDR_RXN_m_gc_2\",\n    \"cit_to_mal\": \"SUCCCOASYN_RXN_m_gc_2\",\n    \"suc_c_v\": \"SUCROSE_PROTON_cv_gc_2\",\n    \"suc_v_deg\": \"RXN_1461_v_gc_2\",\n    \"suc_c_deg\": \"RXN_1461_c_gc_2\",\n    \"suc_to_fru\": \"SUCROSE_SYNTHASE_RXN_c_gc_2\",\n    \"cit_to_acon\": \"ACONITATEDEHYDR_RXN_c_gc_2\",\n    \"cit_synth\": \"CITSYN_RXN_m_gc_2\",\n    \n}\nflux_dict = {\n    \"blue\": {\n        \"unconstrained\": {\n            \"wt\": dict(reaction_dict),\n            \"starchko\": dict(reaction_dict)\n        },\n        \"constrained\": {\n            \"wt\": dict(reaction_dict),\n            \"starchko\": dict(reaction_dict)\n        }\n    },\n    \"white\": {\n        \"constrained\": {\n            \"wt\": dict(reaction_dict),\n            \"starchko\": dict(reaction_dict)\n        }\n    },\n    \"nops\": {\n        \"constrained\": {\n            \"wt\": dict(reaction_dict),\n            \"starchko\": dict(reaction_dict)\n        }\n    }\n}\nconditions_list_of_lists = [\n    [\"blue\", \"white\", \"nops\"],\n    [\"unconstrained\", \"constrained\"],\n    [\"wt\", \"starchko\"],\n]\nconditions_iterations = list(itertools.product(*conditions_list_of_lists))\nsolutions_df\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\nATPase\nunconstrained\nconstrained\nunconstrained\nconstrained\nunconstrained\nconstrained\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEX_X_pi_t_me\n0.000000\n0.000000e+00\n0.000000e+00\n0.000000\n0.000000e+00\n0.000000\n0.000000\n0.000000e+00\n0.000000\n0.000000\n0.000000\n0.000000\n\n\nEX_X_pi_t_gc\n0.000000\n0.000000e+00\n0.000000e+00\n0.000000\n0.000000e+00\n0.000000\n0.000000\n0.000000e+00\n0.000000\n0.000000\n0.000000\n0.000000\n\n\nEX_X_CO2_t_me\n4.128357\n4.128357e+00\n4.128356e+00\n4.128355\n-5.388402e+01\n-53.884016\n-53.884016\n-5.388402e+01\n-53.884046\n-53.884046\n-53.884048\n-53.884048\n\n\nEX_X_CO2_t_gc\n0.003663\n4.036220e-03\n2.176874e-03\n0.001631\n1.156296e-03\n0.001168\n-0.001087\n-1.371060e-03\n0.002922\n0.002922\n0.001837\n0.002173\n\n\nEX_X_Mg_t_me\n0.000000\n0.000000e+00\n0.000000e+00\n0.000000\n0.000000e+00\n0.000000\n0.000000\n0.000000e+00\n0.000000\n0.000000\n0.000000\n0.000000\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nMAL_total_pseudolinker\n0.004445\n4.525811e-03\n2.358282e-03\n0.001766\n4.455754e-03\n0.004487\n0.000000\n-6.494415e-10\n0.002314\n0.002314\n0.000918\n0.002355\n\n\nFRU_total_pseudolinker\n0.000000\n0.000000e+00\n1.737018e-03\n0.006863\n0.000000e+00\n0.000000\n0.001898\n6.805909e-03\n0.000347\n0.000347\n0.004141\n0.006863\n\n\nK_total_pseudolinker\n0.013250\n1.303211e-02\n9.057052e-03\n0.005820\n1.292071e-02\n0.012970\n0.005393\n4.495170e-03\n0.009849\n0.009849\n0.006187\n0.005980\n\n\nCl_total_pseudolinker\n0.011572\n1.303197e-02\n7.424397e-03\n0.004597\n1.292071e-02\n0.012970\n0.005393\n4.495170e-03\n0.008247\n0.008247\n0.004350\n0.004350\n\n\nCIT_total_pseudolinker\n0.000000\n4.690523e-08\n-4.632768e-10\n0.000000\n-2.844564e-18\n0.000000\n0.000000\n0.000000e+00\n0.000000\n0.000000\n0.000000\n0.000000\n\n\n\n\n1774 rows × 12 columns\nfor light, light_dict in flux_dict.items():\n    for atpase, atpase_dict in light_dict.items():\n        for starch, starch_dict in atpase_dict.items():\n            for shorthand, reaction_name in starch_dict.items():\n                flux = solutions_df.loc[reaction_name[:-2],(light, atpase, starch)]\n                if abs(flux) &lt; 1e-8:\n                    flux = 0\n                flux_dict[light][atpase][starch][shorthand] = flux\nsolutions_df.loc[\"GLUC1PURIDYLTRANS_RXN_c_gc\"]\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          1.190563e-04\n                      starchko    1.960967e-04\n       constrained    wt         -4.632788e-10\n                      starchko    2.462117e-12\nwhite  unconstrained  wt          4.278484e-04\n                      starchko    4.304933e-04\n       constrained    wt         -9.054699e-04\n                      starchko    1.142550e-04\nnops   unconstrained  wt         -1.310427e-04\n                      starchko   -1.310166e-04\n       constrained    wt          0.000000e+00\n                      starchko    0.000000e+00\nName: GLUC1PURIDYLTRANS_RXN_c_gc, dtype: float64\nflux_dict\n\n{'blue': {'unconstrained': {'wt': {'starch_to_glc': 0,\n    'starch_to_mal': 0,\n    'mal_deg': 0,\n    'mal_v_c': 0.0084862683952195,\n    'ps_to_suc': 0.0001190562980565,\n    'cit_to_mal': 0.0013558713124941,\n    'suc_c_v': 0,\n    'suc_v_deg': 0,\n    'suc_c_deg': 0,\n    'suc_to_fru': 0,\n    'cit_to_acon': 0.0013558713124941,\n    'cit_synth': 0.000237558821619},\n   'starchko': {'starch_to_glc': 0,\n    'starch_to_mal': 0,\n    'mal_deg': 0.0006650467732122,\n    'mal_v_c': 0.010648966832743,\n    'ps_to_suc': 0.0001960966512218,\n    'cit_to_mal': 0.0008129115147968,\n    'suc_c_v': 0,\n    'suc_v_deg': 0,\n    'suc_c_deg': 0,\n    'suc_to_fru': 0,\n    'cit_to_acon': 0,\n    'cit_synth': 0.0008130053252513}},\n  'constrained': {'wt': {'starch_to_glc': 0.0051260186331311,\n    'starch_to_mal': 0,\n    'mal_deg': 0,\n    'mal_v_c': 0.0036281277404994,\n    'ps_to_suc': 0,\n    'cit_to_mal': 0.0010884364690379,\n    'suc_c_v': 0,\n    'suc_v_deg': 0.0034740356910968,\n    'suc_c_deg': 0,\n    'suc_to_fru': 0,\n    'cit_to_acon': 0.0010884373955896,\n    'cit_synth': 0},\n   'starchko': {'starch_to_glc': 0,\n    'starch_to_mal': 0,\n    'mal_deg': 0,\n    'mal_v_c': 0.0027176388646845,\n    'ps_to_suc': 0,\n    'cit_to_mal': 0.0008152916495569,\n    'suc_c_v': 0,\n    'suc_v_deg': 0.013726072962268,\n    'suc_c_deg': 0,\n    'suc_to_fru': 0,\n    'cit_to_acon': 0.0008152916544811,\n    'cit_synth': 0}}},\n 'white': {'constrained': {'wt': {'starch_to_glc': 0.0054174157446452,\n    'starch_to_mal': 0,\n    'mal_deg': 0,\n    'mal_v_c': 0,\n    'ps_to_suc': 0.0010865638814297,\n    'cit_to_mal': 0,\n    'suc_c_v': 0,\n    'suc_v_deg': 0.0018046775864697,\n    'suc_c_deg': 0,\n    'suc_to_fru': 0.0019920337826212,\n    'cit_to_acon': 0,\n    'cit_synth': 0},\n   'starchko': {'starch_to_glc': 0,\n    'starch_to_mal': 0,\n    'mal_deg': 0,\n    'mal_v_c': 0,\n    'ps_to_suc': 0.0001142549771026,\n    'cit_to_mal': 0,\n    'suc_c_v': 0,\n    'suc_v_deg': 0.0136118179802412,\n    'suc_c_deg': 0,\n    'suc_to_fru': 0,\n    'cit_to_acon': 0,\n    'cit_synth': 0}}},\n 'nops': {'constrained': {'wt': {'starch_to_glc': 0.0025691232468596,\n    'starch_to_mal': 0.0003061234489482,\n    'mal_deg': 0,\n    'mal_v_c': 0,\n    'ps_to_suc': 0,\n    'cit_to_mal': 0.0012244940670225,\n    'suc_c_v': 0.0029878403954816,\n    'suc_v_deg': 0.0029878403954816,\n    'suc_c_deg': 0.0052938626191942,\n    'suc_to_fru': 0,\n    'cit_to_acon': 0.0012244937957926,\n    'cit_synth': 0},\n   'starchko': {'starch_to_glc': 0,\n    'starch_to_mal': 0,\n    'mal_deg': 0,\n    'mal_v_c': 0.003622478194246,\n    'ps_to_suc': 0,\n    'cit_to_mal': 0.0010867432486121,\n    'suc_c_v': 0.0061093909571672,\n    'suc_v_deg': 0.0096469801196154,\n    'suc_c_deg': 0.0040790928377284,\n    'suc_to_fru': 0,\n    'cit_to_acon': 0.0010867432486121,\n    'cit_synth': 0}}}}\nfrom sigfig import round\ndef NestedDictValues(d):\n    for v in d.values():\n        if isinstance(v, dict):\n            yield from NestedDictValues(v)\n        else:\n            yield v\nmin_flux = np.array(list(NestedDictValues(flux_dict))).min()\nmin_flux\n\n0.0\nmax_flux = np.array(list(NestedDictValues(flux_dict))).max()\nmax_flux\n\n0.013726072962268\nmax_flux/min_flux\n\n/tmp/ipykernel_4834/4031404064.py:1: RuntimeWarning: divide by zero encountered in scalar divide\n  max_flux/min_flux\n\n\ninf\nSo we have a 50-fold difference between the smallest and largest flux. 5mm in the inkscape figures that I’ve created is probably the max I can do, so 0.1 is the minimum.\nInkscape will only do widths to nearest 0.01mm I think, but allows you to input 3 numbers after the dp.\ndef convert_fluxes_to_widths_linear(flux):\n    max_width_in_inkscape = 5\n    conversion = max_width_in_inkscape/max_flux\n\n    new_flux = conversion*flux\n    new_flux_rounded = round(new_flux, 3)\n\n    return new_flux_rounded\nimport matplotlib.pyplot as plt\nx = np.arange(0.0001, 0.014, 0.0001)\ny = [convert_fluxes_to_widths_linear(flux) for flux in x]\n\nplt.plot(x, y)\nimport copy\ndef convert_flux_dict(flux_dict):\n    converted_dict = copy.deepcopy(flux_dict)\n    for light_value, light_dict in flux_dict.items():\n        for atpase_constraint, atpase_dict in light_dict.items():\n            for phenotype, phenotype_dict in atpase_dict.items():\n                for reaction, reaction_value in phenotype_dict.items():\n                    converted_dict[light_value][atpase_constraint][phenotype][reaction] = convert_fluxes_to_widths_linear(\n                        reaction_value)\n\n    return converted_dict\nconverted_dict = convert_flux_dict(flux_dict)\n\n/home/maurice/miniconda3/envs/mmon-gcm/lib/python3.9/site-packages/sigfig/sigfig.py:586: UserWarning: warning: 3 significant figures requested from number with only 1 significant figures\n  warn(\"warning: %d significant figures requested from number with only %d significant figures\" % (given['sigfigs'], len(num.map)))\n/home/maurice/miniconda3/envs/mmon-gcm/lib/python3.9/site-packages/sigfig/sigfig.py:586: UserWarning: warning: 3 significant figures requested from number with only 2 significant figures\n  warn(\"warning: %d significant figures requested from number with only %d significant figures\" % (given['sigfigs'], len(num.map)))\nfor light, light_dict in converted_dict.items():\n    for atpase, atpase_dict in light_dict.items():\n        for starch, starch_dict in atpase_dict.items():\n            print(f\"{light}_{atpase}_{starch}:\")\n            for shorthand, mm in starch_dict.items():\n                if mm &gt; 0:\n                    #print(f\"{shorthand} should be {mm}mm wide\")\n                    print(f\"{shorthand} should be {mm*175}%\")\n            print(\"\\n\")\n\nblue_unconstrained_wt:\nmal_v_c should be 540.75%\nps_to_suc should be 7.595%\ncit_to_mal should be 86.45%\ncit_to_acon should be 86.45%\ncit_synth should be 15.1375%\n\n\nblue_unconstrained_starchko:\nmal_deg should be 42.35%\nmal_v_c should be 679.0%\nps_to_suc should be 12.495000000000001%\ncit_to_mal should be 51.8%\ncit_synth should be 51.8%\n\n\nblue_constrained_wt:\nstarch_to_glc should be 327.25%\nmal_v_c should be 231.0%\ncit_to_mal should be 69.3%\nsuc_v_deg should be 222.25%\ncit_to_acon should be 69.3%\n\n\nblue_constrained_starchko:\nmal_v_c should be 173.25%\ncit_to_mal should be 51.974999999999994%\nsuc_v_deg should be 875.0%\ncit_to_acon should be 51.974999999999994%\n\n\nwhite_constrained_wt:\nstarch_to_glc should be 344.75%\nps_to_suc should be 69.3%\nsuc_v_deg should be 114.97500000000001%\nsuc_to_fru should be 127.05%\n\n\nwhite_constrained_starchko:\nps_to_suc should be 7.279999999999999%\nsuc_v_deg should be 868.0%\n\n\nnops_constrained_wt:\nstarch_to_glc should be 163.8%\nstarch_to_mal should be 19.6%\ncit_to_mal should be 78.05%\nsuc_c_v should be 190.75%\nsuc_v_deg should be 190.75%\nsuc_c_deg should be 337.75%\ncit_to_acon should be 78.05%\n\n\nnops_constrained_starchko:\nmal_v_c should be 231.0%\ncit_to_mal should be 69.3%\nsuc_c_v should be 390.25%\nsuc_v_deg should be 614.25%\nsuc_c_deg should be 260.75%\ncit_to_acon should be 69.3%",
    "crumbs": [
      "Solving and analysing specific scenarios for paper",
      "Calculating line widths for flux maps"
    ]
  },
  {
    "objectID": "2.3_flux_map_values.html#for-the-key",
    "href": "2.3_flux_map_values.html#for-the-key",
    "title": "Calculating line widths for flux maps",
    "section": "For the key:",
    "text": "For the key:\n\nimport cobra\nimport pandas as pd\nfrom mmon_gcm.supermodel import SuperModel\n\n\nparameters_df = pd.read_csv(\"../inputs/arabidopsis_parameters.csv\", index_col=0)\nfour_stage_GC_model = cobra.io.sbml.read_sbml_model(\"../models/4_stage_GC.xml\")  # read model\narabidopsis_supermodel = SuperModel(parameters_df.loc[:, \"Value\"], fba_model=four_stage_GC_model);\n\nNo objective coefficients in model. Unclear what should be optimized\n\n\n\narabidopsis_supermodel.N_gcs\n\n580000000.0\n\n\n\n0.01/arabidopsis_supermodel.N_gcs\n\n1.724137931034483e-11\n\n\n\nmoles_gc_h = 10 * 10 ** -15  # fmolesgc-1h-1\n\n\nmoles_m2_h = moles_gc_h*arabidopsis_supermodel.N_gcs  # molesh-1\n\n\nmmoles_m2_h = moles_m2_h * 10 ** 3\nmmoles_m2_h\n\n0.005800000000000001\n\n\n\nf\"{convert_fluxes_to_widths_linear(mmoles_m2_h)}mm for a flux of 10 fmoles gc-1 h-1\"\n\n'2.11mm for a flux of 10 fmoles gc-1 h-1'",
    "crumbs": [
      "Solving and analysing specific scenarios for paper",
      "Calculating line widths for flux maps"
    ]
  },
  {
    "objectID": "1.5_convert_horrer_starch_level.html",
    "href": "1.5_convert_horrer_starch_level.html",
    "title": "Starch amount estimation",
    "section": "",
    "text": "Here we use the values determined in Horrer et al. (2016) in order to determine an experimental value for the level of starch degradation we should expect to see in our model.\n\nimport pandas as pd\n\n\nstarchdf = pd.DataFrame([[\"End of night\", 41.92813034], [\"1h Light\", 12.10368844]],\n                        columns=[\"Time of day\", \"Starch content per guard cell (pg)\"])\nstarchdf = starchdf.set_index(\"Time of day\")\nstarchdf\n\n\n\n\n\n\n\n\nStarch content per guard cell (pg)\n\n\nTime of day\n\n\n\n\n\nEnd of night\n41.928130\n\n\n1h Light\n12.103688\n\n\n\n\n\n\n\nThis table is found in the supplementary files of Horrer (2016). We can calculate glucose equivalents from starch by dividing by 162 g/mol, as Horrer et al did:\n\nstarchdf[\"Glucose equivalents (pmol)\"] = starchdf[\"Starch content per guard cell (pg)\"]/162\nstarchdf\n\n\n\n\n\n\n\n\nStarch content per guard cell (pg)\nGlucose equivalents (pmol)\n\n\nTime of day\n\n\n\n\n\n\nEnd of night\n41.928130\n0.258816\n\n\n1h Light\n12.103688\n0.074714\n\n\n\n\n\n\n\nIn our model we use the glucose equivalents as a measure of starch.\nWe use a value of \\(580 \\times 10^6\\) for the number of guard cells in our model, and therefore we can calculate the expected amount of starch in the model at the two times, and the expected amount of degradation.\n\nN_gc = 290 * 10 ** 6 * 2  # number of stomata/m^2 *2 gives number of guard cells\nstarchdf[\"Starch amount (mmole/m2)\"] = starchdf[\"Glucose equivalents (pmol)\"]*N_gc*10**-9  # 10**-9 to convert to mmol\nstarchdf\n\n\n\n\n\n\n\n\nStarch content per guard cell (pg)\nGlucose equivalents (pmol)\nStarch amount (mmole/m2)\n\n\nTime of day\n\n\n\n\n\n\n\nEnd of night\n41.928130\n0.258816\n0.150113\n\n\n1h Light\n12.103688\n0.074714\n0.043334\n\n\n\n\n\n\n\n\nprint(\"Expected starch degradation amount is therefore %s fmoles/GC\" %\n      round((starchdf.at[\"End of night\", \"Glucose equivalents (pmol)\"]-starchdf.at[\"1h Light\", \"Glucose equivalents (pmol)\"])*1000, 3))\n\nExpected starch degradation amount is therefore 184.101 fmoles/GC\n\n\n\nprint(\"Expected starch degradation amount is therefore %s mmoles/m2\" %\n      round((starchdf.at[\"End of night\", \"Starch amount (mmole/m2)\"]-starchdf.at[\"1h Light\", \"Starch amount (mmole/m2)\"]), 3))\n\nExpected starch degradation amount is therefore 0.107 mmoles/m2",
    "crumbs": [
      "Building model and defining parameters",
      "Starch amount estimation"
    ]
  },
  {
    "objectID": "functions/helper.html",
    "href": "functions/helper.html",
    "title": "Helper functions",
    "section": "",
    "text": "source\n\nconvert_true_false\n\n convert_true_false (true_false)",
    "crumbs": [
      "functions",
      "Helper functions"
    ]
  },
  {
    "objectID": "functions/analysing.html",
    "href": "functions/analysing.html",
    "title": "Analysing",
    "section": "",
    "text": "source\n\nget_phase_times\n\n get_phase_times (model)\n\n\nsource\n\n\nget_phase_length\n\n get_phase_length (model, phase)\n\n\nsource\n\n\nget_phase_lengths\n\n get_phase_lengths (model)\n\n\nsource\n\n\nadjust_for_phases\n\n adjust_for_phases (series_object, model)\n\n\nsource\n\n\nget_only_gc_opening\n\n get_only_gc_opening (df)\n\n\nsource\n\n\nget_pearson\n\n get_pearson (df)\n\n\nsource\n\n\nget_solution_dfs\n\n get_solution_dfs (light, atpase_constrained, starch_knockout,\n                   outputs_path, cutoff_flux=1e-08)\n\n\nsource\n\n\ncheck_for_missing\n\n check_for_missing (reaction_list, map_path)\n\n\nsource\n\n\nget_escher_map\n\n get_escher_map (model_solution, map='inputs/map.json',\n                 json_model='models/4_stage_GC.json', **kwargs)\n\n\nsource\n\n\nget_difference_biggest_to_smallest\n\n get_difference_biggest_to_smallest (row)\n\n\nsource\n\n\nreplace_with_1_0\n\n replace_with_1_0 (value, threshold)\n\n\nsource\n\n\nget_adjacency\n\n get_adjacency (df, threshold)\n\n\nsource\n\n\nget_percentage_difference_df\n\n get_percentage_difference_df (pfba_df, averages_df)\n\n\nsource\n\n\nget_difference_map\n\n get_difference_map (percentage_difference_df, map_path, json_model)\n\n\nsource\n\n\nget_pfba_pathways_map\n\n get_pfba_pathways_map (subgraph_list, map_path, json_model)",
    "crumbs": [
      "functions",
      "Analysing"
    ]
  },
  {
    "objectID": "functions/supermodel.html",
    "href": "functions/supermodel.html",
    "title": "supermodel",
    "section": "",
    "text": "From Hills et al. (2012): &gt; $ VT = $ (16)\nwhere:\n\\(VT\\) is the total volume of the guard cell\n\\(C_{apo}\\) is the sum of osmolarity in the apoplast.\n$ q = n - m s / r $\nwhere n, m, s and r are empirical parameters\n\\(R\\) is the ideal gas constant\n\\(T\\) is temperature\n$ p = m/r $\nQT is total osmolarity of the guard cell\nThey also provide a relationship between volume and aperture:\n$ A_s = (VT - s)/r $ (17)\nAs we want a way to calculate total osmolarity from aperture we can rearrange (and just say VT is V and QT is Q) to get:\n$ V = A_s r + s $\nand:\n$ Q = (( + C_{apo} + )^2 - (C_{apo} + )^2) $\n\nsource\n\nSuperModel\n\n SuperModel (parameters, fba_model=None)\n\nThe supermodel class is a class that includes the FBA model object as well as all the parameters used to constrain it. It provides methods to constrain the FBA model\n\nsource\n\n\nSuperModel.get_volumes\n\n SuperModel.get_volumes (apertures='default', printouts=False,\n                         per_guard_cell=True)\n\nReturns a list containing the volume of the guard cells, in dm\\(^3\\), at each phase, calculated using the OnGuard equation\nHere the default is for per_guard_cell to be True, meaning that the list that is returned is a volume per individual cell, however setting this to false will return the colume of guard cell within the 1m\\(^2\\) of leaf being simulated.\n\nsource\n\n\nSuperModel.get_osmolarities\n\n SuperModel.get_osmolarities (apertures='default', equation='onguard',\n                              printouts=False)\n\nCalculates the osmolarities at each phase of the model using the equation specified, default is onguard. Adds these as an attribute to the SuperModel\n\nsource\n\n\nSuperModel.constrain_osmolarity\n\n SuperModel.constrain_osmolarity (apertures='default', printouts=False,\n                                  osequation='onguard')\n\nThis method constrains the fba_model of the supermodel using osmolarities calculated using SuperModel.get_osmolarities\n\nsource\n\n\nSuperModel.get_prop_gc\n\n SuperModel.get_prop_gc (printouts=False)\n\nThis method returns the proportion of the volume of the leaf that is guard cells\n\nsource\n\n\nSuperModel.get_photons\n\n SuperModel.get_photons (PPFD, printouts=False)\n\nThis method constrains photon influx into the model in accordance with the equation outlined in the documentation\n\nsource\n\n\nSuperModel.constrain_photons\n\n SuperModel.constrain_photons (PPFD, printouts=False)\n\nThis method constrains the fba_model of the supermodel using osmolarities calculated using SuperModel.get_osmolarities\n\nsource\n\n\nSuperModel.add_maintenance\n\n SuperModel.add_maintenance (me=True, gc=True, gc_scaling=1,\n                             printouts=False,\n                             gc_ratio=4.427086760474383e-05)\n\nThis function constrains the maintenance reactions in the model relative to the input of photons into the model. Maintenance value based on Toepfer et al., (2020)\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nme\nbool\nTrue\n\n\n\ngc\nbool\nTrue\n\n\n\ngc_scaling\nint\n1\n\n\n\nprintouts\nbool\nFalse\n\n\n\ngc_ratio\nfloat\n4.427086760474383e-05\ngc_ratio from 2.0_compute_maintenance"
  },
  {
    "objectID": "functions/alternativemodes.html",
    "href": "functions/alternativemodes.html",
    "title": "alternativemodes",
    "section": "",
    "text": "source\n\nget_real_reaction_ids\n\n get_real_reaction_ids (model)\n\nThis function takes a COBRApy model object and returns a list of reaction ids without phase tags that are considered to be ‘real’, excluding reactions that combine others, constraint pseudoreactions, boundary reactions.\n\nsource\n\n\nsolve_model_with_weightings\n\n solve_model_with_weightings (weightings, model, temp_results_path)",
    "crumbs": [
      "functions",
      "alternativemodes"
    ]
  },
  {
    "objectID": "3.1_generate_constraints_df.html",
    "href": "3.1_generate_constraints_df.html",
    "title": "Constraint scan",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nimport pyDOE\nfrom mmon_gcm.constraintscan import generate_constraints_df",
    "crumbs": [
      "Running constraints scan",
      "Constraint scan"
    ]
  },
  {
    "objectID": "3.1_generate_constraints_df.html#generate-constraintscandf",
    "href": "3.1_generate_constraints_df.html#generate-constraintscandf",
    "title": "Constraint scan",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nimport pyDOE\nfrom mmon_gcm.constraintscan import generate_constraints_df",
    "crumbs": [
      "Running constraints scan",
      "Constraint scan"
    ]
  },
  {
    "objectID": "3.1_generate_constraints_df.html#define-parameter-bounds",
    "href": "3.1_generate_constraints_df.html#define-parameter-bounds",
    "title": "Constraint scan",
    "section": "Define parameter bounds",
    "text": "Define parameter bounds\n\nparameter_bounds = {}",
    "crumbs": [
      "Running constraints scan",
      "Constraint scan"
    ]
  },
  {
    "objectID": "3.1_generate_constraints_df.html#photons",
    "href": "3.1_generate_constraints_df.html#photons",
    "title": "Constraint scan",
    "section": "Photons",
    "text": "Photons\nWe can go 10% above and below the value for photon reflectance and transmission from Zhu et al (2010)\n\nparameter_bounds[\"P_abs\"] = [0.9*0.9, 0.9*1.1, r\"Dimensionless\",\n                             \"90% of Zhu, Long, and Ort (2010)\", \"110% of Zhu, Long, and Ort (2010)\"]  # proportion of photons absorbed by the leaf\n\nThe lower bound is the default we’ve used from Wuyts et al (2021), for a higher value we’ll use one from Ramonell 2001.\n\nparameter_bounds[\"T_l\"] = [0.017 * 10 ** -2, 0.024 * 10 ** -2, r\"m\", \"Wuyts et al. (2010)\", \"Ramonell et al. (2001)\"]\n\nThe are of the leaf being simulated is fixed at 1m\\(^2\\)\n\nparameter_bounds[\"A_l\"] = [1, 1, r\"m$^2$\", \"Fixed\", \"Fixed\"]\n\nFor the lower bound we can use the average volume of an Arabidopsis guard cell as the midpoint of the values given in table 1 of Jezek and Blatt (2017). For the upper bound we can use the volume given in Hills et al (2012).\n\nj_b_upper = 0.65\nj_b_lower = 0.3\nV_gc_ind = (j_b_lower+j_b_upper)/2  # pL\nV_gc_ind = V_gc_ind * 10**-12  # dm3\nparameter_bounds[\"V_gc_ind\"] = [V_gc_ind, 4.1E-12, r\"dm$^3$\", \"Jezek and Blatt (2017)\", \"Hills et al. (2012)\"]\n\nThe photosynthetic efficient of guard cells compared to the mesophyll was taken from Lawson (2003).\n\nIn leaves of all species the values of photosynthetic efficiency for guard cells were either indistinguishable from or only slightly lower (minimum of 79%) than those of the underlying, spongy mesophyll cells.\n\nWe’ll use these as the bounds.\n\nparameter_bounds[\"FqFm\"] = [0.79, 0.9, r\"Dimensionless\", \"Lawson (2003)\", \"Lawson (2003)\"]\n\nFujiwara et al (2019) provide a range of values for number of chloroplasts in mesophyll and guard cells, we can take the upper gc and lower me and vice versa to get the upper and lower bound for the ratios, respectively.\n\nupper_gc = 5.5\nlower_gc = 3.5\n\nupper_me = 100\nlower_me = 30\n\nrch_lower_bound = lower_gc/upper_me\nrch_upper_bound = upper_gc/lower_me\n\nparameter_bounds[\"R_ch\"] = [rch_lower_bound, rch_upper_bound, r\"Dimensionless\",\n                            \"Fujiwara, Sanjaya, and Itoh (2019)\", \"Fujiwara, Sanjaya, and Itoh (2019)\"]\n\nAdded in Nov 2023: The proportion of chloroplast volumes between guard cells and mesophyll cells for Arabidopsis Col-0 based on Chl a data from Knoblauch et al. (2023) Table S1. We can the standard error values to calculate the range with min/max being 2 SE away.\n\nchl_vol_me = 88.24\nchl_vol_se_me = 1.58\nmin_chl_vol_me = chl_vol_me - 2 * chl_vol_se_me\nmax_chl_vol_me = chl_vol_me + 2 * chl_vol_se_me\n\nchl_vol_gc = 17.69\nchl_vol_se_gc = 0.21\nmin_chl_vol_gc = chl_vol_gc - 2 * chl_vol_se_gc\nmax_chl_vol_gc = chl_vol_gc + 2 * chl_vol_se_gc\n\nmin_R_ch_vol = min_chl_vol_gc / max_chl_vol_me\nmax_R_ch_vol = max_chl_vol_gc / min_chl_vol_me\n\n#modelparameters[\"R_ch_vol\"] = [R_ch_vol, r\"Dimensionless\", \"Knoblauch et al. (2023)\"]\n\nparameter_bounds[\"R_ch_vol\"] = [min_R_ch_vol, max_R_ch_vol, r\"Dimensionless\",\n                            \"Knoblauch et al. (2023)\", \"Knoblauch et al. (2023)\"]\n\nFor the lower bound Ramonell et al. (2001) provide a percentage of the leaf that is space at atmospheric pressure in Table 1.For the upper bound we take the proportion of the leaf that is air from Earles et al 2018 for Guzmania zahnii from Table 2.\n\nparameter_bounds[\"L_air\"] = [0.185, 0.37, r\"Dimensionless\", \"Ramonell et al. (2001)\", \"Earles et al. (2018)\"]\n\nWillmer and Fricker (1996) provide a lower bound of 0.1 and Ramonell et al. (2001) an upper bound of 0.24 for the proportion of the leaf that is epidermis.\n\nparameter_bounds[\"L_epidermis\"] = [0.1, 0.24, r\"Dimensionless\", \"Willmer and Fricker (1996)\", \"Ramonell et al. (2001)\"]",
    "crumbs": [
      "Running constraints scan",
      "Constraint scan"
    ]
  },
  {
    "objectID": "3.1_generate_constraints_df.html#osmolarity",
    "href": "3.1_generate_constraints_df.html#osmolarity",
    "title": "Constraint scan",
    "section": "Osmolarity",
    "text": "Osmolarity\nWang et al. (2017) use a value of 0.751 to be the proportion of the Guard Cell that is vacuole, Andrés et al. (2014) quote a value of 90% from an old MacRobbie paper.\n\nparameter_bounds[\"Vac_frac\"] = [0.751, 0.9, r\"Dimensionless\", \"Wang et al. (2017)\", \"Andrés et al. (2014) \"]\n\nA reasonable range for temperature seems to be 10C to 25C, this covers a wide range:\n\nparameter_bounds[\"T\"] = [273.15+10, 273.15+25, \"K\", \"10C\", \"25C\"]\n\nIdeal gas constant, from NIST, (reference Tiesinga2019). This is constant, so won’t change in the model\n\nR = 8.205*10**(-5)  # m3atmK-1mol-1\nR = R*10**3  # dm3atmK-1mol-1\nparameter_bounds[\"R\"] = [\n    R, R, r\"dm$^3$$\\cdot$atm$\\cdot$K$^{-1}$$\\cdot$mol$^{-1}$\", \"Tiesinga et al. (2019)\", \"Tiesinga et al. (2019)\"]\n\nThe density of guard cells per m\\(^2\\) of leaf was taken by multiplying the density of stomata from Papanatsiou et al (2016) by two. This only takes into account the abaxial surface of the leaf, so for the upper bound, we’ll double this again. For the lower bound, we’ll use a value for Commelina from Willmer and Fricker (1996).\n\nparameter_bounds[\"N_gcs\"] = [172 * 10 ** 6, 290 * 10 ** 6 * 2.0 * 2,\n                             r\"GCs$\\cdot$m$^{-2}$\", \"Willmer and Fricker (1996)\", \"Papanatsiou, Amtmann, and Blatt (2016)\"]\n\nThe following parameters required for osmolarity are based taking values from an older OnGuard paper (Wang et al. (2012)) and the newer, updated model (Wang et al 2017).\n\nparameter_bounds[\"n\"] = [1.5, 2.5, \"atm\", \"Wang et al. (2012)\", \"Wang et al. (2017)\"]\nparameter_bounds[\"m\"] = [0.8, 1, r\"atm$\\cdot$µm$^{-1}$\", \"Wang et al. (2017)\", \"Wang et al. (2012)\"]\nparameter_bounds[\"r\"] = [0.05 * 10 ** (-12), 0.08 * 10 ** (-12),\n                         r\"dm$^3$ µm$^{-1}$\", \"Wang et al. (2017)\", \"Wang et al. (2012)\"]\nparameter_bounds[\"s\"] = [0.1 * 10 ** (-12), 0.3 * 10 ** (-12), r\"dm$^3$\", \"Wang et al. (2012)\", \"Wang et al. (2017)\"]\n\nFor the apoplastic concentration, we use the value from the OnGuard model as the lower bound, and use a combination of values which have been collated by Roelfsema and Hedrich (2002) from Lohaus et al. (2001) for the upper bound:\n\napoplastic_concs_wang_2017 = {\n    \"K\": 10,\n    \"Ca\": 1,\n    \"Cl\": 12,\n    \"Suc\": 0.01,\n    \"MH2\": 3.2*10**(-6),\n    \"MH\": 7.9*10**(-5),\n    \"M\": 0.00999,\n}\napoplastic_conc_wang_2017 = sum(apoplastic_concs_wang_2017.values())\n\n\napoplastic_concs_roelfsema_2002 = {\n    \"K\": 13,\n    \"Ca\": 0.7,\n    \"Cl\": 11,\n    \"Suc\": 1.6,\n    \"Mal\": 0.7,\n    \"Amino Acids\": 9.6,\n    \"Hexoses\": 0.7,\n}\napoplastic_conc_roelfsema_2002 = sum(apoplastic_concs_roelfsema_2002.values())\n\n\nparameter_bounds[\"C_apo\"] = [apoplastic_conc_wang_2017*10 **\n                             (-3), apoplastic_conc_roelfsema_2002*10**(-3), r\"mol$\\cdot$dm$^{-3}$\", \"Wang et al. (2017)\", \"Roelfsema and Hedrich (2002)\"]",
    "crumbs": [
      "Running constraints scan",
      "Constraint scan"
    ]
  },
  {
    "objectID": "3.1_generate_constraints_df.html#apertures",
    "href": "3.1_generate_constraints_df.html#apertures",
    "title": "Constraint scan",
    "section": "Apertures",
    "text": "Apertures\nFor the closed aperture, we’ll use 1 µm value from Jezek and Blatt (2017) as a lower bound and 4 µm from Wang et al. (2017) as an upper bound.\n\nparameter_bounds[\"A_closed\"] = [1, 4, r\"µm\", \"Jezek and Blatt (2017)\", \"Wang et al. (2017)\"]\n\nFor the open aperture, we’ll use the 2.75 µm from Horrer et al. (2016) as the lower bound and 12 µm from Wang et al. (2017) as the upper bound.\n\nparameter_bounds[\"A_open\"] = [2.75, 12, r\"µm\", \"Horrer et al. (2016)\", \"Wang et al. (2017)\"]\n\nFor the proportion of photons that are absorbed by the leaf we can just go for 10% above and below the value that is reported by",
    "crumbs": [
      "Running constraints scan",
      "Constraint scan"
    ]
  },
  {
    "objectID": "3.1_generate_constraints_df.html#atpase",
    "href": "3.1_generate_constraints_df.html#atpase",
    "title": "Constraint scan",
    "section": "ATPase",
    "text": "ATPase\nWe’ll go between constraining the ATPase to 0 and the level of ATPase that Flütsch et al. (2020) measured (17 fmoles\\(\\cdot\\)GC\\(^{-1}\\cdot\\)h\\(^{-1}\\)).\n\nparameter_bounds[\"ATPase\"] = [\n    0, 17, r\"fmoles$\\cdot$GC$^{-1}\\cdot$h$^{-1}$\", \"Supplementary\", \"Flütsch et al. (2020)\"]",
    "crumbs": [
      "Running constraints scan",
      "Constraint scan"
    ]
  },
  {
    "objectID": "3.2_run_constraint_scan.html",
    "href": "3.2_run_constraint_scan.html",
    "title": "Running Constraint Scan",
    "section": "",
    "text": "Remember to run for both BLUE and WHITE light  \nThis notebook can either be run as a notebook, or using nbdev a python script is produced that can be run in the command line for easier running on e.g. a cluster. It is a notebook in the nbs directory and exported as a .py file in the mmon-gcm library.\n\n# This cell isn't exported to the .py file, so define here if running in notebook rather than as .py on e.g.a cluster\n# This is also where to change whether the light is blue or white if you want to run in the notebook\n\nsys.argv = [\n    \"script_name\",\n    \"../outputs/constraint_scan/constraint_scan_results_blue.csv\",\n    \"../models/4_stage_GC.json\",\n    \"../outputs/constraint_scan/constraints_df.csv\",\n    \"blue\",\n    \"6\",\n]\n\nIf you are running from notebook you’ll want to comment out the next cell! It’s here so that running nbdev tests doesn’t take too long, as they test running the entire notebook. It won’t be exported so running as a script will be fine\n\n#test == True\n#constraints = constraints.iloc[:10]  # so tests don't take too long\n\n\nconstraints.head()\n\n\n\n\n\n\n\n\nP_abs\nT_l\nA_l\nV_gc_ind\nFqFm\nR_ch\nR_ch_vol\nL_air\nL_epidermis\nVac_frac\n...\nR\nN_gcs\nn\nm\nr\ns\nC_apo\nA_closed\nA_open\nATPase\n\n\n\n\n0\n0.815093\n0.000194\n1.0\n2.262641e-12\n0.809297\n0.179970\n0.191527\n0.240879\n0.214860\n0.858645\n...\n0.08205\n4.484392e+08\n1.933548\n0.992641\n7.886553e-14\n1.678654e-13\n0.033679\n2.321339\n11.318979\n10.816668\n\n\n1\n0.923180\n0.000190\n1.0\n1.250880e-12\n0.889162\n0.093534\n0.195869\n0.337197\n0.196606\n0.837767\n...\n0.08205\n1.064044e+09\n2.025073\n0.946228\n5.400144e-14\n1.664063e-13\n0.023524\n2.500598\n9.754649\n0.549826\n\n\n2\n0.830507\n0.000220\n1.0\n5.035745e-13\n0.821060\n0.167889\n0.204824\n0.331556\n0.205674\n0.816618\n...\n0.08205\n5.758277e+08\n2.141889\n0.972835\n6.579620e-14\n2.457118e-13\n0.034062\n2.802180\n3.338120\n7.823891\n\n\n3\n0.880998\n0.000192\n1.0\n8.629192e-13\n0.866582\n0.051244\n0.204472\n0.309538\n0.169957\n0.813726\n...\n0.08205\n3.851195e+08\n2.077401\n0.940848\n5.747590e-14\n1.515328e-13\n0.029770\n3.399462\n9.936390\n12.606738\n\n\n4\n0.915597\n0.000220\n1.0\n7.391447e-13\n0.846358\n0.059969\n0.193449\n0.352066\n0.238671\n0.810491\n...\n0.08205\n1.046353e+09\n2.396012\n0.817798\n7.654181e-14\n1.652973e-13\n0.028420\n3.305233\n7.650706\n10.970481\n\n\n\n\n5 rows × 21 columns\n\n\n\n\nprint(f\"Number of constraints = {len(constraints.index)}\")\n\nNumber of constraints = 968\n\n\n\nBreakdown into batches of constraints\n\nif os.path.exists(f\"{results_path[:-4]}_{num_batches}.csv\"):\n    directory_path = os.path.dirname(results_path)\n    # Get a list of all files in the directory\n    all_files = os.listdir(directory_path)\n    # Filter the list to include\n    csv_files = [file for file in all_files if file.startswith(f\"{results_path[:-4]}_\".rsplit(\"/\")[-1])]\n\n    # Sort the list using a lambda function and underscore as separator\n    csv_files = sorted(csv_files, key=lambda x: int(x.rsplit('_')[-1].split('.')[0]))\n\n    # Initialize an empty list to store DataFrames\n    dfs = []\n\n    # Read each CSV file into a DataFrame and append it to the list\n    for csv_file in csv_files:\n        file_path = os.path.join(directory_path, csv_file)\n        df = pd.read_csv(file_path)\n        dfs.append(df)\n\n    # Concatenate all DataFrames into a single DataFrame\n    combined_df = pd.concat(dfs, ignore_index=True)\n\n    # Remove 'Unnamed: 0' column\n    if 'Unnamed: 0' in combined_df.columns:\n        combined_df = combined_df.drop('Unnamed: 0', axis=1)\n        \n    # Print or use the combined DataFrame as needed\n    combined_df.to_csv(results_path)\n    \n    for csv_file in list(csv_files):\n        file_path = os.path.join(directory_path, csv_file)\n        if os.path.exists(file_path):\n            os.remove(file_path)\n\n\ncombined_df.shape\n\n(968, 7101)",
    "crumbs": [
      "Running constraints scan",
      "Running Constraint Scan"
    ]
  },
  {
    "objectID": "1.4_maintenance_calculation.html",
    "href": "1.4_maintenance_calculation.html",
    "title": "Calculating guard cell maintenance value",
    "section": "",
    "text": "Tan and Cheung (2020) included a maintenance value in their model:\nThey set constraints to force sucrose to be accumulated:\nThey then used the fact that sucrose was accumulated to set the maintenance to be 20% of total CO2 influx:\nSo their maintenance value was 2.87 mmol \\(\\cdot\\) ATP \\(\\cdot\\) gDW\\(^{−1}\\) \\(\\cdot\\) h\\(^{−1}\\), which we can use in our model. However, our model is in units of mmol \\(\\cdot\\) m\\(^{-2}\\)leaf \\(\\cdot\\) h\\(^{-1}\\), so it needs to be converted."
  },
  {
    "objectID": "1.4_maintenance_calculation.html#converting-mmol-gdw-1-to-mmol-m-2",
    "href": "1.4_maintenance_calculation.html#converting-mmol-gdw-1-to-mmol-m-2",
    "title": "Calculating guard cell maintenance value",
    "section": "Converting mmol ⋅ gDW-1 to mmol ⋅ m-2",
    "text": "Converting mmol ⋅ gDW-1 to mmol ⋅ m-2\nTschoep et al (2009) found, and then Arnold 2014 referenced, that the dry weight content of Arabidopsis during optimal growth was 0.088:\n\n\n\nimage.png\n\n\nWe assume that this relationship holds for guard cells as well.\nWe want to know the concentration of ATP, and as it will only dissolve in the water component of the leaf, not the dry, we need to first convert from mmol \\(\\cdot\\) gDW\\(^{−1}\\) to mmol \\(\\cdot\\) gFW\\(^{−1}\\).\n\\[ 0.088 = \\frac{gDW}{gFW} \\]\nWe assume that the fresh weight of the leaf is the gDW + water:\n\\[ 0.088 = \\frac{gDW}{gDW + gWater} \\]\nAnd using the density of water 1g=1cm3:\n\\[ 0.088 = \\frac{gDW}{gDW + cm^3leaf} \\]\n\\[ 0.088 \\cdot (gDW + cm^3leaf) = gDW\\]\n\\[ 0.088 \\cdot gDW + 0.088 \\cdot cm^3leaf = gDW\\]\n\\[ 0.088 \\cdot cm^3leaf = 0.912 \\cdot gDW\\]\n\\[ cm^3leaf = 10.36 \\cdot gDW\\]\nSo for every gram of dry weight we have 10.36 cm\\(^3\\) of water that the ATP can be dissolved in, or 0.010 dm\\(^3\\).\n2.87 mmol \\(\\cdot\\) ATP \\(\\cdot\\) gDW\\(^{−1}\\) \\(\\cdot\\) h\\(^{-1}\\) \\(\\times\\) \\(\\frac{1}{0.01}\\) gDW \\(\\cdot\\) dm\\(^{-3}\\) = 287 mmoles \\(\\cdot\\) dm\\(^{-3}\\) \\(\\cdot\\) ATP \\(\\cdot\\) h\\(^{-1}\\)\nThis then needs to be converted to mmoles \\(\\cdot\\) ATP \\(\\cdot\\) m\\(^{-2}\\)leaf \\(\\cdot\\) h\\(^{-1}\\) by multiplying by the volume of guard cells per m2leaf (this will vary depending on parameters chosen, but here is one example as a sanity check):\n\nimport pandas as pd\n\n\nparameters_df = pd.read_csv(\"../inputs/arabidopsis_parameters.csv\", index_col=0)\nparameters_df\n\n\n\n\n\n\n\n\nValue\nUnits\nSource\n\n\n\n\nP_abs\n9.000000e-01\nDimensionless\nZhu, Long, and Ort (2010)\n\n\nT_l\n1.700000e-04\nm\nWuyts et al. (2010)\n\n\nA_l\n1.000000e+00\nm$^2$\nFixed\n\n\nV_gc_ind\n4.750000e-13\ndm$^3$\nJezek and Blatt (2017)\n\n\nFqFm\n9.000000e-01\nDimensionless\nLawson (2003)\n\n\nR_ch\n6.923077e-02\nDimensionless\nFujiwara, Sanjaya, and Itoh (2019)\n\n\nR_ch_vol\n2.004760e-01\nDimensionless\nKnoblauch et al. (2023)\n\n\nL_air\n3.700000e-01\nDimensionless\nEarles et al. (2018)\n\n\nL_epidermis\n1.500000e-01\nDimensionless\nWuyts et al. (2010)\n\n\nVac_frac\n7.510000e-01\nDimensionless\nWang et al. (2017)\n\n\nT\n2.961500e+02\nK\nHorrer et al. (2016)\n\n\nR\n8.205000e-02\ndm$^3$$\\cdot$atm$\\cdot$K$^{-1}$$\\cdot$mol$^{-1}$\nTiesinga et al. (2019)\n\n\nN_gcs\n5.800000e+08\nGCs$\\cdot$m$^{-2}$\nPapanatsiou, Amtmann, and Blatt (2016)\n\n\nn\n2.500000e+00\natm\nWang et al. (2017)\n\n\nm\n8.000000e-01\natm$\\cdot$µm$^{-1}$\nWang et al. (2017)\n\n\nr\n5.000000e-14\ndm$^3$ µm$^{-1}$\nWang et al. (2017)\n\n\ns\n3.000000e-13\ndm$^3$\nWang et al. (2017)\n\n\nC_apo\n2.302007e-02\nmol$\\cdot$dm$^{-3}$\nWang et al. (2017)\n\n\nA_closed\n1.600000e+00\nµm\nHorrer et al. (2016)\n\n\nA_open\n2.750000e+00\nµm\nHorrer et al. (2016)\n\n\n\n\n\n\n\nSo we multiply the volume of an individual guard cell by the number of guard cells per m2 of leaf to give us the volume of guard cells per m2 leaf\n\ndm3_gc_per_m2leaf = parameters_df.loc[\"V_gc_ind\", \"Value\"] * parameters_df.loc[\"N_gcs\", \"Value\"]\ndm3_gc_per_m2leaf\n\n0.0002755\n\n\nWe then multiply this by 287, the number calculated above:\n\ndm3_gc_per_m2leaf * 287\n\n0.07906849999999999\n\n\nSo we need to add maintenance of 0.079 mmoles \\(\\cdot\\) ATP \\(\\cdot\\) m\\(^{-2}\\)leaf \\(\\cdot\\) h\\(^{-1}\\) to the model. Currently during the opening phase of the model we have an ATP production rate from the mitochondrial ATP synthase of 0.003, so using this equation maintenance would be over 20X the amount of ATP production needed for guard cell opening, which seems unrealistic.\nMaintenance in the mesophyll portion of the model is 5.17 mmoles \\(\\cdot\\) ATP \\(\\cdot\\) m\\(^{-2}\\)leaf \\(\\cdot\\) h\\(^{-1}\\). Let’s see what happens if we correct this to guard cell by size, as another possible way to do this:\nThe volume of 1m2 of leaf (in dm3):\n\nvolume_of_leaf_m2 = (parameters_df.loc[\"T_l\", \"Value\"] * 1) * 1000\nvolume_of_leaf_m2\n\n0.17\n\n\nThe proportion of the leaf that is air:\n\nparameters_df.loc[\"L_air\", \"Value\"]\n\n0.37\n\n\nThe volume of leaf that is not air:\n\nvolume_of_leaf_not_air = volume_of_leaf_m2 * (1 - parameters_df.loc[\"L_air\", \"Value\"])\nvolume_of_leaf_not_air\n\n0.10710000000000001\n\n\nThe volume of the leaf that is not air and is not guard cells (ie. mesophyll):\n\nvolume_of_mesophyll = volume_of_leaf_not_air - dm3_gc_per_m2leaf\nvolume_of_mesophyll\n\n0.10682450000000002\n\n\nSo the proportion of cells modelled that are guard cells:\n\nproportion_of_leaf_gc = dm3_gc_per_m2leaf / volume_of_mesophyll\nproportion_of_leaf_gc\n\n0.002578996391277281\n\n\nAnd if we multiply this by the maintenance in the mesophyll:\n\n5.17 * proportion_of_leaf_gc\n\n0.013333411342903542\n\n\nGiving us 0.01 mmoles \\(\\cdot\\) ATP \\(\\cdot\\) m\\(^{-2}\\)leaf \\(\\cdot\\) h\\(^{-1}\\), interestingly still approximately 3x the energy required for opening, and not too far from the values that Maurice used."
  },
  {
    "objectID": "1.1_buildingmodel.html",
    "href": "1.1_buildingmodel.html",
    "title": "Building model",
    "section": "",
    "text": "import cobra\nimport pandas as pd\nfrom mmon_gcm.buildingediting import (\n    add_linkers,\n    add_metabolite,\n    add_metabolites_to_reaction_multi,\n    add_reaction,\n    check_number_of_models,\n    set_bounds_multi,\n    split_model,\n)\n\n\nmodel = cobra.io.read_sbml_model(\"../models/PlantCoreMetabolism_v1_2_2_3fbc.xml\")\n\nNo objective coefficients in model. Unclear what should be optimized",
    "crumbs": [
      "Building model and defining parameters",
      "Building model"
    ]
  },
  {
    "objectID": "1.1_buildingmodel.html#set-up",
    "href": "1.1_buildingmodel.html#set-up",
    "title": "Building model",
    "section": "",
    "text": "import cobra\nimport pandas as pd\nfrom mmon_gcm.buildingediting import (\n    add_linkers,\n    add_metabolite,\n    add_metabolites_to_reaction_multi,\n    add_reaction,\n    check_number_of_models,\n    set_bounds_multi,\n    split_model,\n)\n\n\nmodel = cobra.io.read_sbml_model(\"../models/PlantCoreMetabolism_v1_2_2_3fbc.xml\")\n\nNo objective coefficients in model. Unclear what should be optimized",
    "crumbs": [
      "Building model and defining parameters",
      "Building model"
    ]
  },
  {
    "objectID": "1.1_buildingmodel.html#add-charge-to-model",
    "href": "1.1_buildingmodel.html#add-charge-to-model",
    "title": "Building model",
    "section": "Add charge to model",
    "text": "Add charge to model\n\ncharges = pd.read_csv(\"../inputs/charges.csv\")\ncharges.set_index(\"Metabolite\")\nfor index, row in charges.iterrows():\n    model.metabolites.get_by_id(row[1]).charge = row[0]",
    "crumbs": [
      "Building model and defining parameters",
      "Building model"
    ]
  },
  {
    "objectID": "1.1_buildingmodel.html#changes-to-both-cells",
    "href": "1.1_buildingmodel.html#changes-to-both-cells",
    "title": "Building model",
    "section": "Changes to Both Cells",
    "text": "Changes to Both Cells\n\nK+\n\nfor metabolite in model.metabolites:\n    if \"KI_\" in metabolite.id:\n        metabolite.id = metabolite.id[:1] + metabolite.id[-2:]\n        metabolite.name = metabolite.id\nmodel.reactions.K_rev_vc.name = \"K_cv\"\nmodel.reactions.K_rev_vc.id = \"K_cv\"\nmodel.metabolites.K_e.charge = 1\n\n\n\nCl-\n\nadd_metabolite(model, \"Cl_e\", \"e\", multi=False)\nadd_metabolite(model, \"Cl_c\", \"c\", multi=False)\nadd_metabolite(model, \"Cl_v\", \"v\", multi=False)\nmodel.metabolites.Cl_e.notes = {\"INCHI\": [\"InChI=1S/ClH/h1H/p-1\"], \"SMILES\": [\"Cl-\"]}\nmodel.metabolites.Cl_e.charge = -1\nmodel.metabolites.Cl_c.notes = model.metabolites.Cl_e.notes.copy()\nmodel.metabolites.Cl_c.charge = -1\nmodel.metabolites.Cl_v.notes = model.metabolites.Cl_e.notes.copy()\nmodel.metabolites.Cl_v.charge = -1\n\nadd_reaction(model, \"Cl_tx\", multi=False)\nmodel.reactions.Cl_tx.add_metabolites({\"Cl_e\": 1})\nmodel.reactions.Cl_tx.lower_bound = -1000\n\n\n\nCIT\n\nfor metabolite in model.metabolites:\n    if \"CIT_\" in metabolite.id and \"aCIT\" not in metabolite.id:\n        metabolite.charge = -3\n\n\nmodel.metabolites.aCIT_v.charge = -2\n\n\n\nMAL\n\nfor metabolite in model.metabolites:\n    if \"MAL_\" in metabolite.id and \"aMAL\" not in metabolite.id:\n        metabolite.charge = -2\n\n\nmodel.metabolites.aMAL_v.charge = -1\n\n\nadd_metabolite(model, \"MAL_e\", \"e\", multi=False)\nadd_metabolite(model, \"aMAL_e\", \"e\", multi=False)\n\n\n        \n\n\n\nMetabolite identifier\naMAL_e\n\n\nName\naMAL_e\n\n\nMemory address\n0x7e0687d07f40\n\n\nFormula\nNone\n\n\nCompartment\ne\n\n\nIn 0 reaction(s)\n\n\n\n\n\n\n\nmodel.metabolites.MAL_e.notes = model.metabolites.MAL_v.notes.copy()\nmodel.metabolites.aMAL_e.notes = model.metabolites.aMAL_v.notes.copy()\nmodel.metabolites.MAL_e.charge = model.metabolites.MAL_v.charge\nmodel.metabolites.aMAL_e.charge = model.metabolites.aMAL_v.charge\n\n\nadd_reaction(model, \"MAL_tx\", multi=False)\nmodel.reactions.MAL_tx.add_metabolites(\n    {\n        \"MAL_e\": 0.7,\n        \"aMAL_e\": 0.3,\n    }\n)\nmodel.reactions.MAL_tx.lower_bound = -1000\n\n\n\nMAL Anion Export Channel (Cl/Mal)\n\nadd_reaction(model, \"MAL_ce\", multi=False)\nmodel.reactions.MAL_ce.name = \"MAL R/S-Type Anion Channel\"\nmodel.reactions.MAL_ce.add_metabolites(\n    {\"MAL_c\": -1, \"MAL_e\": 0.7, \"aMAL_e\": 0.3, \"PROTON_e\": -0.3}\n)\n\n\n\nNADPHox\n\n# change names to make consistent with the rest of the model\nfor reaction in model.reactions:\n    if \"NADPHox\" in reaction.id:\n        reaction.name = reaction.id[:7] + \"_\" + reaction.id[7:]\n        reaction.id = reaction.id[:7] + \"_\" + reaction.id[7:]\n\n\n\nRemove reactions only active in germinating seeds\nArabidopsis Peroxisomal Citrate Synthase Is Required for Fatty Acid Respiration and Seed Germination Itsara Pracharoenwattana, Johanna E. Cornah, Steven M. Smith The Plant Cell Jul 2005, 17 (7) 2037-2048; DOI: 10.1105/tpc.105.031856\nCoordinate expression of transcriptionally regulated isocitrate lyase and malate synthase genes in Brassica napus L. L Comai, R A Dietrich, D J Maslyar, C S Baden, J J Harada The Plant Cell Mar 1989, 1 (3) 293-300; DOI: 10.1105/tpc.1.3.293\n\nmodel.reactions.MALSYN_RXN_x.bounds = 0, 0\nmodel.reactions.CITSYN_RXN_x.bounds = 0, 0\n\n\n\nSetting disproportionating enzyme irreversible in the direction of maltose degradation\nCritchley, J.H., Zeeman, S.C., Takaha, T., Smith, A.M. and Smith, S.M. (2001), A critical role for disproportionating enzyme in starch breakdown is revealed by a knock-out mutation in Arabidopsis. The Plant Journal, 26: 89-100. https://doi.org/10.1046/j.1365-313x.2001.01012.x\n\nmodel.reactions.MALTODEG_RXN_c.bounds = 0, cobra.Configuration().upper_bound",
    "crumbs": [
      "Building model and defining parameters",
      "Building model"
    ]
  },
  {
    "objectID": "1.1_buildingmodel.html#split-model-into-mesophyll-me-and-guard-cell-gc",
    "href": "1.1_buildingmodel.html#split-model-into-mesophyll-me-and-guard-cell-gc",
    "title": "Building model",
    "section": "Split Model into Mesophyll (me) and Guard Cell (gc)",
    "text": "Split Model into Mesophyll (me) and Guard Cell (gc)\nUsesplit_model to duplicate the model and add the tags “me” and “gc” to each one\n\nsplit_model(model, [\"me\", \"gc\"])\n\n/home/maurice/miniconda3/envs/mmon-gcm/lib/python3.9/site-packages/cobra/core/group.py:147: UserWarning: need to pass in a list\n  warn(\"need to pass in a list\")",
    "crumbs": [
      "Building model and defining parameters",
      "Building model"
    ]
  },
  {
    "objectID": "1.1_buildingmodel.html#adding-gc-specific-transporters",
    "href": "1.1_buildingmodel.html#adding-gc-specific-transporters",
    "title": "Building model",
    "section": "Adding GC-specific transporters",
    "text": "Adding GC-specific transporters\n\nmodel.reactions.PROTON_ATPase_c_gc\n\n\n        \n\n\n\n\n\n\n\nReaction identifier\nPROTON_ATPase_c_gc\n\n\nName\nPROTON_ATPase_c_gc\n\n\nMemory address\n0x7e0686ad35b0\n\n\nStoichiometry\n0.65 ATP_c_gc + 0.45 PROTON_c_gc + WATER_c_gc + 0.35 aATP_c_gc --&gt; 0.5 ADP_c_gc + PROTON_e_gc + 0.7 Pi_c_gc + 0.5 aADP_c_gc + 0.3 aPi_c_gc\n0.65 ATP_gc + 0.45 PROTON_gc + WATER_gc + 0.35 aATP[c]_gc --&gt; 0.5 ADP_gc + PROTON_gc + 0.7 Pi[c]_gc + 0.5 aADP[c]_gc + 0.3 aPi[c]_gc\n\n\nGPR\n\n\n\nLower bound\n0.0\n\n\nUpper bound\n1000.0\n\n\n\n\n        \n\n\n\nInward-rectifying K+ Channel\n\nRemove dependence for protons\n\nmodel.reactions.K_ec_gc.name = \"Apoplastic Inward-Rectifying K+ Channel\"\nmodel.reactions.K_ec_gc.add_metabolites({\"PROTON_e_gc\": 1, \"PROTON_c_gc\": -1})\n\n\nmodel.reactions.K_ec_gc\n\n\n        \n\n\n\n\n\n\n\nReaction identifier\nK_ec_gc\n\n\nName\nApoplastic Inward-Rectifying K+ Channel\n\n\nMemory address\n0x7e0686b12bb0\n\n\nStoichiometry\nK_e_gc --&gt; K_c_gc\nK_e_gc --&gt; K_c_gc\n\n\nGPR\n\n\n\nLower bound\n0.0\n\n\nUpper bound\n1000.0\n\n\n\n\n        \n\n\n\n\n\nOutward-rectifying K+ Channel\n\nadd_reaction(model, \"K_ce_gc\", multi=False)\nmodel.reactions.K_ce_gc.name = \"Apoplastic Outward-Rectifying K+ Channel\"\nmodel.reactions.K_ce_gc.add_metabolites({\"K_c_gc\": -1, \"K_e_gc\": 1})\n\n\n\nH+-coupled K+ Symport\n\nadd_reaction(model, \"K_PROTON_ec_gc\", multi=False)\nmodel.reactions.K_PROTON_ec_gc.name = \"H+-Coupled K+ Symport\"\nmodel.reactions.K_PROTON_ec_gc.add_metabolites(\n    {\"K_e_gc\": -1, \"K_c_gc\": 1, \"PROTON_e_gc\": -1, \"PROTON_c_gc\": 1}\n)\nmodel.reactions.K_PROTON_ec_gc\n\n\n        \n\n\n\n\n\n\n\nReaction identifier\nK_PROTON_ec_gc\n\n\nName\nH+-Coupled K+ Symport\n\n\nMemory address\n0x7e0687d43760\n\n\nStoichiometry\nK_e_gc + PROTON_e_gc --&gt; K_c_gc + PROTON_c_gc\nK_e_gc + PROTON_gc --&gt; K_c_gc + PROTON_gc\n\n\nGPR\n\n\n\nLower bound\n0.0\n\n\nUpper bound\n1000.0\n\n\n\n\n        \n\n\n\n\nCl- Import Channel\n\nadd_reaction(model, \"Cl_ec_gc\", multi=False)\nmodel.reactions.Cl_ec_gc.name = \"Cl Apoplastic Import Channel\"\nmodel.reactions.Cl_ec_gc.add_metabolites({\"Cl_e_gc\": -1, \"Cl_c_gc\": 1})\n\n\n\nH+-Coupled Cl- Symport\n\nadd_reaction(model, \"Cl_PROTON_ec_gc\", multi=False)\nmodel.reactions.Cl_PROTON_ec_gc.name = \"H+-Coupled Cl- Symport\"\nmodel.reactions.Cl_PROTON_ec_gc.add_metabolites(\n    {\"Cl_e_gc\": -2, \"Cl_c_gc\": 2, \"PROTON_e_gc\": -1, \"PROTON_c_gc\": 1}\n)\n\n\n\nCl- Anion Export Channel (Cl/Mal)\n\nadd_reaction(model, \"Cl_ce_gc\", multi=False)\nmodel.reactions.Cl_ce_gc.name = \"Cl- R/S-Type Anion Channel\"\nmodel.reactions.Cl_ce_gc.add_metabolites({\"Cl_c_gc\": -1, \"Cl_e_gc\": 1})\n\n\n\nATPase Malate Importer\n\nadd_reaction(model, \"MAL_ATPASE_ec_gc\", multi=False)\nmodel.reactions.MAL_ATPASE_ec_gc.add_metabolites(\n    {\n        \"MAL_e_gc\": -0.7,\n        \"aMAL_e_gc\": -0.3,\n        \"MAL_c_gc\": 1,\n        \"ATP_c_gc\": -0.65,\n        \"aATP_c_gc\": -0.35,\n        \"WATER_c_gc\": -1,\n        \"ADP_c_gc\": 1,\n        \"Pi_c_gc\": 0.7,\n        \"aPi_c_gc\": 0.3,\n        \"PROTON_c_gc\": +0.85,\n    }\n)\n\n\n\nGlucose Apoplastic Symport Channel\n\nmodel.reactions.GLC_ec_gc.id = \"GLC_PROTON_ec_gc\"\nmodel.reactions.GLC_PROTON_ec_gc.name = \"H+-Coupled Glucose Symport\"\nmodel.reactions.GLC_PROTON_ec_gc\n\n\n        \n\n\n\n\n\n\n\nReaction identifier\nGLC_PROTON_ec_gc\n\n\nName\nH+-Coupled Glucose Symport\n\n\nMemory address\n0x7e0686c9c8e0\n\n\nStoichiometry\nGLC_e_gc + PROTON_e_gc --&gt; GLC_c_gc + PROTON_c_gc\nGLC_gc + PROTON_gc --&gt; GLC_gc + PROTON_gc\n\n\nGPR\n\n\n\nLower bound\n0.0\n\n\nUpper bound\n1000.0\n\n\n\n\n        \n\n\n\n\nGlucose Exporter\n\nadd_reaction(model, \"GLC_ce_gc\", multi=False)\nmodel.reactions.GLC_ce_gc.name = \"Glucose Apoplastic Exporter\"\nmodel.reactions.GLC_ce_gc.add_metabolites({\"GLC_c_gc\": -1, \"GLC_e_gc\": 1})\n\n\n\nSucrose Apoplastic Symport Channel\n\n# Renaming Sucrose_tx\nmodel.reactions.Sucrose_tx_gc.id = \"SUCROSE_tx_gc\"\n\n\nmodel.reactions.Sucrose_ec_gc.id = \"SUCROSE_PROTON_ec_gc\"\nmodel.reactions.SUCROSE_PROTON_ec_gc.name = \"H+-Coupled Sucrose Symport\"\nmodel.reactions.SUCROSE_PROTON_ec_gc.upper_bound = 1000\nmodel.reactions.SUCROSE_PROTON_ec_gc\n\n\n        \n\n\n\n\n\n\n\nReaction identifier\nSUCROSE_PROTON_ec_gc\n\n\nName\nH+-Coupled Sucrose Symport\n\n\nMemory address\n0x7e06869a2cd0\n\n\nStoichiometry\nPROTON_e_gc + SUCROSE_e_gc --&gt; PROTON_c_gc + SUCROSE_c_gc\nPROTON_gc + SUCROSE_gc --&gt; PROTON_gc + SUCROSE_gc\n\n\nGPR\n\n\n\nLower bound\n0.0\n\n\nUpper bound\n1000\n\n\n\n\n        \n\n\n\n\nSucrose Exporter\n\nadd_reaction(model, \"SUCROSE_ce_gc\", multi=False)\nmodel.reactions.SUCROSE_ce_gc.name = \"Sucrose Apoplastic Exporter\"\nmodel.reactions.SUCROSE_ce_gc.add_metabolites({\"SUCROSE_c_gc\": -1, \"SUCROSE_e_gc\": 1})\n\n\n\nFructose Apoplastic Symport Channel\n\nadd_metabolite(model, \"FRU_e_gc\", \"e\", multi=False)\nmodel.metabolites.FRU_e_gc.notes = model.metabolites.FRU_c_gc.notes.copy()\nmodel.metabolites.FRU_e_gc.charge = 0\n\n\nadd_reaction(model, \"FRU_PROTON_ec_gc\", multi=False)\nmodel.reactions.FRU_PROTON_ec_gc.name = \"H+-Coupled Fructose Symport\"\nmodel.reactions.FRU_PROTON_ec_gc.add_metabolites(\n    {\"FRU_e_gc\": -1, \"FRU_c_gc\": 1, \"PROTON_e_gc\": -1, \"PROTON_c_gc\": 1}\n)\n\n\n\nFructose Exporter\n\nadd_reaction(model, \"FRU_ce_gc\", multi=False)\nmodel.reactions.FRU_ce_gc.name = \"Fructose Apoplastic Exporter\"\nmodel.reactions.FRU_ce_gc.add_metabolites({\"FRU_c_gc\": -1, \"FRU_e_gc\": 1})\n\n\n\nCell-Wall Invertase\n\nadd_reaction(model, \"cwINV_gc\", multi=False)\n\n\n        \n\n\n\n\n\n\n\nReaction identifier\ncwINV_gc\n\n\nName\ncwINV_gc\n\n\nMemory address\n0x7e0687d43a60\n\n\nStoichiometry\n--&gt;\n--&gt;\n\n\nGPR\n\n\n\nLower bound\n0.0\n\n\nUpper bound\n1000.0\n\n\n\n\n        \n\n\n\nmodel.reactions.cwINV_gc.add_metabolites(\n    {\"SUCROSE_e_gc\": -1, \"WATER_e_gc\": -1, \"FRU_e_gc\": 1, \"GLC_e_gc\": 1}\n)\n\n\n\nK+ Import Channel\n(TPK-Type and Fast-vacuolar)\n\nmodel.reactions.K_cv_gc.name = \"K+ Tonoplastic Import Channel\"\nmodel.reactions.K_cv_gc\n\n\n        \n\n\n\n\n\n\n\nReaction identifier\nK_cv_gc\n\n\nName\nK+ Tonoplastic Import Channel\n\n\nMemory address\n0x7e0686aa7dc0\n\n\nStoichiometry\nK_c_gc + PROTON_v_gc --&gt; K_v_gc + PROTON_c_gc\nK_c_gc + PROTON_gc --&gt; K_v_gc + PROTON_gc\n\n\nGPR\n\n\n\nLower bound\n0.0\n\n\nUpper bound\n1000.0\n\n\n\n\n        \n\n\n\n\nNHX-Type K+/H+ Antiport\n\nadd_reaction(model, \"K_PROTON_cv_gc\", multi=False)\nmodel.reactions.K_PROTON_cv_gc.name = \"NHX-Type K+/H+ Antiport\"\nmodel.reactions.K_PROTON_cv_gc.add_metabolites(\n    {\"K_c_gc\": -1, \"K_v_gc\": 1, \"PROTON_v_gc\": -1, \"PROTON_c_gc\": 1}\n)\n\n\n\nK+ Tonoplastic Export Channel\nSlow Vacuolar Channel\n\nadd_reaction(model, \"K_vc_gc\", multi=False)\nmodel.reactions.K_vc_gc.name = \"K+ Tonoplastic Export Slow Vacuolar Channel\"\nmodel.reactions.K_vc_gc.add_metabolites({\"K_v_gc\": -1, \"K_c_gc\": 1})\n\n\n\nCLC-Type Cl-/H+ Antiport Vacoular Import Channel\n\nadd_reaction(model, \"Cl_PROTON_cv_gc\", multi=False)\nmodel.reactions.Cl_PROTON_cv_gc.name = (\n    \"CLC-Type Cl-/H+ Antiport Vacoular Import Channel\"\n)\nmodel.reactions.Cl_PROTON_cv_gc.add_metabolites(\n    {\n        \"Cl_v_gc\": 1,\n        \"Cl_c_gc\": -1,\n        \"PROTON_c_gc\": 2,\n        \"PROTON_v_gc\": -2,\n    }\n)\n\n\n\nVCL Cl- Vacuolar Import Channel\n\nadd_reaction(model, \"Cl_cv_gc\", multi=False)\nmodel.reactions.Cl_cv_gc.name = \"VCL Cl- Vacuolar Import Channel\"\nmodel.reactions.Cl_cv_gc.add_metabolites({\"Cl_c_gc\": -1, \"Cl_v_gc\": 1})\n\n\n\nCl- Vacuolar Export Channel\n\nmodel.reactions.Cl_cv_gc.lower_bound = -1000\n\n\n\nMAL Import Channel (AMLT)\n\nmodel.reactions.MAL_PROTON_vc_gc.id = \"MAL_cv_gc\"\nmodel.reactions.MAL_cv_gc.name = \"VMAL-type MAL Channel (Import)\"\nmodel.reactions.MAL_cv_gc\n\n\n        \n\n\n\n\n\n\n\nReaction identifier\nMAL_cv_gc\n\n\nName\nVMAL-type MAL Channel (Import)\n\n\nMemory address\n0x7e0686ab9190\n\n\nStoichiometry\nMAL_c_gc + 0.3 PROTON_v_gc --&gt; 0.7 MAL_v_gc + 0.3 aMAL_v_gc\nMAL_gc + 0.3 PROTON_gc --&gt; 0.7 MAL_gc + 0.3 aMAL[v]_gc\n\n\nGPR\n\n\n\nLower bound\n0.0\n\n\nUpper bound\n1000.0\n\n\n\n\n        \n\n\n\n\nMAL Export Channel (AMLT)\n\nadd_reaction(model, \"MAL_vc_gc\", multi=False)\nmodel.reactions.MAL_vc_gc.name = \"VMAL-type MAL Channel (Export)\"\nmodel.reactions.MAL_vc_gc.add_metabolites(\n    {\n        \"MAL_v_gc\": -0.7,\n        \"aMAL_v_gc\": -0.3,\n        \"MAL_c_gc\": 1,\n        \"PROTON_c_gc\": 0.3,\n    }\n)\n\n\n\nMAL Export Symporter\nAlready in Model\n\nmodel.reactions.MAL_PROTON_rev_vc_gc.name = \"MAL Export Symporter\"\nmodel.reactions.MAL_PROTON_rev_vc_gc\n\n\n        \n\n\n\n\n\n\n\nReaction identifier\nMAL_PROTON_rev_vc_gc\n\n\nName\nMAL Export Symporter\n\n\nMemory address\n0x7e068696ca90\n\n\nStoichiometry\n0.7 MAL_v_gc + 1.7 PROTON_v_gc + 0.3 aMAL_v_gc --&gt; MAL_c_gc + 2.0 PROTON_c_gc\n0.7 MAL_gc + 1.7 PROTON_gc + 0.3 aMAL[v]_gc --&gt; MAL_gc + 2.0 PROTON_gc\n\n\nGPR\n\n\n\nLower bound\n0.0\n\n\nUpper bound\n1000.0\n\n\n\n\n        \n\n\n\n\nFructose Import Antiporter\nPreviously in the model\n\nmodel.reactions.FRU_PROTON_rev_vc_gc.id = \"FRU_PROTON_rev_cv_gc\"\nmodel.reactions.FRU_PROTON_rev_cv_gc.name = \"Fructose Tonoplastic Import Antiporter\"\nmodel.reactions.FRU_PROTON_rev_cv_gc\n\n\n        \n\n\n\n\n\n\n\nReaction identifier\nFRU_PROTON_rev_cv_gc\n\n\nName\nFructose Tonoplastic Import Antiporter\n\n\nMemory address\n0x7e0686ea8fa0\n\n\nStoichiometry\nFRU_c_gc + PROTON_v_gc --&gt; FRU_v_gc + PROTON_c_gc\nFRU[c]_gc + PROTON_gc --&gt; FRU[v]_gc + PROTON_gc\n\n\nGPR\n\n\n\nLower bound\n0.0\n\n\nUpper bound\n1000.0\n\n\n\n\n        \n\n\n\n\nFructose Import Symporter\n\nadd_reaction(model, \"FRU_PROTON_cv_gc\", multi=False)\nmodel.reactions.FRU_PROTON_cv_gc.name = \"Fructose Tonoplastic Import Symporter\"\nmodel.reactions.FRU_PROTON_cv_gc.add_metabolites(\n    {\"PROTON_c_gc\": -1, \"PROTON_v_gc\": 1, \"FRU_c_gc\": -1, \"FRU_v_gc\": 1}\n)\n\n\n\nFructose Export\n\nmodel.reactions.FRU_vc_gc\n\n\n        \n\n\n\n\n\n\n\nReaction identifier\nFRU_vc_gc\n\n\nName\nFRU_vc_gc\n\n\nMemory address\n0x7e0686b245e0\n\n\nStoichiometry\nFRU_v_gc --&gt; FRU_c_gc\nFRU[v]_gc --&gt; FRU[c]_gc\n\n\nGPR\n\n\n\nLower bound\n0.0\n\n\nUpper bound\n1000.0\n\n\n\n\n        \n\n\n\n\nGlucose Tonoplastic Antiporter\n\nmodel.reactions.GLC_PROTON_rev_vc_gc.id = \"GLC_PROTON_rev_cv_gc\"\nmodel.reactions.GLC_PROTON_rev_cv_gc.name = \"Glucose Tonoplastic Import Antiporter\"\nmodel.reactions.GLC_PROTON_rev_cv_gc\n\n\n        \n\n\n\n\n\n\n\nReaction identifier\nGLC_PROTON_rev_cv_gc\n\n\nName\nGlucose Tonoplastic Import Antiporter\n\n\nMemory address\n0x7e0686d1de50\n\n\nStoichiometry\nGLC_c_gc + PROTON_v_gc --&gt; GLC_v_gc + PROTON_c_gc\nGLC_gc + PROTON_gc --&gt; GLC_gc + PROTON_gc\n\n\nGPR\n\n\n\nLower bound\n0.0\n\n\nUpper bound\n1000.0\n\n\n\n\n        \n\n\n\n\nGlucose Tonoplastic Symporter\n\nadd_reaction(model, \"GLC_PROTON_cv_gc\", multi=False)\nmodel.reactions.GLC_PROTON_cv_gc.name = \"Glucose Tonoplastic Import Symporter\"\nmodel.reactions.GLC_PROTON_cv_gc.add_metabolites(\n    {\"PROTON_c_gc\": -1, \"PROTON_v_gc\": 1, \"GLC_c_gc\": -1, \"GLC_v_gc\": 1}\n)\n\n\n\nGlucose Export Channel\n\nmodel.reactions.GLC_vc_gc\n\n\n        \n\n\n\n\n\n\n\nReaction identifier\nGLC_vc_gc\n\n\nName\nGLC_vc_gc\n\n\nMemory address\n0x7e0686a9df70\n\n\nStoichiometry\nGLC_v_gc --&gt; GLC_c_gc\nGLC_gc --&gt; GLC_gc\n\n\nGPR\n\n\n\nLower bound\n0.0\n\n\nUpper bound\n1000.0\n\n\n\n\n        \n\n\n\n\nSucrose Tonoplastic Importer\n\nadd_reaction(model, \"SUCROSE_cv_gc\", multi=False)\nmodel.reactions.SUCROSE_cv_gc.name = \"Sucrose Free Tonoplastic Import\"\nmodel.reactions.SUCROSE_cv_gc.add_metabolites(\n    {\n        \"SUCROSE_c_gc\": -1,\n        \"SUCROSE_v_gc\": 1,\n    }\n)\n\n\n\nSucrose Tonoplastic Import Antiporter\nAlready in the model\n\nmodel.reactions.SUCROSE_PROTON_vc_gc.id = \"SUCROSE_PROTON_cv_gc\"\nmodel.reactions.SUCROSE_PROTON_cv_gc.name = \"Sucrose Tonoplastic Import Antiporter\"\nmodel.reactions.SUCROSE_PROTON_cv_gc\n\n\n        \n\n\n\n\n\n\n\nReaction identifier\nSUCROSE_PROTON_cv_gc\n\n\nName\nSucrose Tonoplastic Import Antiporter\n\n\nMemory address\n0x7e0686f28d30\n\n\nStoichiometry\nPROTON_v_gc + SUCROSE_c_gc --&gt; PROTON_c_gc + SUCROSE_v_gc\nPROTON_gc + SUCROSE_gc --&gt; PROTON_gc + SUCROSE_gc\n\n\nGPR\n\n\n\nLower bound\n0.0\n\n\nUpper bound\n1000.0\n\n\n\n\n        \n\n\n\n\nSucrose Tonoplastic Export Symporter\n\nmodel.reactions.SUCROSE_PROTON_rev_vc_gc.id = \"SUCROSE_PROTON_vc_gc\"\nmodel.reactions.SUCROSE_PROTON_vc_gc.name = \"Sucrose Tonoplastic Export Symporter\"\n\n\n\nTonoplastic PPase\n\nmodel.reactions.PROTON_PPi_rev_vc_gc\n\n\n        \n\n\n\n\n\n\n\nReaction identifier\nPROTON_PPi_rev_vc_gc\n\n\nName\nPROTON_PPi_rev_vc_gc\n\n\nMemory address\n0x7e06869e5670\n\n\nStoichiometry\n0.65 PPI_c_gc + 0.25 PROTON_c_gc + WATER_c_gc + 0.35 aPPI_c_gc --&gt; PROTON_v_gc + 1.4 Pi_c_gc + 0.6 aPi_c_gc\n0.65 PPI_gc + 0.25 PROTON_gc + WATER_gc + 0.35 aPPI[c]_gc --&gt; PROTON_gc + 1.4 Pi[c]_gc + 0.6 aPi[c]_gc\n\n\nGPR\n\n\n\nLower bound\n0.0\n\n\nUpper bound\n1000.0\n\n\n\n\n        \n\n\n\n\nTonoplastic H+ ATPase\n\nmodel.reactions.PROTONATP_rev_vc_gc\n\n\n        \n\n\n\n\n\n\n\nReaction identifier\nPROTONATP_rev_vc_gc\n\n\nName\nPROTONATP_rev_vc_gc\n\n\nMemory address\n0x7e0686febb20\n\n\nStoichiometry\n0.65 ATP_c_gc + 1.45 PROTON_c_gc + WATER_c_gc + 0.35 aATP_c_gc --&gt; 0.5 ADP_c_gc + 2.0 PROTON_v_gc + 0.7 Pi_c_gc + 0.5 aADP_c_gc + 0.3 aPi_c_gc\n0.65 ATP_gc + 1.45 PROTON_gc + WATER_gc + 0.35 aATP[c]_gc --&gt; 0.5 ADP_gc + 2.0 PROTON_gc + 0.7 Pi[c]_gc + 0.5 aADP[c]_gc + 0.3 aPi[c]_gc\n\n\nGPR\n\n\n\nLower bound\n0.0\n\n\nUpper bound\n1000.0\n\n\n\n\n        \n\n\n\nadd_reaction(model, \"PROTON_ec_gc\", multi=False)\nmodel.reactions.PROTON_ec_gc.name = \"Plasma membrane proton leakage\"\nmodel.reactions.PROTON_ec_gc.add_metabolites(\n    {\n        \"PROTON_e_gc\": -1,\n        \"PROTON_c_gc\": 1,\n    }\n)\n\n\nadd_reaction(model, \"PROTON_vc_gc\", multi=False)\nmodel.reactions.PROTON_vc_gc.name = \"Tonoplast membrane proton leakage\"\nmodel.reactions.PROTON_vc_gc.add_metabolites(\n    {\n        \"PROTON_v_gc\": -1,\n        \"PROTON_c_gc\": 1,\n    }\n)",
    "crumbs": [
      "Building model and defining parameters",
      "Building model"
    ]
  },
  {
    "objectID": "1.1_buildingmodel.html#constrain-channels-in-guard-cell",
    "href": "1.1_buildingmodel.html#constrain-channels-in-guard-cell",
    "title": "Building model",
    "section": "Constrain Channels in Guard Cell",
    "text": "Constrain Channels in Guard Cell\n\nfor channel in [\"Cl_ec\", \"K_cv\", \"FRU_PROTON_cv\", \"GLC_PROTON_cv\", \"SUCROSE_cv\"]:\n    model.reactions.get_by_id(channel + \"_gc\").bounds = 0, 0",
    "crumbs": [
      "Building model and defining parameters",
      "Building model"
    ]
  },
  {
    "objectID": "1.1_buildingmodel.html#adding-apoplast-and-exchanges",
    "href": "1.1_buildingmodel.html#adding-apoplast-and-exchanges",
    "title": "Building model",
    "section": "Adding apoplast and exchanges",
    "text": "Adding apoplast and exchanges\nIn this section we add an apoplastic compartment and set the influx of osmolites to be from this compartment rather than as boundary reactions.\n\nRemoving tx_me\nHere we remove all the boundary reactions from the mesophyll cell except for: - Maintenance reactions - Photon influx - Phloem output - Gas transfer (O2 and CO2)\n\ntx_me = []\nfor reaction in model.reactions:\n    if \"_tx_me\" in reaction.id:\n        tx_me.append(reaction)\nkeep = [\n    \"Photon_tx_me\",\n    \"Phloem_output_tx_me\",\n    \"NADPHox_c_tx_me\",\n    \"NADPHox_m_tx_me\",\n    \"NADPHox_p_tx_me\",\n    \"O2_tx_me\",\n    \"CO2_tx_me\",\n    \"ATPase_tx_me\",\n]\nfor reaction in keep:\n    tx_me.remove(model.reactions.get_by_id(reaction))\n\nmodel.remove_reactions(tx_me)\n\n\n\nRemoving tx_gc\nSee above for removing tx_me reactions, only difference is in this case we don’t have a phloem output reaction\n\ntx_gc = []\nfor reaction in model.reactions:\n    if \"_tx_gc\" in reaction.id:\n        tx_gc.append(reaction)\nkeep = [\n    \"Photon_tx_gc\",\n    \"NADPHox_c_tx_gc\",\n    \"NADPHox_m_tx_gc\",\n    \"NADPHox_p_tx_gc\",\n    \"O2_tx_gc\",\n    \"CO2_tx_gc\",\n    \"ATPase_tx_gc\",\n]\nfor reaction in keep:\n    tx_gc.remove(model.reactions.get_by_id(reaction))\n\nmodel.remove_reactions(tx_gc)\n\n\n\nAdding tx to apo and adding exchanges\nNow for the species that are present in the extracellular compartment of the guard cell we: - Add the species to the apoplastic compartment with the tag “a” - Add a boundary reaction into this compartment for the species - Add a transfer reaction to allow them to be transferred between the guard cell extracellular compartment and the apoplast - Add a transfer reaction to allow them to be transferred between the mesophyll cell extracellular compartment and the apoplast\nAll these actions are free and reversible, as we are assuming that really the extracellular space and the apoplast are all the same. The apoplastic compartment just gives us an easy way to track influx/efflux of metabolites as well as osmolite levels in that compartment.\n\n# fructose wasn't in the extracellular compartment of mesophyll before\nadd_metabolite(model, \"FRU_e_me\", \"e\", multi=False)\n\n\n        \n\n\n\nMetabolite identifier\nFRU_e_me\n\n\nName\nFRU_e_me\n\n\nMemory address\n0x7e0687e36250\n\n\nFormula\nNone\n\n\nCompartment\ne\n\n\nIn 0 reaction(s)\n\n\n\n\n\n\n\nadd_reaction(model, \"Sucrose_ce_me\", multi=False)  # sucrose transport out of the mesophyll cell wasn't allowed before\nmodel.reactions.Sucrose_ce_me.add_metabolites({\"SUCROSE_c_me\": -1, \"SUCROSE_e_me\": 1})\n\n\nea_reactions = []\nfor metabolite in model.metabolites:\n    if \"_e_gc\" in metabolite.id:\n        ea_reactions.append(metabolite)\n\nprint(ea_reactions)\n\n# don't want these to be transferred in the apoplast, they already have individual boundary reactions in each cell type\nremove = [\"Photon\", \"OXYGEN_MOLECULE\", \"CARBON_DIOXIDE\", \"PROTON\"]\nfor name in remove:\n    ea_reactions.remove(model.metabolites.get_by_id(name + \"_e_gc\"))\n\nfor metabolite in ea_reactions:\n\n    add_metabolite(model, metabolite.id[:-4] + \"a\", \"a\", multi=False)\n    model.metabolites.get_by_id(metabolite.id[:-4] + \"a\").charge = metabolite.charge\n    model.metabolites.get_by_id(metabolite.id[:-4] + \"a\").notes = metabolite.notes\n\n    add_reaction(model, metabolite.id[:-4] + \"a_tx\", multi=False)\n    model.reactions.get_by_id(metabolite.id[:-4] + \"a_tx\").add_metabolites(\n        {metabolite.id[:-4] + \"a\": 1}\n    )\n    model.reactions.get_by_id(metabolite.id[:-4] + \"a_tx\").lower_bound = -1000\n\n    add_reaction(model, metabolite.id[:-4] + \"ae_gc\", multi=False)\n    model.reactions.get_by_id(metabolite.id[:-4] + \"ae_gc\").add_metabolites(\n        {metabolite: 1, metabolite.id[:-4] + \"a\": -1}\n    )\n    model.reactions.get_by_id(metabolite.id[:-4] + \"ae_gc\").lower_bound = -1000\n\n    add_reaction(model, metabolite.id[:-4] + \"ae_me\", multi=False)\n    model.reactions.get_by_id(metabolite.id[:-4] + \"ae_me\").add_metabolites(\n        {metabolite.id[:-4] + \"e_me\": 1, metabolite.id[:-4] + \"a\": -1}\n    )\n    model.reactions.get_by_id(metabolite.id[:-4] + \"ae_me\").lower_bound = -1000\n\n[&lt;Metabolite NITRATE_e_gc at 0x7e06872203a0&gt;, &lt;Metabolite SUCROSE_e_gc at 0x7e0687220b20&gt;, &lt;Metabolite WATER_e_gc at 0x7e0687236be0&gt;, &lt;Metabolite MGII_e_gc at 0x7e06871c25e0&gt;, &lt;Metabolite GLC_e_gc at 0x7e06871d5b20&gt;, &lt;Metabolite PROTON_e_gc at 0x7e06871dc8e0&gt;, &lt;Metabolite CARBON_DIOXIDE_e_gc at 0x7e068719acd0&gt;, &lt;Metabolite CAII_e_gc at 0x7e06871bd910&gt;, &lt;Metabolite Pi_e_gc at 0x7e06871bdf10&gt;, &lt;Metabolite SULFATE_e_gc at 0x7e0687154250&gt;, &lt;Metabolite OXYGEN_MOLECULE_e_gc at 0x7e0687154fd0&gt;, &lt;Metabolite Photon_e_gc at 0x7e0687119280&gt;, &lt;Metabolite K_e_gc at 0x7e0687125a00&gt;, &lt;Metabolite AMMONIUM_e_gc at 0x7e06870e0580&gt;, &lt;Metabolite Cl_e_gc at 0x7e06870f8b80&gt;, &lt;Metabolite MAL_e_gc at 0x7e06870f8dc0&gt;, &lt;Metabolite aMAL_e_gc at 0x7e06870f8e80&gt;, &lt;Metabolite FRU_e_gc at 0x7e0687c417f0&gt;]\n\n\n\n\nList of all boundary reactions:\n\nfor reaction in model.reactions:\n    if \"_tx\" in reaction.id:\n        print(reaction.id)\n\nPhoton_tx_me\nPhoton_tx_gc\nNADPHox_m_tx_me\nNADPHox_m_tx_gc\nCO2_tx_me\nCO2_tx_gc\nO2_tx_me\nO2_tx_gc\nPhloem_output_tx_me\nNADPHox_c_tx_me\nNADPHox_c_tx_gc\nATPase_tx_me\nATPase_tx_gc\nNADPHox_p_tx_me\nNADPHox_p_tx_gc\nNITRATE_a_tx\nSUCROSE_a_tx\nWATER_a_tx\nMGII_a_tx\nGLC_a_tx\nCAII_a_tx\nPi_a_tx\nSULFATE_a_tx\nK_a_tx\nAMMONIUM_a_tx\nCl_a_tx\nMAL_a_tx\naMAL_a_tx\nFRU_a_tx",
    "crumbs": [
      "Building model and defining parameters",
      "Building model"
    ]
  },
  {
    "objectID": "1.1_buildingmodel.html#constrain-free-exchange-and-starch-breakdown",
    "href": "1.1_buildingmodel.html#constrain-free-exchange-and-starch-breakdown",
    "title": "Building model",
    "section": "Constrain free exchange and starch breakdown",
    "text": "Constrain free exchange and starch breakdown\nPrevent: - Free import into the apoplast of energy-carrying metabolites like Glucose, malate, sucrose, fructose. - Free exchange of protons. - Alpha-glucosidase starch degradation pathway as it isn’t used\n\nfor reaction in [\n    \"GLC_a_tx\",\n    \"MAL_a_tx\",\n    \"SUCROSE_a_tx\",\n    \"FRU_a_tx\",\n    \"RXN_1826_p_me\",\n    \"RXN_1826_p_gc\",\n    \"MALTODEXGLUCOSID_RXN_p_me\",\n    \"MALTODEXGLUCOSID_RXN_p_gc\",\n]:\n    model.reactions.get_by_id(reaction).bounds = (0, 0)",
    "crumbs": [
      "Building model and defining parameters",
      "Building model"
    ]
  },
  {
    "objectID": "1.1_buildingmodel.html#quadruple-model-into-4-phases",
    "href": "1.1_buildingmodel.html#quadruple-model-into-4-phases",
    "title": "Building model",
    "section": "Quadruple model into 4 phases",
    "text": "Quadruple model into 4 phases\n\nsplit_model(model, range(1, 5))",
    "crumbs": [
      "Building model and defining parameters",
      "Building model"
    ]
  },
  {
    "objectID": "1.1_buildingmodel.html#add-linker-reactions-with-pseudometabolites-osmolarity-and-charge",
    "href": "1.1_buildingmodel.html#add-linker-reactions-with-pseudometabolites-osmolarity-and-charge",
    "title": "Building model",
    "section": "Add Linker Reactions With Pseudometabolites (Osmolarity and Charge)",
    "text": "Add Linker Reactions With Pseudometabolites (Osmolarity and Charge)\nSet phase times here\n\ncompartments = [\"c\", \"v\", \"p\", \"a\"]\n\ncells = [\n    \"gc\",\n    \"me\",\n]\nphase_times = [6.0, 0.5, 11.5, 6.0]\n\n\nadd_linkers(model, \"../inputs/osmolytes.csv\", compartments, cells, phase_times)\n\n\nprefix_metabolites = {\n    \"a\": {\n        \"v_gc\": {\n            \"MAL\": 0.7,\n            \"CIT\": 0.5,\n        },\n        \"a\": {\n            \"MAL\": 0.7,\n        },\n        \"v_me\": {\n            \"MAL\": 0.7,\n            \"CIT\": 0.5,\n        },\n    },\n    \"b\": {\"v_me\": {\"HIS\": 0}, \"v_gc\": {\"HIS\": 0}},\n}\n\n\nfor prefix, compartments in prefix_metabolites.items():\n    for compartment, metabolites in compartments.items():\n        for metabolite, ratio in metabolites.items():\n            if ratio == 0:\n                set_bounds_multi(\n                    model, metabolite + \"_\" + compartment + \"_Linker\", 0, 0\n                )\n            elif ratio == 1:\n                set_bounds_multi(\n                    prefix + model, metabolite + \"_\" + compartment + \"_Linker\", 0, 0\n                )\n            else:\n                add_metabolite(\n                    model, metabolite + \"_\" + compartment + \"_prefixpseudometabolite\"\n                )\n                for phase in range(check_number_of_models(model)):\n                    model.reactions.get_by_id(\n                        f\"{metabolite}_{compartment}_Linker_\" + str(phase + 1)\n                    ).add_metabolites(\n                        {\n                            model.metabolites.get_by_id(\n                                f\"{metabolite}_{compartment}_prefixpseudometabolite_\" +\n                                str(phase + 1)\n                            ): 1 -\n                            ratio\n                        }\n                    )\n                    model.reactions.get_by_id(\n                        f\"{prefix}{metabolite}_{compartment}_Linker_\" + str(phase + 1)\n                    ).add_metabolites(\n                        {\n                            model.metabolites.get_by_id(\n                                f\"{metabolite}_{compartment}_prefixpseudometabolite_\"\n                                + str(phase + 1)\n                            ): -ratio\n                        }\n                    )",
    "crumbs": [
      "Building model and defining parameters",
      "Building model"
    ]
  },
  {
    "objectID": "1.1_buildingmodel.html#add-maintenance-reactions",
    "href": "1.1_buildingmodel.html#add-maintenance-reactions",
    "title": "Building model",
    "section": "Add Maintenance Reactions",
    "text": "Add Maintenance Reactions\nRemove maintenance phase constraint (no forcing same maintenance for each phase)\n\nnumber_of_models = check_number_of_models(model)\nfor cell in [\"gc\", \"me\"]:\n    add_metabolite(model, \"maintenance_ratio_constraint_\" + cell, \"pseudo\")\n    #add_metabolite(model, \"maintenance_phase_constraint_\" + cell, \"pseudo\")\n    add_reaction(model, \"maintenance_phase_overall_\" + cell, multi=\"\")\n    for i in range(1, number_of_models + 1):\n        for x in [\"c\", \"m\", \"p\"]:\n            reaction = model.reactions.get_by_id(f\"NADPHox_{x}_tx_{cell}_\" + str(i))\n            reaction.add_metabolites(\n                {f\"maintenance_ratio_constraint_{cell}_\" + str(i): -3}\n            )\n        reaction = model.reactions.get_by_id(f\"ATPase_tx_{cell}_\" + str(i))\n        reaction.add_metabolites(\n            {\n                f\"maintenance_ratio_constraint_{cell}_\" + str(i): 1,\n                #f\"maintenance_phase_constraint_{cell}_\" + str(i): 1,\n            }\n        )\n        #model.reactions.get_by_id(f\"maintenance_phase_overall_{cell}\").add_metabolites(\n        #    {f\"maintenance_phase_constraint_{cell}_\" + str(i): -1}\n        #)",
    "crumbs": [
      "Building model and defining parameters",
      "Building model"
    ]
  },
  {
    "objectID": "1.1_buildingmodel.html#add-phloem_tx-overall",
    "href": "1.1_buildingmodel.html#add-phloem_tx-overall",
    "title": "Building model",
    "section": "Add Phloem_tx Overall",
    "text": "Add Phloem_tx Overall\n\nnumber_of_models = check_number_of_models(model)\nday = [2, 3]\nnight = [1, 4]\nadd_metabolite(model, \"pseudoPhloem_me\", \"pseudo\")\nadd_metabolite(model, \"pseudoPhloem_day_me\", \"pseudo\", multi=\"\")\nadd_metabolite(model, \"pseudoPhloem_night_me\", \"pseudo\", multi=\"\")\nadd_reaction(model, \"Phloem_constraint_day\", multi=\"\")\nadd_reaction(model, \"Phloem_constraint_night\", multi=\"\")\nadd_reaction(model, \"Phloem_tx_overall\", multi=\"\")\nfor i in range(1, number_of_models + 1):\n    length_of_phase = 1 / (\n        -model.reactions.get_by_id(f\"SUCROSE_v_gc_Linker_{i}\").get_coefficient(\n            f\"SUCROSE_v_gc_{i}\"\n        )\n    )\n    model.reactions.get_by_id(f\"Phloem_output_tx_me_{i}\").add_metabolites(\n        {f\"pseudoPhloem_me_{i}\": 1}\n    )\n    if i in day:\n        model.reactions.get_by_id(f\"Phloem_output_tx_me_{i}\").add_metabolites(\n            {\"pseudoPhloem_day_me\": 1 * length_of_phase}\n        )\n        model.reactions.Phloem_constraint_day.add_metabolites(\n            {f\"pseudoPhloem_me_{i}\": -1}\n        )\n    elif i in night:\n        model.reactions.get_by_id(f\"Phloem_output_tx_me_{i}\").add_metabolites(\n            {\"pseudoPhloem_night_me\": 1 * length_of_phase}\n        )\n        model.reactions.Phloem_constraint_night.add_metabolites(\n            {f\"pseudoPhloem_me_{i}\": -1}\n        )\n    else:\n        raise ValueError(\"Make sure all phases are either assigned to day or night\")\nmodel.reactions.Phloem_constraint_day.add_metabolites({})\nmodel.reactions.Phloem_tx_overall.add_metabolites(\n    {\n        \"pseudoPhloem_day_me\": -3,\n        \"pseudoPhloem_night_me\": -1,\n    }\n)",
    "crumbs": [
      "Building model and defining parameters",
      "Building model"
    ]
  },
  {
    "objectID": "1.1_buildingmodel.html#add-pseudoreactions-for-total-metabolite-counting-and-fva",
    "href": "1.1_buildingmodel.html#add-pseudoreactions-for-total-metabolite-counting-and-fva",
    "title": "Building model",
    "section": "Add pseudoreactions for total metabolite counting and FVA",
    "text": "Add pseudoreactions for total metabolite counting and FVA\nEssentially, here we add a ‘total’ pseudometabolite in the guard cel for each of a list of metabolites. We can use this metabolite to see the sum of the linker reactions for the vacuole and cytoplasm, but most importantly we can perform FVA on this reaction to see if the total transfer of a metabolite matters. Otherwise, we end up in a situation where we can do FVA on the cytoplasmic and vacuolar reactions separately but it could be the case that when cytoplasm goes down the vacuole compensates etc.\n\"total\" added as keyword to getweightings in order to prevent these reactions from contributing to sum of fluxes constraint\n\nmetabolites = [\"SUCROSE\", \"GLC\", \"MAL\", \"FRU\", \"K\", \"Cl\", \"CIT\"]  # \"NITRATE\", \"CIT\"]\n\n\nfor metabolite in metabolites:\n    if metabolite == \"MAL\" or metabolite == \"CIT\":\n        add_reaction(model, f\"{metabolite}_total_pseudolinker\")\n        add_metabolite(model, f\"{metabolite}_total_pseudometabolite\")\n        add_metabolites_to_reaction_multi(\n            model,\n            f\"{metabolite}_total_pseudolinker\",\n            {f\"{metabolite}_total_pseudometabolite\": -1},\n        )\n        add_metabolites_to_reaction_multi(\n            model,\n            f\"{metabolite}_c_gc_Linker\",\n            {f\"{metabolite}_total_pseudometabolite\": 1},\n        )\n        add_metabolites_to_reaction_multi(\n            model,\n            f\"{metabolite}_v_gc_Linker\",\n            {f\"{metabolite}_total_pseudometabolite\": 1},\n        )\n        add_metabolites_to_reaction_multi(\n            model,\n            f\"a{metabolite}_v_gc_Linker\",\n            {f\"{metabolite}_total_pseudometabolite\": 1},\n        )\n    else:\n        add_reaction(model, f\"{metabolite}_total_pseudolinker\")\n        add_metabolite(model, f\"{metabolite}_total_pseudometabolite\")\n        add_metabolites_to_reaction_multi(\n            model,\n            f\"{metabolite}_total_pseudolinker\",\n            {f\"{metabolite}_total_pseudometabolite\": -1},\n        )\n        add_metabolites_to_reaction_multi(\n            model,\n            f\"{metabolite}_c_gc_Linker\",\n            {f\"{metabolite}_total_pseudometabolite\": 1},\n        )\n        add_metabolites_to_reaction_multi(\n            model,\n            f\"{metabolite}_v_gc_Linker\",\n            {f\"{metabolite}_total_pseudometabolite\": 1},\n        )",
    "crumbs": [
      "Building model and defining parameters",
      "Building model"
    ]
  },
  {
    "objectID": "1.1_buildingmodel.html#export-model",
    "href": "1.1_buildingmodel.html#export-model",
    "title": "Building model",
    "section": "Export Model",
    "text": "Export Model\n\ncobra.io.write_sbml_model(model, \"../models/4_stage_GC.xml\")\ncobra.io.save_json_model(model, \"../models/4_stage_GC.json\")",
    "crumbs": [
      "Building model and defining parameters",
      "Building model"
    ]
  },
  {
    "objectID": "2.2_analysingsolutions.html",
    "href": "2.2_analysingsolutions.html",
    "title": "Analysing solutions",
    "section": "",
    "text": "import itertools\nimport os\nimport re\nimport string\nimport xml.etree.ElementTree as ET\n\nimport cobra\nimport matplotlib as mpl\nimport matplotlib.patches as mpatches\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom IPython.display import SVG\nfrom matplotlib.ticker import MultipleLocator\nfrom mmon_gcm.analysing import get_escher_map\nfrom mmon_gcm.supermodel import SuperModel\n\n\nsns.set_theme()\nsns.set_style(\"ticks\")\nsns.set_palette(\n    sns.color_palette(\n        [\n            \"#332288\",\n            \"#88CCEE\",\n            \"#44AA99\",\n            \"#117733\",\n            \"#999933\",\n            \"#DDCC77\",\n            \"#CC6677\",\n            \"#882255\",\n            \"#AA4499\",\n        ]\n    )\n)\ncolours = sns.color_palette()\n\nparams = {\n    \"xtick.labelsize\": \"large\",\n    \"ytick.labelsize\": \"large\",\n    \"axes.labelsize\": \"large\",\n    \"axes.titlesize\": \"x-large\",\n    #\"axes.labelweight\": \"bold\",\n    #\"axes.titleweight\": \"bold\",\n    #\"font.weight\": \"bold\",\n    \"axes.spines.right\": False,\n    \"axes.spines.top\": False,\n    \"legend.frameon\": False,\n}\n\n#plt.rcParams['font.family'] = 'Arial'\n\nplt.rcParams.update(params)\n\n\ndef get_multiphase_fluxes(df, reaction):\n    reaction_phased = [f\"{reaction}_{i+1}\" for i in range(4)]\n    selected_df = df.loc[reaction_phased, \"fluxes\"]\n    return selected_df\n\n\ndef convert_phases_to_times(df, phase_times=[6, 6.5, 18, 24]):\n    df.index = pd.MultiIndex.from_tuples([(row[0], phase_times[row[1] - 1]) for row in df.index], names=df.index.names)\n    df = df.reorder_levels([\"Phase\", \"Reaction\"]).sort_index()\n    df = df.append(pd.concat([df.loc[24]], keys=[0]))\n    df = df.sort_index()\n    df = df.reorder_levels([\"Reaction\", \"Phase\"]).sort_index()\n\n    return df\n\n\ndef select_volume_based_on_id(reaction_id, SuperModel):\n    total_gc_volume = SuperModel.get_volumes(per_guard_cell=False)\n\n    if \"total\" in reaction_id:\n        phase_volumes = total_gc_volume = SuperModel.get_volumes(per_guard_cell=False)\n    elif \"v_gc\" in reaction_id:\n        phase_volumes = total_gc_volume = SuperModel.get_volumes(per_guard_cell=False) * SuperModel.Vac_frac\n    elif \"c_gc\" in reaction_id:\n        phase_volumes = total_gc_volume = SuperModel.get_volumes(per_guard_cell=False) * (1 - SuperModel.Vac_frac)\n    elif \"p_gc\" in reaction_id:\n        phase_volumes = [1] * 4\n    else:\n        raise ValueError(f\"Don't know how to deal with {reaction_id}\")\n\n    return phase_volumes\n\n\ndef convert_to_conc(row, SuperModel, phases_in_df=[0, 6, 6.5, 18, 24]):\n    phase = row.name[1]\n\n    phase_conversion_dict = {\n        phases_in_df[0]: 4,\n        phases_in_df[1]: 1,\n        phases_in_df[2]: 2,\n        phases_in_df[3]: 3,\n        phases_in_df[4]: 4,\n    }\n\n    phase_volumes = select_volume_based_on_id(row.name[0], SuperModel)\n\n    volume_for_phase = phase_volumes[phase_conversion_dict[phase] - 1]\n\n    return row / volume_for_phase\n\n\ndef get_metabolite_df(solutions_df, concentrations=True, total_mets=None, SuperModel=None):\n    if total_mets == None:\n        total_mets = [\"SUCROSE\", \"GLC\", \"MAL\", \"FRU\", \"K\", \"Cl\", \"CIT\"]\n    total_mets_reactions = [met + \"_total_pseudolinker\" for met in total_mets] + [\"STARCH_p_gc_Linker\"]\n    total_mets_reactions_phased = [f\"{reaction}_{i+1}\" for i in range(4) for reaction in total_mets_reactions]\n    met_df = (solutions_df.loc[total_mets_reactions]).copy()\n\n    # change index to phase times instead of tags\n    met_df = convert_phases_to_times(met_df)\n\n    if concentrations == True:\n        met_df = met_df.apply(convert_to_conc, args=([SuperModel]), axis=1)\n\n    met_df = met_df.reorder_levels([\"Phase\", \"Reaction\"]).sort_index()\n\n    met_df.index = pd.MultiIndex.from_tuples(\n        [(index[0], index[1].split(\"_\")[0]) for index in met_df.index],\n        names=met_df.index.names,\n    )\n\n    return met_df\n\n\ndef get_closed_open_values(met_df_mm, light, atpase):\n    open_closed_dict = {}\n\n    for genotype in [\"wt\", \"starchko\"]:\n        open_closed_dict[genotype] = {}\n        open_closed_dict[genotype][\"closed\"] = met_df_mm.loc[~(met_df_mm.index == (6, \"STARCH\"))].loc[\n            6, (light, atpase, genotype, \"fluxes\")\n        ]\n        open_closed_dict[genotype][\"open\"] = met_df_mm.loc[~(met_df_mm.index == (6.5, \"STARCH\"))].loc[\n            6.5, (light, atpase, genotype, \"fluxes\")\n        ]\n\n    return open_closed_dict\n\n\ndef get_closed_open_values(met_df_mm, light, atpase):\n    open_closed_dict = {}\n\n    for genotype in [\"wt\", \"starchko\"]:\n        open_closed_dict[genotype] = {}\n        open_closed_dict[genotype][\"closed\"] = met_df_mm.loc[6, (light, atpase, genotype, \"fluxes\")]\n        open_closed_dict[genotype][\"open\"] = met_df_mm.loc[6.5, (light, atpase, genotype, \"fluxes\")]\n\n    return open_closed_dict\n\n\ndef get_totals_plot(specific_met_df):\n    colours = [\"#999999ff\", \"#ff7043ff\"]\n    mpl.rcParams[\"hatch.linewidth\"] = 1.5\n    fig, axs = plt.subplots(1, 2, figsize=(10, 4), gridspec_kw={\"width_ratios\": [7, 1]})\n\n    closed_metabolite_df = specific_met_df.loc[6.0].drop(\"STARCH\")\n    open_metabolite_df = specific_met_df.loc[6.5].drop(\"STARCH\")\n\n    # plot wt\n    axs[0].bar(\n        np.array(range(len(closed_metabolite_df))) * 2 - 0.05,\n        closed_metabolite_df[\"wt\"],\n        color=colours[0],\n        width=-0.3,\n        align=\"edge\",\n        edgecolor=colours[0],\n    )\n    axs[0].bar(\n        np.array(range(len(open_metabolite_df))) * 2 + 0.05,\n        open_metabolite_df[\"wt\"],\n        color=colours[1],\n        width=0.3,\n        align=\"edge\",\n        edgecolor=colours[1],\n    )\n\n    axs[0].bar(\n        np.array(range(len(closed_metabolite_df))) * 2 + 1 - 0.05,\n        closed_metabolite_df[\"starchko\"],\n        color=colours[0],\n        width=-0.3,\n        align=\"edge\",\n        edgecolor=\"white\",\n        hatch=\"//\",\n    )\n    axs[0].bar(\n        np.array(range(len(closed_metabolite_df))) * 2 + 1 + 0.05,\n        open_metabolite_df[\"starchko\"],\n        color=colours[1],\n        width=0.3,\n        align=\"edge\",\n        edgecolor=\"white\",\n        hatch=\"//\",\n    )\n    axs[0].bar(\n        np.array(range(len(closed_metabolite_df))) * 2 + 1 - 0.05,\n        closed_metabolite_df[\"starchko\"],\n        color=\"none\",\n        width=-0.3,\n        align=\"edge\",\n        edgecolor=colours[0],\n    )\n    axs[0].bar(\n        np.array(range(len(closed_metabolite_df))) * 2 + 1 + 0.05,\n        open_metabolite_df[\"starchko\"],\n        color=\"none\",\n        width=0.3,\n        align=\"edge\",\n        edgecolor=colours[1],\n    )\n\n    x_ticks_pad = 12\n    axs[0].tick_params(axis=\"x\", which=\"both\", bottom=False, pad=x_ticks_pad)\n    axs[1].tick_params(axis=\"x\", which=\"both\", bottom=False, pad=x_ticks_pad)\n\n    starch_closed = specific_met_df.loc[(6.0, \"STARCH\")]\n    starch_open = specific_met_df.loc[(6.5, \"STARCH\")]\n\n    axs[1].bar(\n        -0.05,\n        starch_closed[\"wt\"],\n        width=-0.3,\n        align=\"edge\",\n        edgecolor=colours[0],\n        color=colours[0],\n    )\n    axs[1].bar(\n        0.05,\n        starch_open[\"wt\"],\n        width=0.3,\n        align=\"edge\",\n        edgecolor=colours[1],\n        color=colours[1],\n    )\n\n    axs[1].bar(\n        1 - 0.05,\n        starch_closed[\"starchko\"],\n        width=-0.3,\n        align=\"edge\",\n        edgecolor=colours[0],\n        color=colours[0],\n        hatch=\"//\",\n    )\n    axs[1].bar(\n        1 + 0.05,\n        starch_open[\"starchko\"],\n        width=0.3,\n        align=\"edge\",\n        edgecolor=colours[1],\n        color=colours[1],\n        hatch=\"//\",\n    )\n\n    main_x_tick_labels = [name[0] + name[1:3].lower() for name in open_metabolite_df.index]\n\n    main_x_tick_labels_superscripted = []\n    for label in main_x_tick_labels:\n        if label == \"K\":\n            new_label = r\"K$^+$\"\n        elif label == \"Cl\":\n            new_label = r\"Cl$^-$\"\n        else:\n            new_label = label\n        main_x_tick_labels_superscripted.append(new_label)\n\n    main_x_tick_labels = main_x_tick_labels_superscripted\n\n    main_x_ticks = np.array(range(len(closed_metabolite_df))) * 2 + 0.5\n\n    ax0_y_max = 60\n\n    axs[0].set_xticks(main_x_ticks)\n    axs[0].set_xticklabels(main_x_tick_labels)\n    axs[0].set_ylim(-0.1, ax0_y_max)\n    axs[0].set_xlim(-0.5, 13.5)\n    axs[0].set_ylabel(r\"Osmolyte concentration (mM)\")\n    axs[0].yaxis.set_major_locator(MultipleLocator(10))\n    # axs[0].yaxis.set_minor_locator(AutoMinorLocator(2))\n\n    for x_loc in [(x - 1) * 2 + 1.5 for x in range(len(closed_metabolite_df))]:\n        axs[0].hlines(-3.7, x_loc + 0.1, x_loc + 1.9, clip_on=False, color=\"black\", alpha=0.9)\n        for offset, label in zip([0.5, 1.5], [\"WT\", \"KO\"]):\n            axs[0].text(x_loc + offset, -2, label, ha=\"center\", va=\"center\", size=\"small\")\n\n    starch_x_tick_labels = [\"Starch\"]\n    starch_x_ticks = [0.5]\n\n    ax1_y_max = 14\n\n    axs[1].set_xticks(starch_x_ticks)\n    axs[1].set_xticklabels(starch_x_tick_labels)\n    axs[1].set_ylim(-0.1 * ax1_y_max / ax0_y_max, ax1_y_max)\n    axs[1].yaxis.set_label_position(\"right\")\n    axs[1].yaxis.tick_right()\n    axs[1].yaxis.set_major_locator(MultipleLocator(2))\n    # axs[1].yaxis.set_minor_locator(AutoMinorLocator(2))\n    axs[1].spines[\"right\"].set_visible(True)\n    axs[1].spines[\"left\"].set_visible(False)\n    axs[1].set_ylabel(r\"Amount (fmol$\\cdot$GC$^{-1}$)\")\n\n    for x_loc in [(x - 1) * 2 + 1.5 for x in [0]]:\n        axs[1].hlines(\n            -3.7 * ax1_y_max / ax0_y_max,\n            x_loc + 0.1,\n            x_loc + 2,\n            clip_on=False,\n            color=\"black\",\n            alpha=0.9,\n        )\n        for offset, label in zip([0.5, 1.5], [\"WT\", \"KO\"]):\n            axs[1].text(\n                x_loc + offset,\n                -2 * ax1_y_max / ax0_y_max,\n                label,\n                ha=\"center\",\n                va=\"center\",\n                size=\"small\",\n            )\n\n    colors = {\"EoN\": \"#999999ff\", \"30 mins\": \"#ff7043ff\"}\n    labels = list(colors.keys())\n    handles = [plt.Rectangle((0, 0), 1, 1, color=colors[label]) for label in labels]\n    # plt.legend(handles, labels)\n\n    plt.subplots_adjust(wspace=0.05)\n\n    return fig\n\n\ndef getgcdiagram(\n    modeldf,\n    modelname,\n    condition_label,\n    genotype_label,\n    scale_height,\n    minimal=True,\n    flipped=False,\n    display_svg=True,\n    debug=False,\n    brokenaxis=False,\n    aspser=False,\n    save_png=True,\n):\n    if minimal == True:\n        if aspser == True:\n            tree = ET.parse(\"../inputs/fluxmap_template_aspserminimal.svg\")\n            root = tree.getroot\n        else:\n            tree = ET.parse(\"../inputs/fluxmap_template_minimal.svg\")\n            root = tree.getroot\n    else:\n        tree = ET.parse(\"../inputs/fluxmap_template.svg\")\n        root = updatetextnames(tree, condition_label, genotype_label, debug=debug)\n\n    # get the background and the flipped background, and set the opacity of the wrong one to 0\n    background = getelement(\n        tree,\n        condition_label=condition_label,\n        genotype_label=genotype_label,\n        compartment_label=\"Background\",\n        debug=debug,\n    )\n    background_flipped = getelement(\n        tree,\n        condition_label=condition_label,\n        genotype_label=genotype_label,\n        compartment_label=\"Background_flipped\",\n        debug=debug,\n    )\n\n    if flipped == True:\n        updateelementopacity(background, 0)\n        updateelementopacity(background_flipped, 1)\n    else:\n        updateelementopacity(background, 1)\n        updateelementopacity(background_flipped, 0)\n\n    if minimal is not True:\n        # get the scale bar, either keep the hatched or don't, and set the height to the scale conc specified\n        for phase_label in [\"EoN\", \"30\", \"EoN_hatched\", \"30_hatched\"]:\n            scale_bar_element = getelement(\n                tree,\n                condition_label=condition_label,\n                genotype_label=genotype_label,\n                compartment_label=\"other\",\n                metabolite_label=\"scale\",\n                phase_label=phase_label,\n                debug=debug,\n            )\n            if \"hatched\" in phase_label:\n                updateelementopacity(scale_bar_element, int(flipped))\n            else:\n                updateelementopacity(scale_bar_element, int(not flipped))\n            updateelementheight(scale_bar_element, scale_height)\n\n    for row in modeldf.iterrows():\n        compartment_label = row[0][1]\n        metabolite_label = row[0][0]\n\n        if debug == True:\n            print(row[0], row[1])\n\n        try:\n            eon_element = getelement(\n                tree,\n                condition_label=condition_label,\n                genotype_label=genotype_label,\n                compartment_label=compartment_label,\n                metabolite_label=metabolite_label,\n                phase_label=\"EoN\",\n                debug=debug,\n            )\n            thirty_element = getelement(\n                tree,\n                condition_label=condition_label,\n                genotype_label=genotype_label,\n                compartment_label=compartment_label,\n                metabolite_label=metabolite_label,\n                phase_label=\"30\",\n                debug=debug,\n            )\n\n            eon_element_hatched = getelement(\n                tree,\n                condition_label=condition_label,\n                genotype_label=genotype_label,\n                compartment_label=compartment_label,\n                metabolite_label=metabolite_label,\n                phase_label=\"EoN_hatched\",\n                debug=debug,\n            )\n            thirty_element_hatched = getelement(\n                tree,\n                condition_label=condition_label,\n                genotype_label=genotype_label,\n                compartment_label=compartment_label,\n                metabolite_label=metabolite_label,\n                phase_label=\"30_hatched\",\n                debug=debug,\n            )\n\n            if flipped == True:\n                updateelementopacity(eon_element, 0)\n                updateelementopacity(eon_element_hatched, 1)\n                updateelementopacity(thirty_element, 0)\n                updateelementopacity(thirty_element_hatched, 1)\n            else:\n                updateelementopacity(eon_element, 1)\n                updateelementopacity(eon_element_hatched, 0)\n                updateelementopacity(thirty_element, 1)\n                updateelementopacity(thirty_element_hatched, 0)\n\n            if row[1][\"EoN\"] &lt;= 0.0001:\n                updateelementheight(eon_element, 0.5)\n                updateelementheight(eon_element_hatched, 0.5)\n            else:\n                updateelementheight(eon_element, row[1][\"EoN\"])\n                updateelementheight(eon_element_hatched, row[1][\"EoN\"])\n\n            if row[1][\"30 mins\"] &lt;= 0.0001:\n                updateelementheight(thirty_element, 0.5)\n                updateelementheight(thirty_element_hatched, 0.5)\n            else:\n                updateelementheight(thirty_element, row[1][\"30 mins\"])\n                updateelementheight(thirty_element_hatched, row[1][\"30 mins\"])\n\n        except AttributeError:\n            print(f\"{row[0]} not in template\")\n\n    svgpath = f\"../outputs/flux_maps/{modelname}.svg\"\n    tree.write(svgpath, encoding=\"UTF-8\", xml_declaration=True)\n    if display_svg == True:\n        display(SVG(svgpath))\n\n    return svgpath\n\n\ndef getelement(\n    tree,\n    condition_label,\n    genotype_label=None,\n    compartment_label=None,\n    metabolite_label=None,\n    phase_label=None,\n    debug=False,\n):\n    if debug == True:\n        print(\n            \"Trying: \",\n            condition_label,\n            genotype_label,\n            compartment_label,\n            metabolite_label,\n            phase_label,\n        )\n    root = tree.getroot()\n    if debug == True:\n        print(\"Got root\", end=\" \")\n    for condition in root.findall(\"{http://www.w3.org/2000/svg}g\"):\n        if condition.get(\"{http://www.inkscape.org/namespaces/inkscape}label\") == \"condition\":\n            if debug == True:\n                print(condition_label, end=\" \")\n            if genotype_label == None:\n                return conditon\n            else:\n                for genotype in condition:\n                    if genotype.get(\"{http://www.inkscape.org/namespaces/inkscape}label\") == \"genotype\":\n                        if debug == True:\n                            print(genotype_label, end=\" \")\n                        if compartment_label == None:\n                            return genotype\n                        else:\n                            for compartment in genotype:\n                                if (\n                                    compartment.get(\"{http://www.inkscape.org/namespaces/inkscape}label\")\n                                    == compartment_label\n                                ):\n                                    if debug == True:\n                                        print(compartment_label, end=\" \")\n                                    if metabolite_label == None:\n                                        return compartment\n                                    else:\n                                        for metabolite in compartment:\n                                            if (\n                                                metabolite.get(\"{http://www.inkscape.org/namespaces/inkscape}label\")\n                                                == metabolite_label\n                                            ):\n                                                if debug == True:\n                                                    print(metabolite_label, end=\" \")\n                                                if phase_label == None:\n                                                    return metabolite\n                                                else:\n                                                    for phase in metabolite:\n                                                        if (\n                                                            phase.get(\n                                                                \"{http://www.inkscape.org/namespaces/inkscape}label\"\n                                                            )\n                                                            == phase_label\n                                                        ):\n                                                            return phase\n\n\ndef updateelementopacity(element, opacity):\n    style_attribs = element.attrib[\"style\"].split(\";\")\n    for i, style in enumerate(style_attribs):\n        if re.match(r\"^opacity\", style):\n            del style_attribs[i]\n    style_attribs.append(\"opacity:\" + str(opacity))\n    element.attrib[\"style\"] = \";\".join(style_attribs)\n    return element\n\n\ndef updateelementheight(element, height):\n    try:\n        element.attrib[\"height\"]\n        element.attrib[\"height\"] = str(height)\n    except:\n        element.attrib[\"d\"] = (\n            element.attrib[\"d\"].split(\"v\")[0] + \"v -\" + str(height) + \" h\" + element.attrib[\"d\"].split(\"h\")[1]\n        )\n    return element\n\n\ndef updatetextnames(tree, condition_label, genotype_label, debug=False):\n    root = tree.getroot()\n    for condition in root.findall(\"{http://www.w3.org/2000/svg}g\"):\n        if condition.get(\"{http://www.inkscape.org/namespaces/inkscape}label\") == \"condition\":\n            for genotype in condition:\n                if genotype.get(\"{http://www.inkscape.org/namespaces/inkscape}label\") == \"condition_name\":\n                    for tspan in genotype:\n                        tspan.text = condition_label\n                        if debug == True:\n                            print(\"Condition label changed to \" + tspan.text)\n                elif genotype.get(\"{http://www.inkscape.org/namespaces/inkscape}label\") == \"genotype\":\n                    for compartment in genotype:\n                        if compartment.get(\"{http://www.inkscape.org/namespaces/inkscape}label\") == \"genotype_name\":\n                            for tspan in compartment:\n                                tspan.text = genotype_label\n                                if debug == True:\n                                    print(\"Genotype label changed to \" + tspan.text)\n                                return root\n\n\nparameters_df = pd.read_csv(\"../inputs/arabidopsis_parameters.csv\", index_col=0)\nfour_stage_GC_model = cobra.io.sbml.read_sbml_model(\"../models/4_stage_GC.xml\")  # read model\narabidopsis_supermodel = SuperModel(parameters_df.loc[:, \"Value\"], fba_model=four_stage_GC_model);\n\nNo objective coefficients in model. Unclear what should be optimized",
    "crumbs": [
      "Solving and analysing specific scenarios for paper",
      "Analysing solutions"
    ]
  },
  {
    "objectID": "2.2_analysingsolutions.html#setup",
    "href": "2.2_analysingsolutions.html#setup",
    "title": "Analysing solutions",
    "section": "",
    "text": "import itertools\nimport os\nimport re\nimport string\nimport xml.etree.ElementTree as ET\n\nimport cobra\nimport matplotlib as mpl\nimport matplotlib.patches as mpatches\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom IPython.display import SVG\nfrom matplotlib.ticker import MultipleLocator\nfrom mmon_gcm.analysing import get_escher_map\nfrom mmon_gcm.supermodel import SuperModel\n\n\nsns.set_theme()\nsns.set_style(\"ticks\")\nsns.set_palette(\n    sns.color_palette(\n        [\n            \"#332288\",\n            \"#88CCEE\",\n            \"#44AA99\",\n            \"#117733\",\n            \"#999933\",\n            \"#DDCC77\",\n            \"#CC6677\",\n            \"#882255\",\n            \"#AA4499\",\n        ]\n    )\n)\ncolours = sns.color_palette()\n\nparams = {\n    \"xtick.labelsize\": \"large\",\n    \"ytick.labelsize\": \"large\",\n    \"axes.labelsize\": \"large\",\n    \"axes.titlesize\": \"x-large\",\n    #\"axes.labelweight\": \"bold\",\n    #\"axes.titleweight\": \"bold\",\n    #\"font.weight\": \"bold\",\n    \"axes.spines.right\": False,\n    \"axes.spines.top\": False,\n    \"legend.frameon\": False,\n}\n\n#plt.rcParams['font.family'] = 'Arial'\n\nplt.rcParams.update(params)\n\n\ndef get_multiphase_fluxes(df, reaction):\n    reaction_phased = [f\"{reaction}_{i+1}\" for i in range(4)]\n    selected_df = df.loc[reaction_phased, \"fluxes\"]\n    return selected_df\n\n\ndef convert_phases_to_times(df, phase_times=[6, 6.5, 18, 24]):\n    df.index = pd.MultiIndex.from_tuples([(row[0], phase_times[row[1] - 1]) for row in df.index], names=df.index.names)\n    df = df.reorder_levels([\"Phase\", \"Reaction\"]).sort_index()\n    df = df.append(pd.concat([df.loc[24]], keys=[0]))\n    df = df.sort_index()\n    df = df.reorder_levels([\"Reaction\", \"Phase\"]).sort_index()\n\n    return df\n\n\ndef select_volume_based_on_id(reaction_id, SuperModel):\n    total_gc_volume = SuperModel.get_volumes(per_guard_cell=False)\n\n    if \"total\" in reaction_id:\n        phase_volumes = total_gc_volume = SuperModel.get_volumes(per_guard_cell=False)\n    elif \"v_gc\" in reaction_id:\n        phase_volumes = total_gc_volume = SuperModel.get_volumes(per_guard_cell=False) * SuperModel.Vac_frac\n    elif \"c_gc\" in reaction_id:\n        phase_volumes = total_gc_volume = SuperModel.get_volumes(per_guard_cell=False) * (1 - SuperModel.Vac_frac)\n    elif \"p_gc\" in reaction_id:\n        phase_volumes = [1] * 4\n    else:\n        raise ValueError(f\"Don't know how to deal with {reaction_id}\")\n\n    return phase_volumes\n\n\ndef convert_to_conc(row, SuperModel, phases_in_df=[0, 6, 6.5, 18, 24]):\n    phase = row.name[1]\n\n    phase_conversion_dict = {\n        phases_in_df[0]: 4,\n        phases_in_df[1]: 1,\n        phases_in_df[2]: 2,\n        phases_in_df[3]: 3,\n        phases_in_df[4]: 4,\n    }\n\n    phase_volumes = select_volume_based_on_id(row.name[0], SuperModel)\n\n    volume_for_phase = phase_volumes[phase_conversion_dict[phase] - 1]\n\n    return row / volume_for_phase\n\n\ndef get_metabolite_df(solutions_df, concentrations=True, total_mets=None, SuperModel=None):\n    if total_mets == None:\n        total_mets = [\"SUCROSE\", \"GLC\", \"MAL\", \"FRU\", \"K\", \"Cl\", \"CIT\"]\n    total_mets_reactions = [met + \"_total_pseudolinker\" for met in total_mets] + [\"STARCH_p_gc_Linker\"]\n    total_mets_reactions_phased = [f\"{reaction}_{i+1}\" for i in range(4) for reaction in total_mets_reactions]\n    met_df = (solutions_df.loc[total_mets_reactions]).copy()\n\n    # change index to phase times instead of tags\n    met_df = convert_phases_to_times(met_df)\n\n    if concentrations == True:\n        met_df = met_df.apply(convert_to_conc, args=([SuperModel]), axis=1)\n\n    met_df = met_df.reorder_levels([\"Phase\", \"Reaction\"]).sort_index()\n\n    met_df.index = pd.MultiIndex.from_tuples(\n        [(index[0], index[1].split(\"_\")[0]) for index in met_df.index],\n        names=met_df.index.names,\n    )\n\n    return met_df\n\n\ndef get_closed_open_values(met_df_mm, light, atpase):\n    open_closed_dict = {}\n\n    for genotype in [\"wt\", \"starchko\"]:\n        open_closed_dict[genotype] = {}\n        open_closed_dict[genotype][\"closed\"] = met_df_mm.loc[~(met_df_mm.index == (6, \"STARCH\"))].loc[\n            6, (light, atpase, genotype, \"fluxes\")\n        ]\n        open_closed_dict[genotype][\"open\"] = met_df_mm.loc[~(met_df_mm.index == (6.5, \"STARCH\"))].loc[\n            6.5, (light, atpase, genotype, \"fluxes\")\n        ]\n\n    return open_closed_dict\n\n\ndef get_closed_open_values(met_df_mm, light, atpase):\n    open_closed_dict = {}\n\n    for genotype in [\"wt\", \"starchko\"]:\n        open_closed_dict[genotype] = {}\n        open_closed_dict[genotype][\"closed\"] = met_df_mm.loc[6, (light, atpase, genotype, \"fluxes\")]\n        open_closed_dict[genotype][\"open\"] = met_df_mm.loc[6.5, (light, atpase, genotype, \"fluxes\")]\n\n    return open_closed_dict\n\n\ndef get_totals_plot(specific_met_df):\n    colours = [\"#999999ff\", \"#ff7043ff\"]\n    mpl.rcParams[\"hatch.linewidth\"] = 1.5\n    fig, axs = plt.subplots(1, 2, figsize=(10, 4), gridspec_kw={\"width_ratios\": [7, 1]})\n\n    closed_metabolite_df = specific_met_df.loc[6.0].drop(\"STARCH\")\n    open_metabolite_df = specific_met_df.loc[6.5].drop(\"STARCH\")\n\n    # plot wt\n    axs[0].bar(\n        np.array(range(len(closed_metabolite_df))) * 2 - 0.05,\n        closed_metabolite_df[\"wt\"],\n        color=colours[0],\n        width=-0.3,\n        align=\"edge\",\n        edgecolor=colours[0],\n    )\n    axs[0].bar(\n        np.array(range(len(open_metabolite_df))) * 2 + 0.05,\n        open_metabolite_df[\"wt\"],\n        color=colours[1],\n        width=0.3,\n        align=\"edge\",\n        edgecolor=colours[1],\n    )\n\n    axs[0].bar(\n        np.array(range(len(closed_metabolite_df))) * 2 + 1 - 0.05,\n        closed_metabolite_df[\"starchko\"],\n        color=colours[0],\n        width=-0.3,\n        align=\"edge\",\n        edgecolor=\"white\",\n        hatch=\"//\",\n    )\n    axs[0].bar(\n        np.array(range(len(closed_metabolite_df))) * 2 + 1 + 0.05,\n        open_metabolite_df[\"starchko\"],\n        color=colours[1],\n        width=0.3,\n        align=\"edge\",\n        edgecolor=\"white\",\n        hatch=\"//\",\n    )\n    axs[0].bar(\n        np.array(range(len(closed_metabolite_df))) * 2 + 1 - 0.05,\n        closed_metabolite_df[\"starchko\"],\n        color=\"none\",\n        width=-0.3,\n        align=\"edge\",\n        edgecolor=colours[0],\n    )\n    axs[0].bar(\n        np.array(range(len(closed_metabolite_df))) * 2 + 1 + 0.05,\n        open_metabolite_df[\"starchko\"],\n        color=\"none\",\n        width=0.3,\n        align=\"edge\",\n        edgecolor=colours[1],\n    )\n\n    x_ticks_pad = 12\n    axs[0].tick_params(axis=\"x\", which=\"both\", bottom=False, pad=x_ticks_pad)\n    axs[1].tick_params(axis=\"x\", which=\"both\", bottom=False, pad=x_ticks_pad)\n\n    starch_closed = specific_met_df.loc[(6.0, \"STARCH\")]\n    starch_open = specific_met_df.loc[(6.5, \"STARCH\")]\n\n    axs[1].bar(\n        -0.05,\n        starch_closed[\"wt\"],\n        width=-0.3,\n        align=\"edge\",\n        edgecolor=colours[0],\n        color=colours[0],\n    )\n    axs[1].bar(\n        0.05,\n        starch_open[\"wt\"],\n        width=0.3,\n        align=\"edge\",\n        edgecolor=colours[1],\n        color=colours[1],\n    )\n\n    axs[1].bar(\n        1 - 0.05,\n        starch_closed[\"starchko\"],\n        width=-0.3,\n        align=\"edge\",\n        edgecolor=colours[0],\n        color=colours[0],\n        hatch=\"//\",\n    )\n    axs[1].bar(\n        1 + 0.05,\n        starch_open[\"starchko\"],\n        width=0.3,\n        align=\"edge\",\n        edgecolor=colours[1],\n        color=colours[1],\n        hatch=\"//\",\n    )\n\n    main_x_tick_labels = [name[0] + name[1:3].lower() for name in open_metabolite_df.index]\n\n    main_x_tick_labels_superscripted = []\n    for label in main_x_tick_labels:\n        if label == \"K\":\n            new_label = r\"K$^+$\"\n        elif label == \"Cl\":\n            new_label = r\"Cl$^-$\"\n        else:\n            new_label = label\n        main_x_tick_labels_superscripted.append(new_label)\n\n    main_x_tick_labels = main_x_tick_labels_superscripted\n\n    main_x_ticks = np.array(range(len(closed_metabolite_df))) * 2 + 0.5\n\n    ax0_y_max = 60\n\n    axs[0].set_xticks(main_x_ticks)\n    axs[0].set_xticklabels(main_x_tick_labels)\n    axs[0].set_ylim(-0.1, ax0_y_max)\n    axs[0].set_xlim(-0.5, 13.5)\n    axs[0].set_ylabel(r\"Osmolyte concentration (mM)\")\n    axs[0].yaxis.set_major_locator(MultipleLocator(10))\n    # axs[0].yaxis.set_minor_locator(AutoMinorLocator(2))\n\n    for x_loc in [(x - 1) * 2 + 1.5 for x in range(len(closed_metabolite_df))]:\n        axs[0].hlines(-3.7, x_loc + 0.1, x_loc + 1.9, clip_on=False, color=\"black\", alpha=0.9)\n        for offset, label in zip([0.5, 1.5], [\"WT\", \"KO\"]):\n            axs[0].text(x_loc + offset, -2, label, ha=\"center\", va=\"center\", size=\"small\")\n\n    starch_x_tick_labels = [\"Starch\"]\n    starch_x_ticks = [0.5]\n\n    ax1_y_max = 14\n\n    axs[1].set_xticks(starch_x_ticks)\n    axs[1].set_xticklabels(starch_x_tick_labels)\n    axs[1].set_ylim(-0.1 * ax1_y_max / ax0_y_max, ax1_y_max)\n    axs[1].yaxis.set_label_position(\"right\")\n    axs[1].yaxis.tick_right()\n    axs[1].yaxis.set_major_locator(MultipleLocator(2))\n    # axs[1].yaxis.set_minor_locator(AutoMinorLocator(2))\n    axs[1].spines[\"right\"].set_visible(True)\n    axs[1].spines[\"left\"].set_visible(False)\n    axs[1].set_ylabel(r\"Amount (fmol$\\cdot$GC$^{-1}$)\")\n\n    for x_loc in [(x - 1) * 2 + 1.5 for x in [0]]:\n        axs[1].hlines(\n            -3.7 * ax1_y_max / ax0_y_max,\n            x_loc + 0.1,\n            x_loc + 2,\n            clip_on=False,\n            color=\"black\",\n            alpha=0.9,\n        )\n        for offset, label in zip([0.5, 1.5], [\"WT\", \"KO\"]):\n            axs[1].text(\n                x_loc + offset,\n                -2 * ax1_y_max / ax0_y_max,\n                label,\n                ha=\"center\",\n                va=\"center\",\n                size=\"small\",\n            )\n\n    colors = {\"EoN\": \"#999999ff\", \"30 mins\": \"#ff7043ff\"}\n    labels = list(colors.keys())\n    handles = [plt.Rectangle((0, 0), 1, 1, color=colors[label]) for label in labels]\n    # plt.legend(handles, labels)\n\n    plt.subplots_adjust(wspace=0.05)\n\n    return fig\n\n\ndef getgcdiagram(\n    modeldf,\n    modelname,\n    condition_label,\n    genotype_label,\n    scale_height,\n    minimal=True,\n    flipped=False,\n    display_svg=True,\n    debug=False,\n    brokenaxis=False,\n    aspser=False,\n    save_png=True,\n):\n    if minimal == True:\n        if aspser == True:\n            tree = ET.parse(\"../inputs/fluxmap_template_aspserminimal.svg\")\n            root = tree.getroot\n        else:\n            tree = ET.parse(\"../inputs/fluxmap_template_minimal.svg\")\n            root = tree.getroot\n    else:\n        tree = ET.parse(\"../inputs/fluxmap_template.svg\")\n        root = updatetextnames(tree, condition_label, genotype_label, debug=debug)\n\n    # get the background and the flipped background, and set the opacity of the wrong one to 0\n    background = getelement(\n        tree,\n        condition_label=condition_label,\n        genotype_label=genotype_label,\n        compartment_label=\"Background\",\n        debug=debug,\n    )\n    background_flipped = getelement(\n        tree,\n        condition_label=condition_label,\n        genotype_label=genotype_label,\n        compartment_label=\"Background_flipped\",\n        debug=debug,\n    )\n\n    if flipped == True:\n        updateelementopacity(background, 0)\n        updateelementopacity(background_flipped, 1)\n    else:\n        updateelementopacity(background, 1)\n        updateelementopacity(background_flipped, 0)\n\n    if minimal is not True:\n        # get the scale bar, either keep the hatched or don't, and set the height to the scale conc specified\n        for phase_label in [\"EoN\", \"30\", \"EoN_hatched\", \"30_hatched\"]:\n            scale_bar_element = getelement(\n                tree,\n                condition_label=condition_label,\n                genotype_label=genotype_label,\n                compartment_label=\"other\",\n                metabolite_label=\"scale\",\n                phase_label=phase_label,\n                debug=debug,\n            )\n            if \"hatched\" in phase_label:\n                updateelementopacity(scale_bar_element, int(flipped))\n            else:\n                updateelementopacity(scale_bar_element, int(not flipped))\n            updateelementheight(scale_bar_element, scale_height)\n\n    for row in modeldf.iterrows():\n        compartment_label = row[0][1]\n        metabolite_label = row[0][0]\n\n        if debug == True:\n            print(row[0], row[1])\n\n        try:\n            eon_element = getelement(\n                tree,\n                condition_label=condition_label,\n                genotype_label=genotype_label,\n                compartment_label=compartment_label,\n                metabolite_label=metabolite_label,\n                phase_label=\"EoN\",\n                debug=debug,\n            )\n            thirty_element = getelement(\n                tree,\n                condition_label=condition_label,\n                genotype_label=genotype_label,\n                compartment_label=compartment_label,\n                metabolite_label=metabolite_label,\n                phase_label=\"30\",\n                debug=debug,\n            )\n\n            eon_element_hatched = getelement(\n                tree,\n                condition_label=condition_label,\n                genotype_label=genotype_label,\n                compartment_label=compartment_label,\n                metabolite_label=metabolite_label,\n                phase_label=\"EoN_hatched\",\n                debug=debug,\n            )\n            thirty_element_hatched = getelement(\n                tree,\n                condition_label=condition_label,\n                genotype_label=genotype_label,\n                compartment_label=compartment_label,\n                metabolite_label=metabolite_label,\n                phase_label=\"30_hatched\",\n                debug=debug,\n            )\n\n            if flipped == True:\n                updateelementopacity(eon_element, 0)\n                updateelementopacity(eon_element_hatched, 1)\n                updateelementopacity(thirty_element, 0)\n                updateelementopacity(thirty_element_hatched, 1)\n            else:\n                updateelementopacity(eon_element, 1)\n                updateelementopacity(eon_element_hatched, 0)\n                updateelementopacity(thirty_element, 1)\n                updateelementopacity(thirty_element_hatched, 0)\n\n            if row[1][\"EoN\"] &lt;= 0.0001:\n                updateelementheight(eon_element, 0.5)\n                updateelementheight(eon_element_hatched, 0.5)\n            else:\n                updateelementheight(eon_element, row[1][\"EoN\"])\n                updateelementheight(eon_element_hatched, row[1][\"EoN\"])\n\n            if row[1][\"30 mins\"] &lt;= 0.0001:\n                updateelementheight(thirty_element, 0.5)\n                updateelementheight(thirty_element_hatched, 0.5)\n            else:\n                updateelementheight(thirty_element, row[1][\"30 mins\"])\n                updateelementheight(thirty_element_hatched, row[1][\"30 mins\"])\n\n        except AttributeError:\n            print(f\"{row[0]} not in template\")\n\n    svgpath = f\"../outputs/flux_maps/{modelname}.svg\"\n    tree.write(svgpath, encoding=\"UTF-8\", xml_declaration=True)\n    if display_svg == True:\n        display(SVG(svgpath))\n\n    return svgpath\n\n\ndef getelement(\n    tree,\n    condition_label,\n    genotype_label=None,\n    compartment_label=None,\n    metabolite_label=None,\n    phase_label=None,\n    debug=False,\n):\n    if debug == True:\n        print(\n            \"Trying: \",\n            condition_label,\n            genotype_label,\n            compartment_label,\n            metabolite_label,\n            phase_label,\n        )\n    root = tree.getroot()\n    if debug == True:\n        print(\"Got root\", end=\" \")\n    for condition in root.findall(\"{http://www.w3.org/2000/svg}g\"):\n        if condition.get(\"{http://www.inkscape.org/namespaces/inkscape}label\") == \"condition\":\n            if debug == True:\n                print(condition_label, end=\" \")\n            if genotype_label == None:\n                return conditon\n            else:\n                for genotype in condition:\n                    if genotype.get(\"{http://www.inkscape.org/namespaces/inkscape}label\") == \"genotype\":\n                        if debug == True:\n                            print(genotype_label, end=\" \")\n                        if compartment_label == None:\n                            return genotype\n                        else:\n                            for compartment in genotype:\n                                if (\n                                    compartment.get(\"{http://www.inkscape.org/namespaces/inkscape}label\")\n                                    == compartment_label\n                                ):\n                                    if debug == True:\n                                        print(compartment_label, end=\" \")\n                                    if metabolite_label == None:\n                                        return compartment\n                                    else:\n                                        for metabolite in compartment:\n                                            if (\n                                                metabolite.get(\"{http://www.inkscape.org/namespaces/inkscape}label\")\n                                                == metabolite_label\n                                            ):\n                                                if debug == True:\n                                                    print(metabolite_label, end=\" \")\n                                                if phase_label == None:\n                                                    return metabolite\n                                                else:\n                                                    for phase in metabolite:\n                                                        if (\n                                                            phase.get(\n                                                                \"{http://www.inkscape.org/namespaces/inkscape}label\"\n                                                            )\n                                                            == phase_label\n                                                        ):\n                                                            return phase\n\n\ndef updateelementopacity(element, opacity):\n    style_attribs = element.attrib[\"style\"].split(\";\")\n    for i, style in enumerate(style_attribs):\n        if re.match(r\"^opacity\", style):\n            del style_attribs[i]\n    style_attribs.append(\"opacity:\" + str(opacity))\n    element.attrib[\"style\"] = \";\".join(style_attribs)\n    return element\n\n\ndef updateelementheight(element, height):\n    try:\n        element.attrib[\"height\"]\n        element.attrib[\"height\"] = str(height)\n    except:\n        element.attrib[\"d\"] = (\n            element.attrib[\"d\"].split(\"v\")[0] + \"v -\" + str(height) + \" h\" + element.attrib[\"d\"].split(\"h\")[1]\n        )\n    return element\n\n\ndef updatetextnames(tree, condition_label, genotype_label, debug=False):\n    root = tree.getroot()\n    for condition in root.findall(\"{http://www.w3.org/2000/svg}g\"):\n        if condition.get(\"{http://www.inkscape.org/namespaces/inkscape}label\") == \"condition\":\n            for genotype in condition:\n                if genotype.get(\"{http://www.inkscape.org/namespaces/inkscape}label\") == \"condition_name\":\n                    for tspan in genotype:\n                        tspan.text = condition_label\n                        if debug == True:\n                            print(\"Condition label changed to \" + tspan.text)\n                elif genotype.get(\"{http://www.inkscape.org/namespaces/inkscape}label\") == \"genotype\":\n                    for compartment in genotype:\n                        if compartment.get(\"{http://www.inkscape.org/namespaces/inkscape}label\") == \"genotype_name\":\n                            for tspan in compartment:\n                                tspan.text = genotype_label\n                                if debug == True:\n                                    print(\"Genotype label changed to \" + tspan.text)\n                                return root\n\n\nparameters_df = pd.read_csv(\"../inputs/arabidopsis_parameters.csv\", index_col=0)\nfour_stage_GC_model = cobra.io.sbml.read_sbml_model(\"../models/4_stage_GC.xml\")  # read model\narabidopsis_supermodel = SuperModel(parameters_df.loc[:, \"Value\"], fba_model=four_stage_GC_model);\n\nNo objective coefficients in model. Unclear what should be optimized",
    "crumbs": [
      "Solving and analysing specific scenarios for paper",
      "Analysing solutions"
    ]
  },
  {
    "objectID": "2.2_analysingsolutions.html#import-solutions-and-set-up-dataframes",
    "href": "2.2_analysingsolutions.html#import-solutions-and-set-up-dataframes",
    "title": "Analysing solutions",
    "section": "Import solutions and set up dataframes",
    "text": "Import solutions and set up dataframes\n\nsolutions_dict = {\n    file[:-4]: pd.read_csv(f\"../outputs/model_solutions/{file}\", index_col=0)\n    for file in os.listdir(\"../outputs/model_solutions\")\n    if file.endswith(\".csv\")\n}\n\n\nCheck we’re in a good range for the solver\n\nmaxes = {}\nmins = {}\nfor name, solution in solutions_dict.items():\n    maxes[name] = abs(solution.loc[:, \"fluxes\"]).max()\n    mins[name] = abs(solution.loc[:, \"fluxes\"][abs(solution.loc[:, \"fluxes\"]) &gt; 10**-7]).min()\n\n\nmins\n\n{'blue_constrained_wt': 4.31244284473815e-06,\n 'blue_constrained_starchko': 4.291294149081833e-06,\n 'white_unconstrained_starchko': 8.359240012413899e-07,\n 'nops_unconstrained_wt': 2.7073713978167244e-06,\n 'blue_unconstrained_wt': 3.6707915071407277e-07,\n 'blue_unconstrained_starchko': 8.34944986206833e-07,\n 'nops_constrained_wt': 4.969355485606848e-06,\n 'white_unconstrained_wt': 5.523520793885328e-07,\n 'white_constrained_wt': 4.281246479161383e-06,\n 'white_constrained_starchko': 4.2812129271807015e-06,\n 'nops_constrained_starchko': 5.607231189748266e-06,\n 'nops_unconstrained_starchko': 2.708509015023009e-06}\n\n\n\nabs(\n    solutions_dict[\"blue_unconstrained_wt\"].loc[:, \"fluxes\"][\n        abs(solutions_dict[\"blue_unconstrained_wt\"].loc[:, \"fluxes\"]) &gt; 10**-7\n    ]\n).sort_values()\n\nMALTOSE_c_gc_Linker_3                             3.670792e-07\nMALTOSE_c_gc_Linker_1                             3.670792e-07\nMALTOSE_c_gc_Linker_2                             3.670792e-07\nPGLUCISOM_RXN_c_gc_1                              3.004235e-06\n6PFRUCTPHOS_RXN_c_gc_1                            3.004235e-06\n                                                      ...     \nPLASTOQUINOL_PLASTOCYANIN_REDUCTASE_RXN_p_me_3    1.214954e+02\nRXN490_3650_p_me_3                                2.429908e+02\nPhoton_tx_me_3                                    4.859816e+02\nPhoton_ep_me_3                                    4.859816e+02\nEX_X_Photon_t_me_3                                4.859816e+02\nName: fluxes, Length: 1136, dtype: float64\n\n\n\nabs(\n    solutions_dict[\"blue_unconstrained_starchko\"].loc[:, \"fluxes\"][\n        abs(solutions_dict[\"blue_unconstrained_starchko\"].loc[:, \"fluxes\"]) &gt; 10**-7\n    ]\n).sort_values()\n\nPROTON_ATPase_c_gc_4                              8.349450e-07\nCl_PROTON_ec_gc_4                                 8.349450e-07\nCl_a_tx_4                                         1.669890e-06\nK_a_tx_4                                          1.669890e-06\nCl_ae_gc_4                                        1.669890e-06\n                                                      ...     \nPLASTOQUINOL_PLASTOCYANIN_REDUCTASE_RXN_p_me_3    1.214954e+02\nRXN490_3650_p_me_3                                2.429908e+02\nPhoton_tx_me_3                                    4.859816e+02\nPhoton_ep_me_3                                    4.859816e+02\nEX_X_Photon_t_me_3                                4.859816e+02\nName: fluxes, Length: 1133, dtype: float64\n\n\nWith solver tolerance of 10e-7 we treat any fluxes below that value as being effectively 0, and this doesn’t include any fluxes we’re interested in. They’re 10-5 and above, so there is a difference of two orders of magnitude.\n\nconditions_permutations = [\n    [\"blue\", \"white\", \"nops\"],\n    [\"unconstrained\", \"constrained\"],\n    [\"wt\", \"starchko\"],\n    [\"fluxes\", \"minimum\", \"maximum\"],\n]\n\nsolutions_df_columns = pd.MultiIndex.from_product(\n    conditions_permutations, names=[\"Light\", \"ATPase\", \"Starch\", \"Solution\"]\n)\nsolutions_df = pd.DataFrame(columns=solutions_df_columns)\n\nconditions_list_of_lists = [\n    [\"blue\", \"white\", \"nops\"],\n    [\"unconstrained\", \"constrained\"],\n    [\"wt\", \"starchko\"],\n]\nconditions_iterations = list(itertools.product(*conditions_list_of_lists))\n\ncols_to_drop = []\nfor conditions in conditions_iterations:\n    light_condition, atpase_condition, starch_condition = conditions\n    file_name = f\"../outputs/model_solutions/{light_condition}_{atpase_condition}_{starch_condition}.csv\"\n    try:\n        condition_df = pd.read_csv(file_name, index_col=0)\n        for col in [\"fluxes\", \"minimum\", \"maximum\"]:\n            solutions_df.loc[:, (light_condition, atpase_condition, starch_condition, col)] = condition_df.loc[:, col]\n    except:\n        cols_to_drop.append(conditions)\n        print(f\"File {file_name} doesn't exist, skipping\")\n\n\nsolutions_df_unphased = solutions_df.copy()\nindex_phased = pd.MultiIndex.from_tuples(\n    [\n        (reaction[:-2], int(reaction[-1])) if reaction[-1] in [\"1\", \"2\", \"3\", \"4\"] else (reaction, None)\n        for reaction in solutions_df.index\n    ],\n    names=[\"Reaction\", \"Phase\"],\n)\nsolutions_df.index = index_phased\n\nsolutions_df = solutions_df.mask(abs(solutions_df) &lt; 10**-7, 0)  # drop fluxes below 10^-8\n\nsolutions_df = solutions_df.drop(cols_to_drop, axis=1)\n\n/tmp/ipykernel_5280/3555352746.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[:, (light_condition, atpase_condition, starch_condition, col)] = condition_df.loc[:, col]\n/tmp/ipykernel_5280/3555352746.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[:, (light_condition, atpase_condition, starch_condition, col)] = condition_df.loc[:, col]\n/tmp/ipykernel_5280/3555352746.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[:, (light_condition, atpase_condition, starch_condition, col)] = condition_df.loc[:, col]\n/tmp/ipykernel_5280/3555352746.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[:, (light_condition, atpase_condition, starch_condition, col)] = condition_df.loc[:, col]\n/tmp/ipykernel_5280/3555352746.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[:, (light_condition, atpase_condition, starch_condition, col)] = condition_df.loc[:, col]\n/tmp/ipykernel_5280/3555352746.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[:, (light_condition, atpase_condition, starch_condition, col)] = condition_df.loc[:, col]\n/tmp/ipykernel_5280/3555352746.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[:, (light_condition, atpase_condition, starch_condition, col)] = condition_df.loc[:, col]\n/tmp/ipykernel_5280/3555352746.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[:, (light_condition, atpase_condition, starch_condition, col)] = condition_df.loc[:, col]\n/tmp/ipykernel_5280/3555352746.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[:, (light_condition, atpase_condition, starch_condition, col)] = condition_df.loc[:, col]\n/tmp/ipykernel_5280/3555352746.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[:, (light_condition, atpase_condition, starch_condition, col)] = condition_df.loc[:, col]\n/tmp/ipykernel_5280/3555352746.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[:, (light_condition, atpase_condition, starch_condition, col)] = condition_df.loc[:, col]\n/tmp/ipykernel_5280/3555352746.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[:, (light_condition, atpase_condition, starch_condition, col)] = condition_df.loc[:, col]\n\n\n\nfilter_df = solutions_df.filter(like='fluxes', axis=1)\nfilter_df = filter_df[filter_df.index.get_level_values(0).str.contains('gc_Linker')]\nfilter_df\n\n# Get the unique first-level indices\nunique_first_level_indices = filter_df.index.get_level_values('Reaction').unique()\n\n# Define a threshold\nthreshold = 1e-7  # You can adjust this value to your desired threshold\n\n# Check if the values within each group are within the threshold\nfor idx in unique_first_level_indices:\n    group = filter_df.xs(key=idx, level='Reaction')\n    if (group &lt;= (group.iloc[0] + threshold)).all().all() and (group &gt;= (group.iloc[0] - threshold)).all().all():\n        #print(f\"Values for First_Level '{idx}' are within the threshold.\")\n        pass\n    else:\n        print(f\"Values for First_Level '{idx}' are not within the threshold.\")\n        #print(filter_df.loc[idx])\n\nValues for First_Level 'CIT_c_gc_Linker' are not within the threshold.\nValues for First_Level 'Cl_c_gc_Linker' are not within the threshold.\nValues for First_Level 'FRU_c_gc_Linker' are not within the threshold.\nValues for First_Level 'GLC_c_gc_Linker' are not within the threshold.\nValues for First_Level 'K_c_gc_Linker' are not within the threshold.\nValues for First_Level 'MAL_c_gc_Linker' are not within the threshold.\nValues for First_Level 'SUCROSE_c_gc_Linker' are not within the threshold.\nValues for First_Level 'Cl_v_gc_Linker' are not within the threshold.\nValues for First_Level 'FRU_v_gc_Linker' are not within the threshold.\nValues for First_Level 'GLC_v_gc_Linker' are not within the threshold.\nValues for First_Level 'K_v_gc_Linker' are not within the threshold.\nValues for First_Level 'MAL_v_gc_Linker' are not within the threshold.\nValues for First_Level 'SUCROSE_v_gc_Linker' are not within the threshold.\nValues for First_Level 'aMAL_v_gc_Linker' are not within the threshold.\nValues for First_Level 'STARCH_p_gc_Linker' are not within the threshold.\nValues for First_Level 'MALTOSE_c_gc_Linker' are not within the threshold.",
    "crumbs": [
      "Solving and analysing specific scenarios for paper",
      "Analysing solutions"
    ]
  },
  {
    "objectID": "2.2_analysingsolutions.html#plotting-linker-fluxes",
    "href": "2.2_analysingsolutions.html#plotting-linker-fluxes",
    "title": "Analysing solutions",
    "section": "Plotting Linker fluxes",
    "text": "Plotting Linker fluxes\nAll gc osmolytes\n\ndef get_linkers_df(\n    solutions_df,\n    concentrations=True,\n    osmolytes_path=\"../inputs/osmolytes.csv\",\n    SuperModel=None,\n):\n    osmolytes = pd.read_csv(osmolytes_path, index_col=0)\n    gc_osmolytes = [os for os in osmolytes.index if os[-2:] == \"gc\"]\n    gc_osmolytes_linker_reactions = [os + \"_Linker\" for os in gc_osmolytes]\n\n    linkers_df = solutions_df.loc[gc_osmolytes_linker_reactions].copy()\n\n    linkers_df = convert_phases_to_times(linkers_df)\n\n    if concentrations == True:\n        linkers_df = linkers_df.apply(convert_to_conc, args=([SuperModel]), axis=1)\n\n    linkers_df = linkers_df.reorder_levels([\"Phase\", \"Reaction\"]).sort_index()\n\n    index_key = {\"p\": \"Chloroplast\", \"v\": \"Vacuole\", \"c\": \"Cytoplasm\"}\n\n    linkers_df.index = pd.MultiIndex.from_tuples(\n        [\n            (\n                index[0],\n                \"_\".join(index[1].split(\"_\")[:-3]),\n                index_key[index[1].split(\"_\")[-3]],\n            )\n            for index in linkers_df.index\n        ],\n        names=linkers_df.index.names + [\"Compartment\"],\n    )\n\n    return linkers_df\n\n\nlinkers_df = get_linkers_df(solutions_df, SuperModel=arabidopsis_supermodel)\n\n/tmp/ipykernel_5280/2463702405.py:4: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append(pd.concat([df.loc[24]], keys=[0]))\n\n\n\nlinkers_df.loc[(slice(None), 'MAL', slice(None))]\n\n\n\n\n\n\n\n\nLight\nblue\n...\nnops\n\n\n\nATPase\nunconstrained\nconstrained\n...\nunconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\n...\nwt\nstarchko\nwt\nstarchko\n\n\n\nSolution\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\n...\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\n\n\nPhase\nCompartment\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\nCytoplasm\n6.661263\nNaN\nNaN\n0.000000\nNaN\nNaN\n5.505091\nNaN\nNaN\n1.772218\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nVacuole\n17.944579\nNaN\nNaN\n22.517698\nNaN\nNaN\n7.671832\nNaN\nNaN\n5.746564\n...\nNaN\n7.528567\nNaN\nNaN\n0.000000\nNaN\nNaN\n7.659888\nNaN\nNaN\n\n\n6.0\nCytoplasm\n0.000000\n0.0\n59.527114\n0.000000\n0.0\n59.527114\n0.000000\n0.0\n59.527114\n0.000000\n...\n59.527114\n0.000000\n0.0\n59.527114\n0.000000\n0.0\n59.527114\n0.000000\n0.0\n0.000000\n\n\nVacuole\n17.944579\n0.0\n46.298866\n22.517698\n0.0\n46.298866\n7.671832\n0.0\n46.298866\n5.746564\n...\n46.298866\n7.528567\n0.0\n46.298866\n0.000000\n0.0\n46.298866\n7.659888\n0.0\n46.298866\n\n\n6.5\nCytoplasm\n70.356673\n0.0\n72.147605\n71.629349\n0.0\n58.166494\n37.324187\n0.0\n72.147605\n27.957588\n...\n72.147605\n36.627203\n0.0\n72.147605\n14.534914\n0.0\n72.147605\n37.266089\n0.0\n58.166494\n\n\nVacuole\n0.000000\n0.0\n56.114804\n0.000000\n0.0\n56.114804\n0.000000\n0.0\n56.114804\n0.000000\n...\n56.114804\n0.000000\n0.0\n56.114804\n0.000000\n0.0\n56.114804\n0.000000\n0.0\n56.114804\n\n\n18.0\nCytoplasm\n15.283172\nNaN\nNaN\n0.000000\nNaN\nNaN\n14.874878\nNaN\nNaN\n11.142004\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nVacuole\n17.944579\nNaN\nNaN\n22.517698\nNaN\nNaN\n7.671832\nNaN\nNaN\n5.746564\n...\nNaN\n7.528567\nNaN\nNaN\n0.000000\nNaN\nNaN\n7.659888\nNaN\nNaN\n\n\n24.0\nCytoplasm\n6.661263\nNaN\nNaN\n0.000000\nNaN\nNaN\n5.505091\nNaN\nNaN\n1.772218\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nVacuole\n17.944579\nNaN\nNaN\n22.517698\nNaN\nNaN\n7.671832\nNaN\nNaN\n5.746564\n...\nNaN\n7.528567\nNaN\nNaN\n0.000000\nNaN\nNaN\n7.659888\nNaN\nNaN\n\n\n\n\n10 rows × 36 columns\n\n\n\n\n# Combine metabolites with multiple charges (MAL, CIT, HIS) in linkers_df\nmets_to_combine = ['aCIT', 'aMAL', 'bHIS']\nfor idx in linkers_df.index:\n    if idx[1] in mets_to_combine:\n        main_met_idx = (idx[0], idx[1][1:], idx[2])\n        linkers_df.loc[main_met_idx] = linkers_df.loc[main_met_idx] + linkers_df.loc[idx]\n        linkers_df = linkers_df.drop(idx)\n\n\nlinkers_df.loc[(slice(None), 'MAL', slice(None))]\n\n\n\n\n\n\n\n\nLight\nblue\n...\nnops\n\n\n\nATPase\nunconstrained\nconstrained\n...\nunconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\n...\nwt\nstarchko\nwt\nstarchko\n\n\n\nSolution\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\n...\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\n\n\nPhase\nCompartment\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\nCytoplasm\n6.661263\nNaN\nNaN\n0.000000\nNaN\nNaN\n5.505091\nNaN\nNaN\n1.772218\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nVacuole\n25.635113\nNaN\nNaN\n32.168140\nNaN\nNaN\n10.959760\nNaN\nNaN\n8.209377\n...\nNaN\n10.755095\nNaN\nNaN\n0.000000\nNaN\nNaN\n10.942697\nNaN\nNaN\n\n\n6.0\nCytoplasm\n0.000000\n0.0\n59.527114\n0.000000\n0.0\n59.527114\n0.000000\n0.0\n59.527114\n0.000000\n...\n59.527114\n0.000000\n0.0\n59.527114\n0.000000\n0.0\n59.527114\n0.000000\n0.0\n0.000000\n\n\nVacuole\n25.635113\n0.0\n66.141238\n32.168140\n0.0\n66.141238\n10.959760\n0.0\n66.141238\n8.209377\n...\n66.141238\n10.755095\n0.0\n66.141238\n0.000000\n0.0\n66.141238\n10.942697\n0.0\n66.141238\n\n\n6.5\nCytoplasm\n70.356673\n0.0\n72.147605\n71.629349\n0.0\n58.166494\n37.324187\n0.0\n72.147605\n27.957588\n...\n72.147605\n36.627203\n0.0\n72.147605\n14.534914\n0.0\n72.147605\n37.266089\n0.0\n58.166494\n\n\nVacuole\n0.000000\n0.0\n80.164005\n0.000000\n0.0\n80.164005\n0.000000\n0.0\n80.164005\n0.000000\n...\n80.164005\n0.000000\n0.0\n80.164005\n0.000000\n0.0\n80.164005\n0.000000\n0.0\n80.164005\n\n\n18.0\nCytoplasm\n15.283172\nNaN\nNaN\n0.000000\nNaN\nNaN\n14.874878\nNaN\nNaN\n11.142004\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nVacuole\n25.635113\nNaN\nNaN\n32.168140\nNaN\nNaN\n10.959760\nNaN\nNaN\n8.209377\n...\nNaN\n10.755095\nNaN\nNaN\n0.000000\nNaN\nNaN\n10.942697\nNaN\nNaN\n\n\n24.0\nCytoplasm\n6.661263\nNaN\nNaN\n0.000000\nNaN\nNaN\n5.505091\nNaN\nNaN\n1.772218\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nVacuole\n25.635113\nNaN\nNaN\n32.168140\nNaN\nNaN\n10.959760\nNaN\nNaN\n8.209377\n...\nNaN\n10.755095\nNaN\nNaN\n0.000000\nNaN\nNaN\n10.942697\nNaN\nNaN\n\n\n\n\n10 rows × 36 columns\n\n\n\n\nmet_df_mm = get_metabolite_df(solutions_df, SuperModel=arabidopsis_supermodel)\n\n/tmp/ipykernel_5280/2463702405.py:4: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append(pd.concat([df.loc[24]], keys=[0]))\n\n\n\nmet_df_mm\n\n\n\n\n\n\n\n\nLight\nblue\n...\nnops\n\n\n\nATPase\nunconstrained\nconstrained\n...\nunconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\n...\nwt\nstarchko\nwt\nstarchko\n\n\n\nSolution\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\n...\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\n\n\nPhase\nReaction\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\nCIT\n1.431237\nNaN\nNaN\n0.000000\nNaN\nNaN\n1.555385\nNaN\nNaN\n1.555385\n...\nNaN\n2.423123\nNaN\nNaN\n2.777890\nNaN\nNaN\n2.465388\nNaN\nNaN\n\n\nCl\n16.524279\nNaN\nNaN\n21.954453\nNaN\nNaN\n13.391074\nNaN\nNaN\n0.718695\n...\nNaN\n2.969559\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nFRU\n0.000000\nNaN\nNaN\n0.458382\nNaN\nNaN\n0.659272\nNaN\nNaN\n0.658861\n...\nNaN\n0.637511\nNaN\nNaN\n0.672046\nNaN\nNaN\n0.989743\nNaN\nNaN\n\n\nGLC\n0.633834\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nK\n24.135299\nNaN\nNaN\n21.955092\nNaN\nNaN\n20.798763\nNaN\nNaN\n6.267413\n...\nNaN\n10.238928\nNaN\nNaN\n8.333669\nNaN\nNaN\n7.396173\nNaN\nNaN\n\n\nMAL\n20.910624\nNaN\nNaN\n24.158592\nNaN\nNaN\n9.601548\nNaN\nNaN\n6.606525\n...\nNaN\n8.077077\nNaN\nNaN\n0.000000\nNaN\nNaN\n8.217966\nNaN\nNaN\n\n\nSTARCH\n0.000244\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.005126\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.002569\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nSUCROSE\n0.000000\nNaN\nNaN\n0.098507\nNaN\nNaN\n7.881207\nNaN\nNaN\n31.139004\n...\nNaN\n0.637511\nNaN\nNaN\n18.115847\nNaN\nNaN\n30.149261\nNaN\nNaN\n\n\n6.0\nCIT\n2.537007\n0.0\n49.435142\n0.000000\n0.0\n49.435142\n2.469230\n0.0\n49.435142\n1.849573\n...\n49.435142\n2.423123\n0.0\n49.435142\n2.777890\n0.0\n49.435142\n2.465388\n0.0\n49.435142\n\n\nCl\n16.524279\n0.0\n89.290671\n22.232898\n0.0\n89.290671\n13.949171\n0.0\n89.290671\n1.121672\n...\n89.290671\n2.969559\n0.0\n89.290671\n0.000000\n0.0\n89.290671\n0.000000\n0.0\n80.403347\n\n\nFRU\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n...\n178.581341\n1.275022\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n160.500964\n\n\nGLC\n1.268503\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n...\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n160.500964\n\n\nK\n24.135299\n0.0\n140.262888\n22.233537\n0.0\n140.262888\n21.356860\n0.0\n140.262888\n6.670390\n...\n140.262888\n10.238928\n0.0\n140.262888\n8.333669\n0.0\n140.262888\n7.396173\n0.0\n133.708937\n\n\nMAL\n19.251970\n0.0\n64.494321\n24.158592\n0.0\n64.494321\n8.230780\n0.0\n64.494321\n6.165242\n...\n64.494321\n8.077077\n0.0\n64.494321\n0.000000\n0.0\n64.494321\n8.217966\n0.0\n64.494321\n\n\nSTARCH\n0.000000\n0.0\n1000.000000\n0.000000\n0.0\n0.000000\n0.005126\n0.0\n0.285304\n0.000000\n...\n1000.000000\n0.000000\n0.0\n0.000000\n0.002569\n0.0\n0.232884\n0.000000\n0.0\n0.000000\n\n\nSUCROSE\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n7.881207\n0.0\n178.581341\n31.139004\n...\n178.581341\n0.000000\n0.0\n178.581341\n18.787893\n0.0\n178.581341\n31.139004\n0.0\n178.581341\n\n\n6.5\nCIT\n0.000000\n0.0\n44.869080\n0.000000\n0.0\n44.869080\n0.000000\n0.0\n44.869080\n0.000000\n...\n44.869080\n0.000000\n0.0\n44.869080\n0.000000\n0.0\n44.869080\n0.000000\n0.0\n39.265593\n\n\nCl\n45.604537\n0.0\n108.221407\n51.357528\n0.0\n108.221407\n29.258708\n0.0\n94.698182\n18.117110\n...\n108.221407\n32.501177\n0.0\n108.221407\n17.142857\n0.0\n94.698182\n17.142857\n0.0\n86.978907\n\n\nFRU\n0.000000\n0.0\n216.442814\n0.000000\n0.0\n216.442814\n6.845391\n0.0\n216.442814\n27.046449\n...\n216.442814\n1.365608\n0.0\n216.442814\n16.318627\n0.0\n216.442814\n27.046449\n0.0\n216.442814\n\n\nGLC\n1.101786\n0.0\n216.442814\n0.000000\n0.0\n216.442814\n27.046452\n0.0\n216.442814\n27.046449\n...\n216.442814\n0.000000\n0.0\n216.442814\n25.840051\n0.0\n216.442814\n27.046449\n0.0\n216.442814\n\n\nK\n52.215252\n0.0\n152.876211\n51.358083\n0.0\n152.876211\n35.692816\n0.0\n138.971194\n22.936568\n...\n152.876211\n38.815143\n0.0\n152.876211\n24.381244\n0.0\n138.971194\n23.566961\n0.0\n133.278620\n\n\nMAL\n17.518812\n0.0\n65.116825\n17.835708\n0.0\n65.116825\n9.293723\n0.0\n65.116825\n6.961439\n...\n65.116825\n9.120173\n0.0\n65.116825\n3.619193\n0.0\n65.116825\n9.279256\n0.0\n62.386555\n\n\nSTARCH\n0.000000\n0.0\n0.000000\n0.000000\n0.0\n0.000000\n0.000000\n0.0\n0.000000\n0.000000\n...\n0.000000\n0.000000\n0.0\n0.000000\n0.000000\n0.0\n0.099952\n0.000000\n0.0\n0.000000\n\n\nSUCROSE\n0.234594\n0.0\n216.442814\n0.386397\n0.0\n216.442814\n0.000000\n0.0\n216.442814\n0.000000\n...\n216.442814\n1.230198\n0.0\n216.442814\n0.000000\n0.0\n216.442814\n0.000000\n0.0\n138.990025\n\n\n18.0\nCIT\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n2.423123\nNaN\nNaN\n2.777890\nNaN\nNaN\n2.465388\nNaN\nNaN\n\n\nCl\n16.524279\nNaN\nNaN\n21.908994\nNaN\nNaN\n12.672379\nNaN\nNaN\n0.000000\n...\nNaN\n2.969559\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nFRU\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n1.318969\nNaN\nNaN\n1.318558\n...\nNaN\n0.000000\nNaN\nNaN\n1.906201\nNaN\nNaN\n1.979486\nNaN\nNaN\n\n\nGLC\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nK\n24.135299\nNaN\nNaN\n21.909632\nNaN\nNaN\n20.080068\nNaN\nNaN\n5.548718\n...\nNaN\n10.238928\nNaN\nNaN\n8.333669\nNaN\nNaN\n7.396173\nNaN\nNaN\n\n\nMAL\n23.057480\nNaN\nNaN\n24.158273\nNaN\nNaN\n11.934624\nNaN\nNaN\n8.939601\n...\nNaN\n8.077077\nNaN\nNaN\n0.000000\nNaN\nNaN\n8.217966\nNaN\nNaN\n\n\nSTARCH\n0.000559\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.005126\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.002455\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nSUCROSE\n0.000000\nNaN\nNaN\n0.647915\nNaN\nNaN\n7.881207\nNaN\nNaN\n31.139004\n...\nNaN\n1.275022\nNaN\nNaN\n16.881692\nNaN\nNaN\n29.159518\nNaN\nNaN\n\n\n24.0\nCIT\n1.431237\nNaN\nNaN\n0.000000\nNaN\nNaN\n1.555385\nNaN\nNaN\n1.555385\n...\nNaN\n2.423123\nNaN\nNaN\n2.777890\nNaN\nNaN\n2.465388\nNaN\nNaN\n\n\nCl\n16.524279\nNaN\nNaN\n21.954453\nNaN\nNaN\n13.391074\nNaN\nNaN\n0.718695\n...\nNaN\n2.969559\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nFRU\n0.000000\nNaN\nNaN\n0.458382\nNaN\nNaN\n0.659272\nNaN\nNaN\n0.658861\n...\nNaN\n0.637511\nNaN\nNaN\n0.672046\nNaN\nNaN\n0.989743\nNaN\nNaN\n\n\nGLC\n0.633834\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nK\n24.135299\nNaN\nNaN\n21.955092\nNaN\nNaN\n20.798763\nNaN\nNaN\n6.267413\n...\nNaN\n10.238928\nNaN\nNaN\n8.333669\nNaN\nNaN\n7.396173\nNaN\nNaN\n\n\nMAL\n20.910624\nNaN\nNaN\n24.158592\nNaN\nNaN\n9.601548\nNaN\nNaN\n6.606525\n...\nNaN\n8.077077\nNaN\nNaN\n0.000000\nNaN\nNaN\n8.217966\nNaN\nNaN\n\n\nSTARCH\n0.000244\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.005126\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.002569\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nSUCROSE\n0.000000\nNaN\nNaN\n0.098507\nNaN\nNaN\n7.881207\nNaN\nNaN\n31.139004\n...\nNaN\n0.637511\nNaN\nNaN\n18.115847\nNaN\nNaN\n30.149261\nNaN\nNaN\n\n\n\n\n40 rows × 36 columns\n\n\n\n\nordered_index = []\nfor phase in [0.0, 6.0, 6.5, 18.0, 24.0]:\n    for met in [\"K\", \"Cl\", \"SUCROSE\", \"GLC\", \"FRU\", \"MAL\", \"CIT\", \"STARCH\"]:\n        ordered_index.append((phase, met))\npd.MultiIndex.from_tuples(ordered_index)\nmet_df_mm = met_df_mm.reindex(ordered_index)\nmet_df_mm\n\n\n\n\n\n\n\n\nLight\nblue\n...\nnops\n\n\n\nATPase\nunconstrained\nconstrained\n...\nunconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\n...\nwt\nstarchko\nwt\nstarchko\n\n\n\nSolution\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\n...\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\n\n\nPhase\nReaction\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\nK\n24.135299\nNaN\nNaN\n21.955092\nNaN\nNaN\n20.798763\nNaN\nNaN\n6.267413\n...\nNaN\n10.238928\nNaN\nNaN\n8.333669\nNaN\nNaN\n7.396173\nNaN\nNaN\n\n\nCl\n16.524279\nNaN\nNaN\n21.954453\nNaN\nNaN\n13.391074\nNaN\nNaN\n0.718695\n...\nNaN\n2.969559\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nSUCROSE\n0.000000\nNaN\nNaN\n0.098507\nNaN\nNaN\n7.881207\nNaN\nNaN\n31.139004\n...\nNaN\n0.637511\nNaN\nNaN\n18.115847\nNaN\nNaN\n30.149261\nNaN\nNaN\n\n\nGLC\n0.633834\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nFRU\n0.000000\nNaN\nNaN\n0.458382\nNaN\nNaN\n0.659272\nNaN\nNaN\n0.658861\n...\nNaN\n0.637511\nNaN\nNaN\n0.672046\nNaN\nNaN\n0.989743\nNaN\nNaN\n\n\nMAL\n20.910624\nNaN\nNaN\n24.158592\nNaN\nNaN\n9.601548\nNaN\nNaN\n6.606525\n...\nNaN\n8.077077\nNaN\nNaN\n0.000000\nNaN\nNaN\n8.217966\nNaN\nNaN\n\n\nCIT\n1.431237\nNaN\nNaN\n0.000000\nNaN\nNaN\n1.555385\nNaN\nNaN\n1.555385\n...\nNaN\n2.423123\nNaN\nNaN\n2.777890\nNaN\nNaN\n2.465388\nNaN\nNaN\n\n\nSTARCH\n0.000244\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.005126\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.002569\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\n6.0\nK\n24.135299\n0.0\n140.262888\n22.233537\n0.0\n140.262888\n21.356860\n0.0\n140.262888\n6.670390\n...\n140.262888\n10.238928\n0.0\n140.262888\n8.333669\n0.0\n140.262888\n7.396173\n0.0\n133.708937\n\n\nCl\n16.524279\n0.0\n89.290671\n22.232898\n0.0\n89.290671\n13.949171\n0.0\n89.290671\n1.121672\n...\n89.290671\n2.969559\n0.0\n89.290671\n0.000000\n0.0\n89.290671\n0.000000\n0.0\n80.403347\n\n\nSUCROSE\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n7.881207\n0.0\n178.581341\n31.139004\n...\n178.581341\n0.000000\n0.0\n178.581341\n18.787893\n0.0\n178.581341\n31.139004\n0.0\n178.581341\n\n\nGLC\n1.268503\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n...\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n160.500964\n\n\nFRU\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n...\n178.581341\n1.275022\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n160.500964\n\n\nMAL\n19.251970\n0.0\n64.494321\n24.158592\n0.0\n64.494321\n8.230780\n0.0\n64.494321\n6.165242\n...\n64.494321\n8.077077\n0.0\n64.494321\n0.000000\n0.0\n64.494321\n8.217966\n0.0\n64.494321\n\n\nCIT\n2.537007\n0.0\n49.435142\n0.000000\n0.0\n49.435142\n2.469230\n0.0\n49.435142\n1.849573\n...\n49.435142\n2.423123\n0.0\n49.435142\n2.777890\n0.0\n49.435142\n2.465388\n0.0\n49.435142\n\n\nSTARCH\n0.000000\n0.0\n1000.000000\n0.000000\n0.0\n0.000000\n0.005126\n0.0\n0.285304\n0.000000\n...\n1000.000000\n0.000000\n0.0\n0.000000\n0.002569\n0.0\n0.232884\n0.000000\n0.0\n0.000000\n\n\n6.5\nK\n52.215252\n0.0\n152.876211\n51.358083\n0.0\n152.876211\n35.692816\n0.0\n138.971194\n22.936568\n...\n152.876211\n38.815143\n0.0\n152.876211\n24.381244\n0.0\n138.971194\n23.566961\n0.0\n133.278620\n\n\nCl\n45.604537\n0.0\n108.221407\n51.357528\n0.0\n108.221407\n29.258708\n0.0\n94.698182\n18.117110\n...\n108.221407\n32.501177\n0.0\n108.221407\n17.142857\n0.0\n94.698182\n17.142857\n0.0\n86.978907\n\n\nSUCROSE\n0.234594\n0.0\n216.442814\n0.386397\n0.0\n216.442814\n0.000000\n0.0\n216.442814\n0.000000\n...\n216.442814\n1.230198\n0.0\n216.442814\n0.000000\n0.0\n216.442814\n0.000000\n0.0\n138.990025\n\n\nGLC\n1.101786\n0.0\n216.442814\n0.000000\n0.0\n216.442814\n27.046452\n0.0\n216.442814\n27.046449\n...\n216.442814\n0.000000\n0.0\n216.442814\n25.840051\n0.0\n216.442814\n27.046449\n0.0\n216.442814\n\n\nFRU\n0.000000\n0.0\n216.442814\n0.000000\n0.0\n216.442814\n6.845391\n0.0\n216.442814\n27.046449\n...\n216.442814\n1.365608\n0.0\n216.442814\n16.318627\n0.0\n216.442814\n27.046449\n0.0\n216.442814\n\n\nMAL\n17.518812\n0.0\n65.116825\n17.835708\n0.0\n65.116825\n9.293723\n0.0\n65.116825\n6.961439\n...\n65.116825\n9.120173\n0.0\n65.116825\n3.619193\n0.0\n65.116825\n9.279256\n0.0\n62.386555\n\n\nCIT\n0.000000\n0.0\n44.869080\n0.000000\n0.0\n44.869080\n0.000000\n0.0\n44.869080\n0.000000\n...\n44.869080\n0.000000\n0.0\n44.869080\n0.000000\n0.0\n44.869080\n0.000000\n0.0\n39.265593\n\n\nSTARCH\n0.000000\n0.0\n0.000000\n0.000000\n0.0\n0.000000\n0.000000\n0.0\n0.000000\n0.000000\n...\n0.000000\n0.000000\n0.0\n0.000000\n0.000000\n0.0\n0.099952\n0.000000\n0.0\n0.000000\n\n\n18.0\nK\n24.135299\nNaN\nNaN\n21.909632\nNaN\nNaN\n20.080068\nNaN\nNaN\n5.548718\n...\nNaN\n10.238928\nNaN\nNaN\n8.333669\nNaN\nNaN\n7.396173\nNaN\nNaN\n\n\nCl\n16.524279\nNaN\nNaN\n21.908994\nNaN\nNaN\n12.672379\nNaN\nNaN\n0.000000\n...\nNaN\n2.969559\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nSUCROSE\n0.000000\nNaN\nNaN\n0.647915\nNaN\nNaN\n7.881207\nNaN\nNaN\n31.139004\n...\nNaN\n1.275022\nNaN\nNaN\n16.881692\nNaN\nNaN\n29.159518\nNaN\nNaN\n\n\nGLC\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nFRU\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n1.318969\nNaN\nNaN\n1.318558\n...\nNaN\n0.000000\nNaN\nNaN\n1.906201\nNaN\nNaN\n1.979486\nNaN\nNaN\n\n\nMAL\n23.057480\nNaN\nNaN\n24.158273\nNaN\nNaN\n11.934624\nNaN\nNaN\n8.939601\n...\nNaN\n8.077077\nNaN\nNaN\n0.000000\nNaN\nNaN\n8.217966\nNaN\nNaN\n\n\nCIT\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n2.423123\nNaN\nNaN\n2.777890\nNaN\nNaN\n2.465388\nNaN\nNaN\n\n\nSTARCH\n0.000559\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.005126\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.002455\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\n24.0\nK\n24.135299\nNaN\nNaN\n21.955092\nNaN\nNaN\n20.798763\nNaN\nNaN\n6.267413\n...\nNaN\n10.238928\nNaN\nNaN\n8.333669\nNaN\nNaN\n7.396173\nNaN\nNaN\n\n\nCl\n16.524279\nNaN\nNaN\n21.954453\nNaN\nNaN\n13.391074\nNaN\nNaN\n0.718695\n...\nNaN\n2.969559\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nSUCROSE\n0.000000\nNaN\nNaN\n0.098507\nNaN\nNaN\n7.881207\nNaN\nNaN\n31.139004\n...\nNaN\n0.637511\nNaN\nNaN\n18.115847\nNaN\nNaN\n30.149261\nNaN\nNaN\n\n\nGLC\n0.633834\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nFRU\n0.000000\nNaN\nNaN\n0.458382\nNaN\nNaN\n0.659272\nNaN\nNaN\n0.658861\n...\nNaN\n0.637511\nNaN\nNaN\n0.672046\nNaN\nNaN\n0.989743\nNaN\nNaN\n\n\nMAL\n20.910624\nNaN\nNaN\n24.158592\nNaN\nNaN\n9.601548\nNaN\nNaN\n6.606525\n...\nNaN\n8.077077\nNaN\nNaN\n0.000000\nNaN\nNaN\n8.217966\nNaN\nNaN\n\n\nCIT\n1.431237\nNaN\nNaN\n0.000000\nNaN\nNaN\n1.555385\nNaN\nNaN\n1.555385\n...\nNaN\n2.423123\nNaN\nNaN\n2.777890\nNaN\nNaN\n2.465388\nNaN\nNaN\n\n\nSTARCH\n0.000244\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.005126\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.002569\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\n\n\n40 rows × 36 columns\n\n\n\n\nmet_df = get_metabolite_df(solutions_df, concentrations=False)\n\n/tmp/ipykernel_5280/2463702405.py:4: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append(pd.concat([df.loc[24]], keys=[0]))\n\n\n\ndef plot_linkers(df, light):\n    fig, axs = plt.subplots(2, 2, figsize=(10, 10), sharex=True, sharey=True)\n    for x, atpase_condition in enumerate([\"unconstrained\", \"constrained\"]):\n        for y, starch_condition in enumerate([\"wt\", \"starchko\"]):\n            df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[\n                :, (light, atpase_condition, starch_condition)\n            ].unstack().plot(title=f\"{atpase_condition} {starch_condition}\", ax=axs[x][y])\n            starch_axis = axs[x][y].twinx()\n            (\n                df.xs(\"fluxes\", level=\"Solution\", axis=1)\n                .loc[:, (light, atpase_condition, starch_condition)]\n                .xs(\"STARCH\", level=\"Reaction\")\n            ).plot(ax=starch_axis, ylim=(0, 0.01), color=\"black\")\n            axs[x][y].get_legend().remove()\n    axs[1][0].legend(loc=\"center left\", bbox_to_anchor=(2.3, 1.1))\n\n\nfor light in [\"blue\", \"white\"]:\n    plot_linkers(met_df_mm, light)",
    "crumbs": [
      "Solving and analysing specific scenarios for paper",
      "Analysing solutions"
    ]
  },
  {
    "objectID": "2.2_analysingsolutions.html#plotting-before-and-after-opening",
    "href": "2.2_analysingsolutions.html#plotting-before-and-after-opening",
    "title": "Analysing solutions",
    "section": "Plotting before and after opening",
    "text": "Plotting before and after opening\n\ndef convert_starch_cols_to_per_gc(row_series, SuperModel, units):\n    if row_series.name[1] == \"STARCH\":\n        n_gcs = SuperModel.N_gcs\n        row_series_moles = row_series * 10**-3\n        moles_per_gc = row_series_moles / n_gcs\n        row_series_converted_to_units = moles_per_gc * (1 / units)\n\n        return row_series_converted_to_units\n\n    else:\n        return row_series\n\n\nfemtomoles = 10**-15\nmet_df_mm_starch_fmol_per_gc = met_df_mm.apply(\n    convert_starch_cols_to_per_gc, args=[arabidopsis_supermodel, femtomoles], axis=1\n)\n\n\nmet_df_mm_starch_fmol_per_gc\n\n\n\n\n\n\n\n\nLight\nblue\n...\nnops\n\n\n\nATPase\nunconstrained\nconstrained\n...\nunconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\n...\nwt\nstarchko\nwt\nstarchko\n\n\n\nSolution\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\n...\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\n\n\nPhase\nReaction\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\nK\n24.135299\nNaN\nNaN\n21.955092\nNaN\nNaN\n20.798763\nNaN\nNaN\n6.267413\n...\nNaN\n10.238928\nNaN\nNaN\n8.333669\nNaN\nNaN\n7.396173\nNaN\nNaN\n\n\nCl\n16.524279\nNaN\nNaN\n21.954453\nNaN\nNaN\n13.391074\nNaN\nNaN\n0.718695\n...\nNaN\n2.969559\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nSUCROSE\n0.000000\nNaN\nNaN\n0.098507\nNaN\nNaN\n7.881207\nNaN\nNaN\n31.139004\n...\nNaN\n0.637511\nNaN\nNaN\n18.115847\nNaN\nNaN\n30.149261\nNaN\nNaN\n\n\nGLC\n0.633834\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nFRU\n0.000000\nNaN\nNaN\n0.458382\nNaN\nNaN\n0.659272\nNaN\nNaN\n0.658861\n...\nNaN\n0.637511\nNaN\nNaN\n0.672046\nNaN\nNaN\n0.989743\nNaN\nNaN\n\n\nMAL\n20.910624\nNaN\nNaN\n24.158592\nNaN\nNaN\n9.601548\nNaN\nNaN\n6.606525\n...\nNaN\n8.077077\nNaN\nNaN\n0.000000\nNaN\nNaN\n8.217966\nNaN\nNaN\n\n\nCIT\n1.431237\nNaN\nNaN\n0.000000\nNaN\nNaN\n1.555385\nNaN\nNaN\n1.555385\n...\nNaN\n2.423123\nNaN\nNaN\n2.777890\nNaN\nNaN\n2.465388\nNaN\nNaN\n\n\nSTARCH\n0.420192\nNaN\nNaN\n0.000000\nNaN\nNaN\n8.837963\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n4.429523\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\n6.0\nK\n24.135299\n0.0\n1.402629e+02\n22.233537\n0.0\n140.262888\n21.356860\n0.0\n140.262888\n6.670390\n...\n1.402629e+02\n10.238928\n0.0\n140.262888\n8.333669\n0.0\n140.262888\n7.396173\n0.0\n133.708937\n\n\nCl\n16.524279\n0.0\n8.929067e+01\n22.232898\n0.0\n89.290671\n13.949171\n0.0\n89.290671\n1.121672\n...\n8.929067e+01\n2.969559\n0.0\n89.290671\n0.000000\n0.0\n89.290671\n0.000000\n0.0\n80.403347\n\n\nSUCROSE\n0.000000\n0.0\n1.785813e+02\n0.000000\n0.0\n178.581341\n7.881207\n0.0\n178.581341\n31.139004\n...\n1.785813e+02\n0.000000\n0.0\n178.581341\n18.787893\n0.0\n178.581341\n31.139004\n0.0\n178.581341\n\n\nGLC\n1.268503\n0.0\n1.785813e+02\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n...\n1.785813e+02\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n160.500964\n\n\nFRU\n0.000000\n0.0\n1.785813e+02\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n...\n1.785813e+02\n1.275022\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n160.500964\n\n\nMAL\n19.251970\n0.0\n6.449432e+01\n24.158592\n0.0\n64.494321\n8.230780\n0.0\n64.494321\n6.165242\n...\n6.449432e+01\n8.077077\n0.0\n64.494321\n0.000000\n0.0\n64.494321\n8.217966\n0.0\n64.494321\n\n\nCIT\n2.537007\n0.0\n4.943514e+01\n0.000000\n0.0\n49.435142\n2.469230\n0.0\n49.435142\n1.849573\n...\n4.943514e+01\n2.423123\n0.0\n49.435142\n2.777890\n0.0\n49.435142\n2.465388\n0.0\n49.435142\n\n\nSTARCH\n0.000000\n0.0\n1.724138e+06\n0.000000\n0.0\n0.000000\n8.837963\n0.0\n491.903125\n0.000000\n...\n1.724138e+06\n0.000000\n0.0\n0.000000\n4.429523\n0.0\n401.523796\n0.000000\n0.0\n0.000000\n\n\n6.5\nK\n52.215252\n0.0\n1.528762e+02\n51.358083\n0.0\n152.876211\n35.692816\n0.0\n138.971194\n22.936568\n...\n1.528762e+02\n38.815143\n0.0\n152.876211\n24.381244\n0.0\n138.971194\n23.566961\n0.0\n133.278620\n\n\nCl\n45.604537\n0.0\n1.082214e+02\n51.357528\n0.0\n108.221407\n29.258708\n0.0\n94.698182\n18.117110\n...\n1.082214e+02\n32.501177\n0.0\n108.221407\n17.142857\n0.0\n94.698182\n17.142857\n0.0\n86.978907\n\n\nSUCROSE\n0.234594\n0.0\n2.164428e+02\n0.386397\n0.0\n216.442814\n0.000000\n0.0\n216.442814\n0.000000\n...\n2.164428e+02\n1.230198\n0.0\n216.442814\n0.000000\n0.0\n216.442814\n0.000000\n0.0\n138.990025\n\n\nGLC\n1.101786\n0.0\n2.164428e+02\n0.000000\n0.0\n216.442814\n27.046452\n0.0\n216.442814\n27.046449\n...\n2.164428e+02\n0.000000\n0.0\n216.442814\n25.840051\n0.0\n216.442814\n27.046449\n0.0\n216.442814\n\n\nFRU\n0.000000\n0.0\n2.164428e+02\n0.000000\n0.0\n216.442814\n6.845391\n0.0\n216.442814\n27.046449\n...\n2.164428e+02\n1.365608\n0.0\n216.442814\n16.318627\n0.0\n216.442814\n27.046449\n0.0\n216.442814\n\n\nMAL\n17.518812\n0.0\n6.511682e+01\n17.835708\n0.0\n65.116825\n9.293723\n0.0\n65.116825\n6.961439\n...\n6.511682e+01\n9.120173\n0.0\n65.116825\n3.619193\n0.0\n65.116825\n9.279256\n0.0\n62.386555\n\n\nCIT\n0.000000\n0.0\n4.486908e+01\n0.000000\n0.0\n44.869080\n0.000000\n0.0\n44.869080\n0.000000\n...\n4.486908e+01\n0.000000\n0.0\n44.869080\n0.000000\n0.0\n44.869080\n0.000000\n0.0\n39.265593\n\n\nSTARCH\n0.000000\n0.0\n0.000000e+00\n0.000000\n0.0\n0.000000\n0.000000\n0.0\n0.000000\n0.000000\n...\n0.000000e+00\n0.000000\n0.0\n0.000000\n0.000000\n0.0\n172.331230\n0.000000\n0.0\n0.000000\n\n\n18.0\nK\n24.135299\nNaN\nNaN\n21.909632\nNaN\nNaN\n20.080068\nNaN\nNaN\n5.548718\n...\nNaN\n10.238928\nNaN\nNaN\n8.333669\nNaN\nNaN\n7.396173\nNaN\nNaN\n\n\nCl\n16.524279\nNaN\nNaN\n21.908994\nNaN\nNaN\n12.672379\nNaN\nNaN\n0.000000\n...\nNaN\n2.969559\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nSUCROSE\n0.000000\nNaN\nNaN\n0.647915\nNaN\nNaN\n7.881207\nNaN\nNaN\n31.139004\n...\nNaN\n1.275022\nNaN\nNaN\n16.881692\nNaN\nNaN\n29.159518\nNaN\nNaN\n\n\nGLC\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nFRU\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n1.318969\nNaN\nNaN\n1.318558\n...\nNaN\n0.000000\nNaN\nNaN\n1.906201\nNaN\nNaN\n1.979486\nNaN\nNaN\n\n\nMAL\n23.057480\nNaN\nNaN\n24.158273\nNaN\nNaN\n11.934624\nNaN\nNaN\n8.939601\n...\nNaN\n8.077077\nNaN\nNaN\n0.000000\nNaN\nNaN\n8.217966\nNaN\nNaN\n\n\nCIT\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n2.423123\nNaN\nNaN\n2.777890\nNaN\nNaN\n2.465388\nNaN\nNaN\n\n\nSTARCH\n0.964062\nNaN\nNaN\n0.000000\nNaN\nNaN\n8.837963\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n4.231974\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\n24.0\nK\n24.135299\nNaN\nNaN\n21.955092\nNaN\nNaN\n20.798763\nNaN\nNaN\n6.267413\n...\nNaN\n10.238928\nNaN\nNaN\n8.333669\nNaN\nNaN\n7.396173\nNaN\nNaN\n\n\nCl\n16.524279\nNaN\nNaN\n21.954453\nNaN\nNaN\n13.391074\nNaN\nNaN\n0.718695\n...\nNaN\n2.969559\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nSUCROSE\n0.000000\nNaN\nNaN\n0.098507\nNaN\nNaN\n7.881207\nNaN\nNaN\n31.139004\n...\nNaN\n0.637511\nNaN\nNaN\n18.115847\nNaN\nNaN\n30.149261\nNaN\nNaN\n\n\nGLC\n0.633834\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nFRU\n0.000000\nNaN\nNaN\n0.458382\nNaN\nNaN\n0.659272\nNaN\nNaN\n0.658861\n...\nNaN\n0.637511\nNaN\nNaN\n0.672046\nNaN\nNaN\n0.989743\nNaN\nNaN\n\n\nMAL\n20.910624\nNaN\nNaN\n24.158592\nNaN\nNaN\n9.601548\nNaN\nNaN\n6.606525\n...\nNaN\n8.077077\nNaN\nNaN\n0.000000\nNaN\nNaN\n8.217966\nNaN\nNaN\n\n\nCIT\n1.431237\nNaN\nNaN\n0.000000\nNaN\nNaN\n1.555385\nNaN\nNaN\n1.555385\n...\nNaN\n2.423123\nNaN\nNaN\n2.777890\nNaN\nNaN\n2.465388\nNaN\nNaN\n\n\nSTARCH\n0.420192\nNaN\nNaN\n0.000000\nNaN\nNaN\n8.837963\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n4.429523\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\n\n\n40 rows × 36 columns\n\n\n\n\nmet_df_mm_starch_fmol_per_gc.xs(\"STARCH\", level=\"Reaction\").xs(\"fluxes\", level=\"Solution\", axis=1)\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\nATPase\nunconstrained\nconstrained\nunconstrained\nconstrained\nunconstrained\nconstrained\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\n0.420192\n0.0\n8.837963\n0.0\n0.080389\n0.0\n9.340372\n0.0\n0.0\n0.0\n4.429523\n0.0\n\n\n6.0\n0.000000\n0.0\n8.837963\n0.0\n0.000000\n0.0\n9.340372\n0.0\n0.0\n0.0\n4.429523\n0.0\n\n\n6.5\n0.000000\n0.0\n0.000000\n0.0\n0.000000\n0.0\n0.000000\n0.0\n0.0\n0.0\n0.000000\n0.0\n\n\n18.0\n0.964062\n0.0\n8.837963\n0.0\n0.325796\n0.0\n9.340372\n0.0\n0.0\n0.0\n4.231974\n0.0\n\n\n24.0\n0.420192\n0.0\n8.837963\n0.0\n0.080389\n0.0\n9.340372\n0.0\n0.0\n0.0\n4.429523\n0.0\n\n\n\n\n\n\n\n\nfor light in [\"blue\", \"white\", \"nops\"]:\n    for atpase in [\"unconstrained\", \"constrained\"]:\n        specific_df = met_df_mm_starch_fmol_per_gc.loc[:, (light, atpase)].xs(\"fluxes\", level=\"Solution\", axis=1)\n        fig = get_totals_plot(specific_df)\n        plot_name = f\"{light}_{atpase}\"\n        fig.savefig(\n            f\"../outputs/total_opening_plots/{plot_name}.svg\",\n            format=\"svg\",\n            bbox_inches=\"tight\",\n        )\n        fig.savefig(\n            f\"../outputs/total_opening_plots/{plot_name}.png\",\n            format=\"png\",\n            bbox_inches=\"tight\",\n            dpi=300,\n        )\n\n/tmp/ipykernel_5280/3835851778.py:3: PerformanceWarning: indexing past lexsort depth may impact performance.\n  specific_df = met_df_mm_starch_fmol_per_gc.loc[:, (light, atpase)].xs(\"fluxes\", level=\"Solution\", axis=1)\n/tmp/ipykernel_5280/3835851778.py:3: PerformanceWarning: indexing past lexsort depth may impact performance.\n  specific_df = met_df_mm_starch_fmol_per_gc.loc[:, (light, atpase)].xs(\"fluxes\", level=\"Solution\", axis=1)\n/tmp/ipykernel_5280/3835851778.py:3: PerformanceWarning: indexing past lexsort depth may impact performance.\n  specific_df = met_df_mm_starch_fmol_per_gc.loc[:, (light, atpase)].xs(\"fluxes\", level=\"Solution\", axis=1)\n/tmp/ipykernel_5280/3835851778.py:3: PerformanceWarning: indexing past lexsort depth may impact performance.\n  specific_df = met_df_mm_starch_fmol_per_gc.loc[:, (light, atpase)].xs(\"fluxes\", level=\"Solution\", axis=1)\n/tmp/ipykernel_5280/3835851778.py:3: PerformanceWarning: indexing past lexsort depth may impact performance.\n  specific_df = met_df_mm_starch_fmol_per_gc.loc[:, (light, atpase)].xs(\"fluxes\", level=\"Solution\", axis=1)\n/tmp/ipykernel_5280/3835851778.py:3: PerformanceWarning: indexing past lexsort depth may impact performance.\n  specific_df = met_df_mm_starch_fmol_per_gc.loc[:, (light, atpase)].xs(\"fluxes\", level=\"Solution\", axis=1)",
    "crumbs": [
      "Solving and analysing specific scenarios for paper",
      "Analysing solutions"
    ]
  },
  {
    "objectID": "2.2_analysingsolutions.html#flux-maps",
    "href": "2.2_analysingsolutions.html#flux-maps",
    "title": "Analysing solutions",
    "section": "Flux maps",
    "text": "Flux maps\n\nmap_translation = {\n    \"\": \"Opening\",\n    \"_1\": \"Night2\",\n    \"_2\": \"Night1\",\n    \"_3\": \"Day\",\n}\n\n\nfor light in [\"blue\", \"white\", \"nops\"]:\n    for atpase in [\"unconstrained\", \"constrained\"]:\n        for starch in [\"wt\", \"starchko\"]:\n            for map_suffix in [\"\", \"_1\", \"_2\", \"_3\"]:\n                model_solution = solutions_df_unphased.loc[:, (light, atpase, starch, \"fluxes\")]\n                flux_map = get_escher_map(\n                    model_solution,\n                    map=f\"../inputs/map{map_suffix}.json\",\n                    json_model=\"../models/4_stage_GC.json\",\n                )\n                flux_map_name = f\"{light}_{atpase}_{starch}\"\n                flux_map.save_html(f\"../outputs/escher_maps/{flux_map_name}_{map_translation[map_suffix]}.html\")\n\n\nlinkers_met_dict = {\n    \"SUCROSE\": \"Suc\",\n    \"GLC\": \"Glc\",\n    \"FRU\": \"Fru\",\n    \"MAL\": \"Mal\",\n    \"CIT\": \"Cit\",\n    \"L_ASPARTATE\": \"Asp\",\n    \"SER\": \"Ser\",\n}\n\n\nlinkers_df.loc[\n    ([6, 6.5], [\"SUCROSE\", \"GLC\", \"FRU\", \"MAL\", \"CIT\", \"L_ASPARTATE\", \"SER\"]),\n    (\"blue\", \"constrained\", \"wt\", \"fluxes\"),\n].unstack(0)\n\n\n\n\n\n\n\n\nPhase\n6.0\n6.5\n\n\nReaction\nCompartment\n\n\n\n\n\n\nSUCROSE\nCytoplasm\n0.000000\n0.000000\n\n\nVacuole\n10.494283\n0.000000\n\n\nGLC\nCytoplasm\n0.000000\n81.128761\n\n\nVacuole\n0.000000\n9.115034\n\n\nFRU\nCytoplasm\n0.000000\n0.000000\n\n\nVacuole\n0.000000\n9.115034\n\n\nMAL\nCytoplasm\n0.000000\n37.324187\n\n\nVacuole\n10.959760\n0.000000\n\n\nCIT\nCytoplasm\n9.916585\n0.000000\n\n\nVacuole\n0.000000\n0.000000\n\n\nL_ASPARTATE\nVacuole\n0.000000\n0.000000\n\n\nSER\nVacuole\n0.000000\n0.000000\n\n\n\n\n\n\n\n\nlinkers_df.loc[\n    ([6, 6.5], [\"SUCROSE\", \"GLC\", \"FRU\", \"MAL\", \"CIT\", \"L_ASPARTATE\", \"SER\"]),\n    (\"blue\", \"constrained\", \"starchko\", \"fluxes\"),\n].unstack(0)\n\n\n\n\n\n\n\n\nPhase\n6.0\n6.5\n\n\nReaction\nCompartment\n\n\n\n\n\n\nSUCROSE\nCytoplasm\n0.000000\n0.000000\n\n\nVacuole\n41.463387\n0.000000\n\n\nGLC\nCytoplasm\n0.000000\n0.000000\n\n\nVacuole\n0.000000\n36.013914\n\n\nFRU\nCytoplasm\n0.000000\n0.000000\n\n\nVacuole\n0.000000\n36.013914\n\n\nMAL\nCytoplasm\n0.000000\n27.957588\n\n\nVacuole\n8.209377\n0.000000\n\n\nCIT\nCytoplasm\n7.428003\n0.000000\n\n\nVacuole\n0.000000\n0.000000\n\n\nL_ASPARTATE\nVacuole\n57.476317\n49.922287\n\n\nSER\nVacuole\n0.000000\n0.000000\n\n\n\n\n\n\n\n\nlinkers_df.loc[\n    ([6, 6.5], [\"SUCROSE\", \"GLC\", \"FRU\", \"MAL\", \"CIT\", \"L_ASPARTATE\", \"SER\"]),\n    (\"white\", \"constrained\", \"wt\", \"fluxes\"),\n].unstack(0)\n\n\n\n\n\n\n\n\nPhase\n6.0\n6.5\n\n\nReaction\nCompartment\n\n\n\n\n\n\nSUCROSE\nCytoplasm\n8.249604\n0.000000\n\n\nVacuole\n5.451526\n0.000000\n\n\nGLC\nCytoplasm\n0.000000\n85.740649\n\n\nVacuole\n0.000000\n4.735040\n\n\nFRU\nCytoplasm\n0.000000\n15.763814\n\n\nVacuole\n0.000000\n4.735040\n\n\nMAL\nCytoplasm\n0.000000\n0.000000\n\n\nVacuole\n0.000000\n0.000000\n\n\nCIT\nCytoplasm\n0.000000\n0.000000\n\n\nVacuole\n0.000000\n0.000000\n\n\nL_ASPARTATE\nVacuole\n0.000000\n0.000000\n\n\nSER\nVacuole\n0.000000\n0.000000\n\n\n\n\n\n\n\n\nlinkers_df.loc[\n    ([6, 6.5], [\"SUCROSE\", \"GLC\", \"FRU\", \"MAL\", \"CIT\", \"L_ASPARTATE\", \"SER\"]),\n    (\"white\", \"constrained\", \"starchko\", \"fluxes\"),\n].unstack(0)\n\n\n\n\n\n\n\n\nPhase\n6.0\n6.5\n\n\nReaction\nCompartment\n\n\n\n\n\n\nSUCROSE\nCytoplasm\n0.000000\n0.904148\n\n\nVacuole\n41.118249\n0.000000\n\n\nGLC\nCytoplasm\n0.000000\n0.000000\n\n\nVacuole\n0.000000\n35.714136\n\n\nFRU\nCytoplasm\n0.000000\n0.000000\n\n\nVacuole\n0.000000\n35.714136\n\n\nMAL\nCytoplasm\n0.000000\n0.000000\n\n\nVacuole\n0.000000\n0.000000\n\n\nCIT\nCytoplasm\n0.000000\n0.000000\n\n\nVacuole\n0.000000\n0.000000\n\n\nL_ASPARTATE\nVacuole\n68.731554\n59.698264\n\n\nSER\nVacuole\n0.000000\n0.000000\n\n\n\n\n\n\n\n\nlinkers_df.loc[\n    ([6, 6.5], [\"SUCROSE\", \"GLC\", \"FRU\", \"MAL\", \"CIT\", \"L_ASPARTATE\", \"SER\"]),\n    (\"nops\", \"constrained\", \"wt\", \"fluxes\"),\n].unstack(0)\n\n\n\n\n\n\n\n\nPhase\n6.0\n6.5\n\n\nReaction\nCompartment\n\n\n\n\n\n\nSUCROSE\nCytoplasm\n75.453384\n0.000000\n\n\nVacuole\n0.000000\n0.000000\n\n\nGLC\nCytoplasm\n0.000000\n80.131249\n\n\nVacuole\n0.000000\n7.839374\n\n\nFRU\nCytoplasm\n0.000000\n41.892596\n\n\nVacuole\n0.000000\n7.839374\n\n\nMAL\nCytoplasm\n0.000000\n14.534914\n\n\nVacuole\n0.000000\n0.000000\n\n\nCIT\nCytoplasm\n11.156184\n0.000000\n\n\nVacuole\n0.000000\n0.000000\n\n\nL_ASPARTATE\nVacuole\n0.000000\n0.000000\n\n\nSER\nVacuole\n0.000000\n0.000000\n\n\n\n\n\n\n\n\nlinkers_df.loc[\n    ([6, 6.5], [\"SUCROSE\", \"GLC\", \"FRU\", \"MAL\", \"CIT\", \"L_ASPARTATE\", \"SER\"]),\n    (\"nops\", \"constrained\", \"starchko\", \"fluxes\"),\n].unstack(0)\n\n\n\n\n\n\n\n\nPhase\n6.0\n6.5\n\n\nReaction\nCompartment\n\n\n\n\n\n\nSUCROSE\nCytoplasm\n92.825784\n0.000000\n\n\nVacuole\n10.686263\n0.000000\n\n\nGLC\nCytoplasm\n0.000000\n32.279604\n\n\nVacuole\n0.000000\n25.311355\n\n\nFRU\nCytoplasm\n0.000000\n32.279604\n\n\nVacuole\n0.000000\n25.311355\n\n\nMAL\nCytoplasm\n0.000000\n37.266089\n\n\nVacuole\n10.942697\n0.000000\n\n\nCIT\nCytoplasm\n9.901168\n0.000000\n\n\nVacuole\n0.000000\n0.000000\n\n\nL_ASPARTATE\nVacuole\n0.000000\n0.000000\n\n\nSER\nVacuole\n0.000000\n0.000000\n\n\n\n\n\n\n\n\nfor light in [\"blue\", \"white\", \"nops\"]:\n    for atpase in [\"unconstrained\", \"constrained\"]:\n        for starch in [\"wt\", \"starchko\"]:\n            print(f\"{light}_{atpase}_{starch}\")\n\n            mets_to_include = [\n                \"SUCROSE\",\n                \"GLC\",\n                \"FRU\",\n                \"MAL\",\n                \"CIT\",\n                \"L_ASPARTATE\",\n                \"SER\",\n            ]\n            test_df = linkers_df.loc[\n                (\n                    [6, 6.5],\n                    mets_to_include,\n                ),\n                (light, atpase, starch, \"fluxes\"),\n            ].unstack(0)\n            test_df.columns = [\"EoN\", \"30 mins\"]\n            test_df.index = pd.MultiIndex.from_tuples(\n                [(linkers_met_dict[index[0]], index[1]) for index in test_df.index]\n            )\n\n            scaling = 0.4\n\n            test_df = test_df * scaling\n\n            if (test_df.loc[[\"Asp\", \"Ser\"]] &gt; 0.0000000001).sum().sum() &gt; 0:\n                aspser = True\n                print(test_df)\n            else:\n                aspser = False\n                print(test_df.loc[[\"Asp\", \"Ser\"]])\n\n            scale_conc = 50  # mM\n\n            scaled_scale_conc = scale_conc * scaling\n\n            map_name = f\"{light}_{atpase}_{starch}\"\n            if starch == \"wt\":\n                gc_path = getgcdiagram(\n                    test_df,\n                    map_name,\n                    atpase,\n                    starch,\n                    scaled_scale_conc,\n                    flipped=False,\n                    #aspser=aspser,\n                    aspser=False,\n                    display_svg=True,\n                    debug=False,\n                    brokenaxis=False,\n                )\n            else:\n                gc_path = getgcdiagram(\n                    test_df,\n                    map_name,\n                    atpase,\n                    starch,\n                    scaled_scale_conc,\n                    flipped=True,\n                    #aspser=aspser,\n                    aspser=False,\n                    display_svg=True,\n                    debug=False,\n                    brokenaxis=False,\n                )\n\n            # doesn't seem to work with hatched\n            # svg_code = open(gc_path, 'rt').read()\n            # svg2png(bytestring=svg_code, write_to=f\"../outputs/flux_maps/{map_name}.png\", dpi=300)\n\nblue_unconstrained_wt\n             EoN  30 mins\nAsp Vacuole  0.0      0.0\nSer Vacuole  0.0      0.0\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\nblue_unconstrained_starchko\n                     EoN    30 mins\nSuc Cytoplasm   0.000000   0.620719\n    Vacuole     0.000000   0.000000\nGlc Cytoplasm   0.000000   0.000000\n    Vacuole     0.000000   0.000000\nFru Cytoplasm   0.000000   0.000000\n    Vacuole     0.000000   0.000000\nMal Cytoplasm   0.000000  28.651740\n    Vacuole    12.867256   0.000000\nCit Cytoplasm   0.000000   0.000000\n    Vacuole     0.000000   0.000000\nAsp Vacuole    18.345473  15.934353\nSer Vacuole     0.000000   0.000000\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\nblue_constrained_wt\n             EoN  30 mins\nAsp Vacuole  0.0      0.0\nSer Vacuole  0.0      0.0\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\nblue_constrained_starchko\n                     EoN    30 mins\nSuc Cytoplasm   0.000000   0.000000\n    Vacuole    16.585355   0.000000\nGlc Cytoplasm   0.000000   0.000000\n    Vacuole     0.000000  14.405565\nFru Cytoplasm   0.000000   0.000000\n    Vacuole     0.000000  14.405565\nMal Cytoplasm   0.000000  11.183035\n    Vacuole     3.283751   0.000000\nCit Cytoplasm   2.971201   0.000000\n    Vacuole     0.000000   0.000000\nAsp Vacuole    22.990527  19.968915\nSer Vacuole     0.000000   0.000000\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\nwhite_unconstrained_wt\n             EoN  30 mins\nAsp Vacuole  0.0      0.0\nSer Vacuole  0.0      0.0\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\nwhite_unconstrained_starchko\n                     EoN    30 mins\nSuc Cytoplasm   0.000000   1.362671\n    Vacuole     0.000000   0.000000\nGlc Cytoplasm   0.000000   0.000000\n    Vacuole     0.000000   0.000000\nFru Cytoplasm   0.000000   0.000000\n    Vacuole     0.000000   0.000000\nMal Cytoplasm   0.000000  28.404819\n    Vacuole    12.756366   0.000000\nCit Cytoplasm   0.000000   0.000000\n    Vacuole     0.000000   0.000000\nAsp Vacuole     0.000000   0.000000\nSer Vacuole    36.990348  32.128760\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\nwhite_constrained_wt\n             EoN  30 mins\nAsp Vacuole  0.0      0.0\nSer Vacuole  0.0      0.0\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\nwhite_constrained_starchko\n                     EoN    30 mins\nSuc Cytoplasm   0.000000   0.361659\n    Vacuole    16.447300   0.000000\nGlc Cytoplasm   0.000000   0.000000\n    Vacuole     0.000000  14.285654\nFru Cytoplasm   0.000000   0.000000\n    Vacuole     0.000000  14.285654\nMal Cytoplasm   0.000000   0.000000\n    Vacuole     0.000000   0.000000\nCit Cytoplasm   0.000000   0.000000\n    Vacuole     0.000000   0.000000\nAsp Vacuole    27.492621  23.879305\nSer Vacuole     0.000000   0.000000\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\nnops_unconstrained_wt\n             EoN  30 mins\nAsp Vacuole  0.0      0.0\nSer Vacuole  0.0      0.0\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\nnops_unconstrained_starchko\n             EoN  30 mins\nAsp Vacuole  0.0      0.0\nSer Vacuole  0.0      0.0\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\nnops_constrained_wt\n             EoN  30 mins\nAsp Vacuole  0.0      0.0\nSer Vacuole  0.0      0.0\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\nnops_constrained_starchko\n             EoN  30 mins\nAsp Vacuole  0.0      0.0\nSer Vacuole  0.0      0.0\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nblue_phloem_tx_overall_df = solutions_df.loc[\"Phloem_tx_overall\", \"blue\"].xs(\"fluxes\", level=\"Solution\", axis=1)\nwhite_phloem_tx_overall_df = solutions_df.loc[\"Phloem_tx_overall\", \"white\"].xs(\"fluxes\", level=\"Solution\", axis=1)\n\n\nblue_phloem_tx_overall_df_wt_unconstrained_corrected = blue_phloem_tx_overall_df - blue_phloem_tx_overall_df.iloc[0, 0]\nblue_phloem_tx_overall_df_wt_unconstrained_corrected = blue_phloem_tx_overall_df_wt_unconstrained_corrected.mask(\n    blue_phloem_tx_overall_df_wt_unconstrained_corrected &gt; -0.0000000001, 0\n)\nblue_phloem_tx_overall_df_wt_unconstrained_corrected_fmol = (\n    blue_phloem_tx_overall_df_wt_unconstrained_corrected / parameters_df.loc[\"N_gcs\", \"Value\"] * 10**12\n)\n\n\nwhite_phloem_tx_overall_df_wt_unconstrained_corrected = (\n    white_phloem_tx_overall_df - white_phloem_tx_overall_df.iloc[0, 0]\n)\nwhite_phloem_tx_overall_df_wt_unconstrained_corrected = white_phloem_tx_overall_df_wt_unconstrained_corrected.mask(\n    white_phloem_tx_overall_df_wt_unconstrained_corrected &gt; -0.0000000001, 0\n)\nwhite_phloem_tx_overall_df_wt_unconstrained_corrected_fmol = (\n    white_phloem_tx_overall_df_wt_unconstrained_corrected / parameters_df.loc[\"N_gcs\", \"Value\"] * 10**12\n)\n\n\ncombined_fmol = pd.concat(\n    [\n        blue_phloem_tx_overall_df_wt_unconstrained_corrected_fmol,\n        white_phloem_tx_overall_df_wt_unconstrained_corrected_fmol,\n    ],\n    keys=[\"Blue\", \"White\"],\n)\ncombined_fmol.index = combined_fmol.index.droplevel(1)\ncombined_fmol\n\n\n\n\n\n\n\nATPase\nunconstrained\nconstrained\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\n\n\n\n\nBlue\n0.0\n-0.000124\n-0.027500\n-0.043059\n\n\nWhite\n0.0\n-0.000036\n-0.030068\n-0.047952\n\n\n\n\n\n\n\n\nfig, ax = plt.subplots(figsize=(8, 6))\ncombined_fmol.plot.bar(ax=ax)\nax.legend(loc=\"center left\", bbox_to_anchor=(1, 0.5))\nax.set_ylabel(\n    \"Reduction in overall phloem output compared to \\n unconstrained WT in specified light(fmol gc$^{-1}$ h$^{-1}$)\"\n)\n\nfig.set_tight_layout(True)\n\nfig.savefig(\"../outputs/efficiency_comparisons/efficiency_comparisons_compared.svg\")\nfig.savefig(\"../outputs/efficiency_comparisons/efficiency_comparisons_compared.png\")\n\n\n\n\n\n\n\n\n\nfrom functools import reduce\n\n\ndef multiply_series_by_coefficient(series_object, model, metabolite_id):\n    reaction_id = series_object.name[0]\n    coefficient = model.reactions.get_by_id(f\"{reaction_id}_1\").get_coefficient(f\"{metabolite_id}_1\")\n    return coefficient * series_object\n\n\ndef get_metabolite_budget(solution_df, metabolite, model):\n    metabolite_reactions_df = solution_df.loc[\n        (\n            [reaction.id[:-2] for reaction in four_stage_GC_model.metabolites.get_by_id(f\"{metabolite}_1\").reactions],\n            slice(None),\n        ),\n        :,\n    ]\n    metabolite_consumed_produced_df = metabolite_reactions_df.apply(\n        multiply_series_by_coefficient, args=[model, metabolite], axis=1\n    )\n    return metabolite_consumed_produced_df\n\n\ndef get_relevant_reaction_fluxes(\n    solution_df,\n    scenarios_to_drop=[(\"nops\", \"unconstrained\"), (\"white\", \"unconstrained\")],\n):\n    solution_df = solution_df.xs(\"fluxes\", level=\"Solution\", axis=1)\n    solution_df = solution_df.drop(scenarios_to_drop, axis=1)  # only keep the scenarios that we are interested in\n    solution_df = solution_df.loc[\n        (abs(solution_df) &gt; 0.00001).any(axis=1), :\n    ]  # pick only reactions which have a flux in at least one scenario\n    solution_df[abs(solution_df) &lt; 0.00001] = 0  # ignore tiny fluxes from solver error\n\n    return solution_df\n\n\ndef get_budget_for_multiple_metabolites(solution_df, metabolites, fba_model):\n    metabolite_dfs = [get_metabolite_budget(solution_df, metabolite, fba_model) for metabolite in metabolites]\n    metabolite_total_df = reduce(lambda a, b: a.add(b, fill_value=0), metabolite_dfs)\n    metabolite_total_df = get_relevant_reaction_fluxes(metabolite_total_df)\n\n    return metabolite_total_df\n\n\natp_metabolites = [metabolite.id for metabolite in four_stage_GC_model.metabolites if \"ATP\" in metabolite.id]\ngc_atp_metabolites = [metabolite[:-2] for metabolite in atp_metabolites if \"gc_2\" in metabolite]\ngc_atp_metabolites = [e for e in gc_atp_metabolites if e not in (\"DATP_p_gc\", \"PHOSPHORIBOSYL_ATP_p_gc\", \"aDATP_p_gc\")]\natp_budget_df = get_budget_for_multiple_metabolites(solutions_df, gc_atp_metabolites, four_stage_GC_model)\n\n/tmp/ipykernel_5280/3164465358.py:6: PerformanceWarning: indexing past lexsort depth may impact performance.\n  solution_df = solution_df.drop(scenarios_to_drop, axis=1)  # only keep the scenarios that we are interested in\n\n\n\nnadh_nadph_metabolites = [\n    metabolite.id\n    for metabolite in four_stage_GC_model.metabolites\n    if \"NADH\" in metabolite.id or \"NADPH\" in metabolite.id\n]\ngc_nadh_nadph_metabolites = [metabolite[:-2] for metabolite in nadh_nadph_metabolites if \"gc_2\" in metabolite]\nnadh_nadph_budget_df = get_budget_for_multiple_metabolites(solutions_df, gc_nadh_nadph_metabolites, four_stage_GC_model)\n\n/tmp/ipykernel_5280/3164465358.py:6: PerformanceWarning: indexing past lexsort depth may impact performance.\n  solution_df = solution_df.drop(scenarios_to_drop, axis=1)  # only keep the scenarios that we are interested in\n\n\n\nnadh_nadph_budget_df\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\n1_PERIOD_18_PERIOD_1_PERIOD_2_RXN_p_gc\n2\n0.000000\n0.000000\n0.000000\n0.000000\n0.004593\n0.004593\n0.000000\n0.000000\n\n\n3\n0.004593\n0.004593\n0.004593\n0.004593\n0.004593\n0.004593\n0.000000\n0.000000\n\n\n1_PERIOD_2_PERIOD_1_PERIOD_13_RXN_p_gc\n2\n0.000000\n0.000000\n0.000000\n0.000000\n-0.002173\n-0.002742\n0.000000\n0.000000\n\n\n3\n-0.004054\n-0.004049\n-0.003958\n-0.003864\n-0.003975\n-0.003881\n0.000000\n0.000000\n\n\n2OXOGLUTARATEDEH_RXN_m_gc\n1\n0.000000\n0.000028\n0.000012\n0.000023\n0.000028\n0.000028\n0.000030\n0.000031\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nNADPHox_p_tx_gc\n4\n-0.000047\n-0.000040\n-0.000040\n-0.000040\n-0.000040\n-0.000040\n-0.000038\n-0.000039\n\n\nPYRUVDEH_RXN_m_gc\n1\n0.000047\n0.000028\n0.000045\n0.000034\n0.000028\n0.000028\n0.000030\n0.000031\n\n\n2\n0.000238\n0.000813\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000104\n0.000109\n\n\n4\n0.000053\n0.000027\n0.000057\n0.000057\n0.000028\n0.000028\n0.000033\n0.000031\n\n\n\n\n62 rows × 8 columns\n\n\n\n\natp_ordered_by_most_likely_importance = (\n    abs(atp_budget_df).groupby(by=\"Reaction\").sum().sum(axis=1).sort_values(ascending=False)\n)\natp_budget_df_reordered = atp_budget_df.reindex(atp_ordered_by_most_likely_importance.index, level=\"Reaction\")\n\n\nnadh_nadph_ordered_by_most_likely_importance = (\n    abs(nadh_nadph_budget_df).groupby(by=\"Reaction\").sum().sum(axis=1).sort_values(ascending=False)\n)\nnadh_nadph_budget_df_reordered = nadh_nadph_budget_df.reindex(\n    nadh_nadph_ordered_by_most_likely_importance.index, level=\"Reaction\"\n)\n\n\ndef convert_fluxes_to_per_guard_cell(series, super_model, units):\n    return series * 10**-3 / super_model.N_gcs * (1 / units)\n\n\nunits = 10**-15  # fmol\n\n\natp_budget_df_reordered_nmoles_gc = atp_budget_df_reordered.apply(\n    convert_fluxes_to_per_guard_cell, args=[arabidopsis_supermodel, units], axis=1\n)\nnadh_nadph_budget_df_reordered_nmoles_gc = nadh_nadph_budget_df_reordered.apply(\n    convert_fluxes_to_per_guard_cell, args=[arabidopsis_supermodel, units], axis=1\n)\n\n\natp_budget_df_reordered_nmoles_gc\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\nMitochondrial_ATP_Synthase_m_gc\n1\n0.669224\n0.670681\n0.713536\n0.689127\n0.677538\n0.677538\n0.705604\n0.731622\n\n\n2\n21.155086\n22.782555\n13.872291\n10.198964\n11.595905\n8.652845\n15.702031\n13.849520\n\n\n3\n1.583322\n1.535555\n2.241434\n2.760614\n2.275743\n2.763883\n1.894895\n2.208677\n\n\n4\n0.679838\n0.639288\n0.738808\n0.738808\n0.677538\n0.677538\n0.794213\n0.731622\n\n\nPlastidial_ATP_Synthase_p_gc\n2\n0.000000\n0.000000\n0.000000\n0.000000\n10.181458\n10.181458\n0.000000\n0.000000\n\n\n3\n10.181458\n10.181458\n10.181458\n10.181458\n10.181458\n10.181458\n0.000000\n0.000000\n\n\nPROTON_ATPase_c_gc\n1\n0.000000\n0.000000\n-0.017673\n0.000000\n0.000000\n0.000000\n-0.042563\n-0.053016\n\n\n2\n-13.672759\n-14.020417\n-7.500000\n-7.500000\n-7.500000\n-7.500000\n-7.500000\n-7.500000\n\n\n3\n0.000000\n0.000000\n-0.260423\n-0.265067\n-0.203159\n-0.244605\n-0.501318\n-0.535036\n\n\n4\n0.000000\n0.000000\n-0.022759\n-0.022759\n0.000000\n0.000000\n-0.078163\n-0.053016\n\n\nPROTONATP_rev_vc_gc\n2\n-7.207308\n-6.355528\n-7.483600\n-3.339336\n-9.297846\n-3.125109\n-10.075724\n-7.457913\n\n\nPHOSGLYPHOS_RXN_p_gc\n2\n0.000000\n0.000000\n0.000000\n0.000000\n-3.746772\n-4.727792\n0.000000\n0.000000\n\n\n3\n-6.988877\n-6.980481\n-6.824133\n-6.661311\n-6.853493\n-6.690779\n0.133320\n0.000000\n\n\nATPase_tx_gc\n1\n-0.765303\n-0.765303\n-0.765303\n-0.765303\n-0.765303\n-0.765303\n-0.765303\n-0.765303\n\n\n2\n-0.765303\n-0.765303\n-0.765303\n-0.765303\n-0.920514\n-0.920514\n-0.765303\n-0.765303\n\n\n3\n-0.920514\n-0.920514\n-0.920514\n-0.920514\n-0.920514\n-0.920514\n-0.765303\n-0.765303\n\n\n4\n-0.765303\n-0.765303\n-0.765303\n-0.765303\n-0.765303\n-0.765303\n-0.765303\n-0.765303\n\n\nPHOSPHORIBULOKINASE_RXN_p_gc\n2\n0.000000\n0.000000\n0.000000\n0.000000\n-1.873386\n-2.363896\n0.000000\n0.000000\n\n\n3\n-3.542150\n-3.550111\n-3.432465\n-3.345935\n-3.426746\n-3.345390\n0.000000\n0.000000\n\n\nSUCCCOASYN_RXN_m_gc\n1\n0.000000\n0.048600\n0.020251\n0.039811\n0.049097\n0.049097\n0.051131\n0.053016\n\n\n2\n2.337709\n1.401572\n1.876615\n1.405675\n0.000000\n0.000000\n2.111197\n1.873695\n\n\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.087425\n0.106920\n\n\n4\n0.000000\n0.046333\n0.000000\n0.000000\n0.049097\n0.049097\n0.057552\n0.053016\n\n\nUDPKIN_RXN_c_gc\n2\n-0.205269\n-0.338098\n0.000000\n0.000000\n1.561155\n-0.196991\n0.000000\n0.000000\n\n\n3\n-0.229408\n-0.265907\n0.000000\n-0.763874\n0.000000\n-0.767206\n-0.056512\n-0.428496\n\n\n4\n0.000000\n0.034796\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\nFRUCTOKINASE_RXN_c_gc\n1\n0.000000\n-0.035270\n-0.041754\n-0.041728\n-0.041715\n-0.041715\n-0.042563\n-0.062684\n\n\n3\n0.000000\n0.000000\n-0.216839\n-0.985371\n-0.241082\n-0.976847\n-0.557830\n-0.963532\n\n\n4\n0.000000\n0.000000\n-0.041781\n-0.041781\n-0.041715\n-0.041715\n-0.078163\n-0.062684\n\n\nPHOSGLYPHOS_RXN_c_gc\n1\n0.045450\n0.048600\n0.049189\n0.049127\n0.049097\n0.049097\n0.051131\n0.053016\n\n\n2\n-0.821078\n-1.352391\n0.000000\n0.000000\n0.000000\n0.000000\n1.055598\n0.000000\n\n\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.188385\n\n\n4\n0.045323\n0.046326\n0.049254\n0.049254\n0.049097\n0.049097\n0.041089\n0.053016\n\n\nPEPCARBOXYKIN_RXN_c_gc\n2\n-0.975561\n-1.352391\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\nGLUC1PADENYLTRANS_RXN_p_gc\n3\n-0.083832\n0.000000\n-0.768519\n0.000000\n-0.812206\n0.000000\n-0.367998\n0.000000\n\n\n4\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n-0.032925\n0.000000\n\n\nPEPDEPHOS_RXN_c_gc\n1\n0.045375\n0.048600\n0.049189\n0.049127\n0.049097\n0.049097\n0.051131\n0.053016\n\n\n2\n0.154483\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.188385\n\n\n4\n0.040143\n0.046326\n0.049254\n0.049254\n0.049097\n0.049097\n0.041089\n0.053016\n\n\n6PFRUCTPHOS_RXN_c_gc\n2\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n-0.527799\n0.000000\n\n\n4\n0.000000\n-0.040561\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\nPEPDEPHOS_RXN_p_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.133320\n0.000000\n\n\n\n\n\n\n\nCarbon movement df generation\n\napoplastic_linker_reactions = [\n    reaction.id[:-2] for reaction in four_stage_GC_model.reactions if \"a_Linker\" in reaction.id\n]\nget_relevant_reaction_fluxes(solutions_df.loc[(apoplastic_linker_reactions, slice(None)), :])\n\n/tmp/ipykernel_5280/3164465358.py:6: PerformanceWarning: indexing past lexsort depth may impact performance.\n  solution_df = solution_df.drop(scenarios_to_drop, axis=1)  # only keep the scenarios that we are interested in\n\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\nSUCROSE_a_Linker\n3\n0.00159\n0.001729\n0.0\n0.0\n0.0\n0.0\n0.000420\n0.000369\n\n\n4\n0.00000\n0.000000\n0.0\n0.0\n0.0\n0.0\n0.000148\n0.000184\n\n\n\n\n\n\n\n\ntransfer_reactions = [reaction.id[:-2] for reaction in four_stage_GC_model.reactions if \"ae_gc\" in reaction.id]\ntransfer_reactions = [e for e in transfer_reactions if e not in (\"WATER_ae_gc\", \"K_ae_gc\", \"Cl_ae_gc\", \"NITRATE_ae_gc\")]\ntransfer_reactions = solutions_df.loc[(transfer_reactions, slice(None)), :]\ntransfer_reactions = get_relevant_reaction_fluxes(transfer_reactions)\ntransfer_reactions.loc[(\"GLC_ae_gc\", 2), :] = 0\ntransfer_reactions\n\n/tmp/ipykernel_5280/3164465358.py:6: PerformanceWarning: indexing past lexsort depth may impact performance.\n  solution_df = solution_df.drop(scenarios_to_drop, axis=1)  # only keep the scenarios that we are interested in\n\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\nSUCROSE_ae_gc\n1\n0.000000\n0.00000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000025\n0.000031\n\n\n3\n-0.000138\n-0.00015\n0.000151\n0.000154\n0.000118\n0.000142\n0.000291\n0.000310\n\n\n4\n0.000000\n0.00000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000045\n0.000031\n\n\nGLC_ae_gc\n3\n-0.000024\n0.00000\n-0.000597\n-0.000597\n-0.000550\n-0.000592\n-0.000570\n-0.000597\n\n\n2\n0.000000\n0.00000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\n\n\n\n\n\n\ntransfer_reactions_me = [reaction.id[:-2] for reaction in four_stage_GC_model.reactions if \"ae_me\" in reaction.id]\ntransfer_reactions_me = [\n    e\n    for e in transfer_reactions_me\n    if e\n    not in (\n        \"WATER_ae_me\",\n        \"K_ae_me\",\n        \"Cl_ae_me\",\n        \"NITRATE_ae_me\",\n        \"SULFATE_ae_me\",\n        \"AMMONIUM_ae_me\",\n    )\n]\ntransfer_reactions_me = get_relevant_reaction_fluxes(solutions_df.loc[(transfer_reactions_me, slice(None)), :])\ntransfer_reactions_me\n\n/tmp/ipykernel_5280/3164465358.py:6: PerformanceWarning: indexing past lexsort depth may impact performance.\n  solution_df = solution_df.drop(scenarios_to_drop, axis=1)  # only keep the scenarios that we are interested in\n\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\nSUCROSE_ae_me\n3\n0.000000\n0.000000\n-0.000151\n-0.000154\n-0.000118\n-0.000142\n-0.000327\n-0.000342\n\n\n4\n0.000265\n0.000288\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\nGLC_ae_me\n3\n0.000024\n0.000000\n0.000597\n0.000597\n0.000550\n0.000592\n0.000570\n0.000597\n\n\n\n\n\n\n\n\ndef adjust_for_hexose_equivalents(series_object):\n    hexose_equivalents = {\n        \"GLC\": 1,\n        \"SUCROSE\": 2,\n        \"FRU\": 1,\n    }\n\n    metabolite = series_object.name[0].split(\"_\")[0]\n    hexose_equivalent = hexose_equivalents[metabolite]\n\n    return series_object * hexose_equivalent\n\n\nfrom mmon_gcm.analysing import adjust_for_phases\n\n\ntransfer_reactions_me\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\nSUCROSE_ae_me\n3\n0.000000\n0.000000\n-0.000151\n-0.000154\n-0.000118\n-0.000142\n-0.000327\n-0.000342\n\n\n4\n0.000265\n0.000288\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\nGLC_ae_me\n3\n0.000024\n0.000000\n0.000597\n0.000597\n0.000550\n0.000592\n0.000570\n0.000597\n\n\n\n\n\n\n\n\nme_carbon_production_consumption = (\n    transfer_reactions_me.apply(adjust_for_phases, args=[four_stage_GC_model], axis=1)\n    .apply(adjust_for_hexose_equivalents, axis=1)\n    .sum()\n    * -1\n)\nme_carbon_production_consumption\n\nLight  ATPase         Starch  \nblue   unconstrained  wt         -0.003459\n                      starchko   -0.003458\n       constrained    wt         -0.003389\n                      starchko   -0.003327\nwhite  constrained    wt         -0.003610\n                      starchko   -0.003543\nnops   constrained    wt          0.000971\n                      starchko    0.001012\ndtype: float64\n\n\n\ngc_carbon_production_consumption = (\n    transfer_reactions.loc[[\"GLC_ae_gc\", \"SUCROSE_ae_gc\"], :]\n    .apply(adjust_for_phases, args=[four_stage_GC_model], axis=1)\n    .apply(adjust_for_hexose_equivalents, axis=1)\n    * -1\n)\ngc_carbon_production_consumption\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\nGLC_ae_gc\n3\n0.000280\n-0.000000\n0.006863\n0.006863\n0.00632\n0.006806\n0.006557\n0.006863\n\n\n2\n-0.000000\n-0.000000\n-0.000000\n-0.000000\n-0.00000\n-0.000000\n-0.000000\n-0.000000\n\n\nSUCROSE_ae_gc\n1\n-0.000000\n-0.000000\n-0.000000\n-0.000000\n-0.00000\n-0.000000\n-0.000296\n-0.000369\n\n\n3\n0.003179\n0.003458\n-0.003474\n-0.003536\n-0.00271\n-0.003263\n-0.006688\n-0.007137\n\n\n4\n-0.000000\n-0.000000\n-0.000000\n-0.000000\n-0.00000\n-0.000000\n-0.000544\n-0.000369\n\n\n\n\n\n\n\n\n((0.006863-0.003474)+(0.006863-0.003536))/2\n\n0.003358\n\n\n\n((0.00632-0.00271)+(0.006806-0.003263))/2\n\n0.0035765000000000003\n\n\n\n0.0035765000000000003/0.003358\n\n1.065068493150685\n\n\n\n(0.006863-0.003474)/(0.006863-0.003536)\n\n1.0186354072738202\n\n\n\n(0.00632-0.00271)/(0.006806-0.003263)\n\n1.0189105278012982\n\n\n\ngc_carbon_production_consumption_nmoles_gc = gc_carbon_production_consumption.apply(\n    convert_fluxes_to_per_guard_cell, args=[arabidopsis_supermodel, units], axis=1\n)\n\n\natp_colours = {\n    \"6PFRUCTPHOS_RXN_c_gc\": [6, 6],  # phosphofructokinase glycolysis\n    \"FRUCTOKINASE_RXN_c_gc\": [6, 6],  # fructokinase glycolysis\n    \"GLUC1PADENYLTRANS_RXN_p_gc\": [8, 8],  # glc1p -&gt; adp glc (starch synthesis)\n    \"GLY3KIN_RXN_p_gc\": [6, 6],  # g3p -&gt; glycerate (carbon degradation)\n    \"Mitochondrial_ATP_Synthase_m_gc\": [7, 7],  # mitochondrial atp synthase\n    \"PEPCARBOXYKIN_RXN_c_gc\": [6, 6],  # OAA -&gt; pyruvate (mal deg)\n    \"PEPDEPHOS_RXN_c_gc\": [6, 6],  # PEP -&gt; pyruvate\n    \"PEPDEPHOS_RXN_p_gc\": [6, 6],  # PEP -&gt; pyruvate\n    \"PHOSGLYPHOS_RXN_c_gc\": [2, 6],  # DPG -&gt; G3p (glycolysis)\n    \"PHOSGLYPHOS_RXN_p_gc\": [4, 4],  # DPG -&gt; G3p (glycolysis)\n    \"PHOSPHORIBULOKINASE_RXN_p_gc\": [4, 4],  # calvin cycle\n    \"PROTONATP_rev_vc_gc\": [0, 0],  # tonoplastic proton pump\n    \"PROTON_ATPase_c_gc\": [1, 1],  # plasma membrane proton pump\n    \"Plastidial_ATP_Synthase_p_gc\": [3, 3],  # plastidial atp_synthase\n    \"SUCCCOASYN_RXN_m_gc\": [6, 6],  # TCA cycle\n    \"UDPKIN_RXN_c_gc\": [2, 2],  # atp-&gt;utp, sucrose synthesis\n    \"GLUCOKIN_RXN_c_gc\": [9, 9],\n    \"ATP_ADP_mc_gc\": [9, 9],  # ATP shuttle\n    \"ATPase_tx_gc\": [9, 9],  # maintenance\n    \"PYRUVATEORTHOPHOSPHATE_DIKINASE_RXN_c_gc\": [9, 9],\n    \"ADENYL_KIN_RXN_m_gc\": [9, 9],\n    \"6PFRUCTPHOS_RXN_p_gc\": [9, 9],\n}\n\nnadh_nadph_colours = {\n    \"1_PERIOD_18_PERIOD_1_PERIOD_2_RXN_p_gc\": [3, 3],  # ps\n    \"1_PERIOD_2_PERIOD_1_PERIOD_13_RXN_p_gc\": [4, 4],  # ps\n    \"2OXOGLUTARATEDEH_RXN_m_gc\": [6, 6],  # tca\n    \"GAPOXNPHOSPHN_RXN_c_gc\": [2, 6],  # glycolysis or gluconeogenesis\n    \"GAPOXNPHOSPHN_RXN_p_gc\": [4, 4],  # calvin cycle but nadh\n    \"HYDROXYPYRUVATE_REDUCTASE_RXN_NAD_x_gc\": [\n        5,\n        5,\n    ],  # OH_PYR_x -&gt; Glycerate_x to do with serine/aspartate metabolism\n    \"ISOCITRATE_DEHYDROGENASE_NAD_RXN_m_gc\": [6, 6],  # tca\n    \"MALATE_DEHYDROGENASE_NADPs_RXN_p_gc\": [9, 9],  # shuttle\n    \"MALATE_DEH_RXN_c_gc\": [\n        9,\n        6,\n    ],  # malate degradation when forward but also shuttle in reverse\n    \"MALATE_DEH_RXN_m_gc\": [9, 9],  # can be tca but mainly shuttle\n    \"MALATE_DEH_RXN_p_gc\": [9, 9],  # shuttle\n    \"MALATE_DEH_RXN_x_gc\": [9, 9],  # shuttle\n    \"MALIC_NAD_RXN_m_gc\": [6, 6],  # malate degradation (al-&gt;pyr)\n    \"NADH_DEHYDROG_A_RXN_mi_gc\": [7, 7],  # complex 1 (TC)\n    #\"PGLYCDEHYDROG_RXN_p_gc\": [5, 5],  # ser_synthesis from g3p\n    \"PYRUVDEH_RXN_m_gc\": [6, 6],  # pyruvate degradation\n    \"ISOCITDEH_RXN_c_gc\": [6, 6],  # tca nadp\n    \"6PGLUCONDEHYDROG_RXN_p_gc\": [9, 9],  # PPP\n    \"NADPHox_c_tx_gc\": [9, 9],\n    \"NADPHox_p_tx_gc\": [9, 9],\n    \"GLU6PDEHYDROG_RXN_c_gc\": [9, 9],\n    \"6PGLUCONDEHYDROG_RXN_c_gc\": [9, 9],\n    \"GLU6PDEHYDROG_RXN_p_gc\": [9, 9],\n    \"MALIC_NADP_RXN_c_gc\": [9, 9],\n}\n\nreaction_colours = {**atp_colours, **nadh_nadph_colours}\nfor reaction, colour_number in reaction_colours.items():\n    for i, reverse_forward in enumerate(colour_number):\n        if reverse_forward == 9:\n            reaction_colours[reaction][i] = \"#DDDDDD\"\n        else:\n            reaction_colours[reaction][i] = colours[reverse_forward]\n\n\ncolours_legend = {\n    \"Tonoplast membrane ATPase\": 0,\n    \"Plasma membrane ATPase\": 1,\n    \"Sucrose/Glucose synthesis\": 2,\n    \"Plastid/Photosynthesis\": 3,\n    \"Carbon fixation\": 4,\n    #\"Serine Synthesis\": 5,\n    \"Carbon degradation\\n(Glycolysis, TCA etc.)\": 6,\n    \"ETC/Mitochondrial\\nATP Synthase\": 7,\n    \"Starch synthesis\": 8,\n    \"Other e.g. shuttles, maintenance\": 9,\n}\nfor category, colour_number in colours_legend.items():\n    if colour_number == 9:\n        colours_legend[category] = \"#DDDDDD\"\n    else:\n        colours_legend[category] = colours[colour_number]\n\n\ncarbon_colours = {\n    \"SUCROSE_ae_gc\": colours[2],\n    \"GLC_ae_gc\": colours[6],\n    \"FRU_ae_gc\": colours[4],\n}\n\n\nlegend_colours = {\n    \"Glucose\": colours[6],\n    \"Sucrose\": colours[2],\n}\n\n\natp_budget_df_reordered_nmoles_gc.index\n\nMultiIndex([('Mitochondrial_ATP_Synthase_m_gc', 1),\n            ('Mitochondrial_ATP_Synthase_m_gc', 2),\n            ('Mitochondrial_ATP_Synthase_m_gc', 3),\n            ('Mitochondrial_ATP_Synthase_m_gc', 4),\n            (   'Plastidial_ATP_Synthase_p_gc', 2),\n            (   'Plastidial_ATP_Synthase_p_gc', 3),\n            (             'PROTON_ATPase_c_gc', 1),\n            (             'PROTON_ATPase_c_gc', 2),\n            (             'PROTON_ATPase_c_gc', 3),\n            (             'PROTON_ATPase_c_gc', 4),\n            (            'PROTONATP_rev_vc_gc', 2),\n            (           'PHOSGLYPHOS_RXN_p_gc', 2),\n            (           'PHOSGLYPHOS_RXN_p_gc', 3),\n            (                   'ATPase_tx_gc', 1),\n            (                   'ATPase_tx_gc', 2),\n            (                   'ATPase_tx_gc', 3),\n            (                   'ATPase_tx_gc', 4),\n            (   'PHOSPHORIBULOKINASE_RXN_p_gc', 2),\n            (   'PHOSPHORIBULOKINASE_RXN_p_gc', 3),\n            (            'SUCCCOASYN_RXN_m_gc', 1),\n            (            'SUCCCOASYN_RXN_m_gc', 2),\n            (            'SUCCCOASYN_RXN_m_gc', 3),\n            (            'SUCCCOASYN_RXN_m_gc', 4),\n            (                'UDPKIN_RXN_c_gc', 2),\n            (                'UDPKIN_RXN_c_gc', 3),\n            (                'UDPKIN_RXN_c_gc', 4),\n            (          'FRUCTOKINASE_RXN_c_gc', 1),\n            (          'FRUCTOKINASE_RXN_c_gc', 3),\n            (          'FRUCTOKINASE_RXN_c_gc', 4),\n            (           'PHOSGLYPHOS_RXN_c_gc', 1),\n            (           'PHOSGLYPHOS_RXN_c_gc', 2),\n            (           'PHOSGLYPHOS_RXN_c_gc', 3),\n            (           'PHOSGLYPHOS_RXN_c_gc', 4),\n            (         'PEPCARBOXYKIN_RXN_c_gc', 2),\n            (     'GLUC1PADENYLTRANS_RXN_p_gc', 3),\n            (     'GLUC1PADENYLTRANS_RXN_p_gc', 4),\n            (             'PEPDEPHOS_RXN_c_gc', 1),\n            (             'PEPDEPHOS_RXN_c_gc', 2),\n            (             'PEPDEPHOS_RXN_c_gc', 3),\n            (             'PEPDEPHOS_RXN_c_gc', 4),\n            (           '6PFRUCTPHOS_RXN_c_gc', 2),\n            (           '6PFRUCTPHOS_RXN_c_gc', 4),\n            (             'PEPDEPHOS_RXN_p_gc', 3)],\n           names=['Reaction', 'Phase'])\n\n\n\nnadh_nadph_budget_df_reordered_nmoles_gc\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\n1_PERIOD_18_PERIOD_1_PERIOD_2_RXN_p_gc\n2\n0.000000\n0.000000\n0.000000\n0.000000\n7.918912\n7.918912\n0.000000\n0.000000\n\n\n3\n7.918912\n7.918912\n7.918912\n7.918912\n7.918912\n7.918912\n0.000000\n0.000000\n\n\n1_PERIOD_2_PERIOD_1_PERIOD_13_RXN_p_gc\n2\n0.000000\n0.000000\n0.000000\n0.000000\n-3.746772\n-4.727792\n0.000000\n0.000000\n\n\n3\n-6.988877\n-6.980481\n-6.824133\n-6.661311\n-6.853493\n-6.690779\n0.000000\n0.000000\n\n\nNADH_DEHYDROG_A_RXN_mi_gc\n1\n-0.216814\n-0.194400\n-0.225695\n-0.205822\n-0.196388\n-0.196388\n-0.204523\n-0.212064\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n6PGLUCONDEHYDROG_RXN_p_gc\n1\n0.034942\n0.034417\n0.034319\n0.034329\n0.034334\n0.034334\n0.033995\n0.033681\n\n\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.020297\n0.024697\n\n\n4\n0.040143\n0.034796\n0.034308\n0.034308\n0.034334\n0.034334\n0.032925\n0.033681\n\n\nMALATE_DEH_RXN_p_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n-0.133320\n0.000000\n\n\nGAPOXNPHOSPHN_RXN_p_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.133320\n0.000000\n\n\n\n\n62 rows × 8 columns\n\n\n\n\ncolor_order = [\n    [nadh_nadph_colours[reaction][1], reaction] for reaction in nadh_nadph_budget_df_reordered_nmoles_gc.index.levels[0]\n]\nnadh_nadph_budget_df_reordered_nmoles_gc = nadh_nadph_budget_df_reordered_nmoles_gc.loc[\n    pd.DataFrame(color_order).sort_values(by=[0, 1]).loc[:, 1].values\n]\n\n\ncolor_order = [[atp_colours[reaction][1], reaction] for reaction in atp_budget_df_reordered_nmoles_gc.index.levels[0]]\natp_budget_df_reordered_nmoles_gc = atp_budget_df_reordered_nmoles_gc.loc[\n    pd.DataFrame(color_order).sort_values(by=[0, 1]).loc[:, 1].values\n]\n\n\natp_budget_df_reordered_nmoles_gc.drop(\"nops\", axis=1).loc[(\"Plastidial_ATP_Synthase_p_gc\", 3)].mean()\n\n/tmp/ipykernel_5280/544428024.py:1: PerformanceWarning: dropping on a non-lexsorted multi-index without a level parameter may impact performance.\n  atp_budget_df_reordered_nmoles_gc.drop(\"nops\", axis=1).loc[(\"Plastidial_ATP_Synthase_p_gc\", 3)].mean()\n\n\n10.181457681507931\n\n\n\n(abs(nadh_nadph_budget_df_reordered_nmoles_gc) / 2).sum()\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          16.205902\n                      starchko    17.776325\n       constrained    wt          13.499895\n                      starchko    12.706483\nwhite  constrained    wt          21.462877\n                      starchko    20.644570\nnops   constrained    wt           7.282741\n                      starchko     5.903313\ndtype: float64\n\n\n\nnadh_nadph_budget_df_reordered_nmoles_gc\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\n1_PERIOD_18_PERIOD_1_PERIOD_2_RXN_p_gc\n2\n0.000000\n0.000000\n0.000000\n0.000000\n7.918912\n7.918912\n0.000000\n0.000000\n\n\n3\n7.918912\n7.918912\n7.918912\n7.918912\n7.918912\n7.918912\n0.000000\n0.000000\n\n\nNADH_DEHYDROG_A_RXN_mi_gc\n1\n-0.216814\n-0.194400\n-0.225695\n-0.205822\n-0.196388\n-0.196388\n-0.204523\n-0.212064\n\n\n2\n-5.649070\n-6.753242\n-3.498128\n-2.556250\n-3.865302\n-2.884282\n-3.967292\n-3.492290\n\n\n3\n-0.527774\n-0.511852\n-0.747145\n-0.920205\n-0.758581\n-0.921294\n-0.579177\n-0.672074\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nNADPHox_c_tx_gc\n4\n-0.174815\n-0.185509\n-0.186485\n-0.186485\n-0.186433\n-0.186433\n-0.189251\n-0.187739\n\n\nNADPHox_p_tx_gc\n1\n-0.069884\n-0.068834\n-0.068637\n-0.068658\n-0.068668\n-0.068668\n-0.067990\n-0.067362\n\n\n2\n0.000000\n0.000000\n0.000000\n0.000000\n-0.306838\n-0.306838\n0.000000\n0.000000\n\n\n3\n-0.306838\n-0.306838\n-0.306838\n-0.306838\n-0.306838\n-0.306838\n-0.040594\n-0.049394\n\n\n4\n-0.080286\n-0.069592\n-0.068616\n-0.068616\n-0.068668\n-0.068668\n-0.065850\n-0.067362\n\n\n\n\n62 rows × 8 columns\n\n\n\n\n(abs(nadh_nadph_budget_df_reordered_nmoles_gc.loc[(slice(None), 3), :])/2).sum()\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          8.446685\n                      starchko    8.430763\n       constrained    wt          8.666056\n                      starchko    8.839116\nwhite  constrained    wt          8.677492\n                      starchko    8.840206\nnops   constrained    wt          0.967598\n                      starchko    1.115560\ndtype: float64\n\n\n\nnadh_nadph_budget_df_reordered_nmoles_gc.loc[(slice(None), 3), :]\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\n1_PERIOD_18_PERIOD_1_PERIOD_2_RXN_p_gc\n3\n7.918912\n7.918912\n7.918912\n7.918912\n7.918912\n7.918912\n0.000000\n0.000000\n\n\nNADH_DEHYDROG_A_RXN_mi_gc\n3\n-0.527774\n-0.511852\n-0.747145\n-0.920205\n-0.758581\n-0.921294\n-0.579177\n-0.672074\n\n\n1_PERIOD_2_PERIOD_1_PERIOD_13_RXN_p_gc\n3\n-6.988877\n-6.980481\n-6.824133\n-6.661311\n-6.853493\n-6.690779\n0.000000\n0.000000\n\n\nGAPOXNPHOSPHN_RXN_p_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.133320\n0.000000\n\n\n2OXOGLUTARATEDEH_RXN_m_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.087425\n0.106920\n\n\nGAPOXNPHOSPHN_RXN_c_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.188385\n\n\nISOCITDEH_RXN_c_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.087425\n0.106920\n\n\nMALATE_DEH_RXN_c_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n-0.188385\n\n\nPYRUVDEH_RXN_m_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.179216\n0.188385\n\n\n6PGLUCONDEHYDROG_RXN_c_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.040594\n0.049394\n\n\n6PGLUCONDEHYDROG_RXN_p_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.020297\n0.024697\n\n\nGLU6PDEHYDROG_RXN_c_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.040594\n0.049394\n\n\nGLU6PDEHYDROG_RXN_p_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.020297\n0.024697\n\n\nMALATE_DEHYDROGENASE_NADPs_RXN_p_gc\n3\n-0.623197\n-0.631593\n-0.787941\n-0.950763\n-0.758581\n-0.921294\n0.000000\n0.000000\n\n\nMALATE_DEH_RXN_m_gc\n3\n0.527774\n0.511852\n0.747145\n0.920205\n0.758581\n0.921294\n0.312536\n0.376769\n\n\nMALATE_DEH_RXN_p_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n-0.133320\n0.000000\n\n\nMALIC_NADP_RXN_c_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.045896\n0.000000\n\n\nNADPHox_c_tx_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n-0.214507\n-0.205707\n\n\nNADPHox_p_tx_gc\n3\n-0.306838\n-0.306838\n-0.306838\n-0.306838\n-0.306838\n-0.306838\n-0.040594\n-0.049394\n\n\n\n\n\n\n\n\n((0.984348+1.115560)/2) / ((8.446685+8.430763+8.666056+8.839116+8.677492+8.840206)/6)\n\n0.12138122159482721\n\n\n\n((0.984348+1.115560)/2) / ((8.666056+8.839116+8.677492+8.840206)/4)\n\n0.11991638606430598\n\n\n\nnops_nadph_3 = nadh_nadph_budget_df_reordered_nmoles_gc.loc[(slice(None), 3), \"nops\"].index\n\n\ncolours_legend_iv = {v: k for k, v in colours_legend.items()}\n\n\nnops_nadph_3_df = nadh_nadph_budget_df_reordered_nmoles_gc.loc[(slice(None), 3), \"nops\"]\n\n\nnops_nadph_3\n\nMultiIndex([('1_PERIOD_18_PERIOD_1_PERIOD_2_RXN_p_gc', 3),\n            (             'NADH_DEHYDROG_A_RXN_mi_gc', 3),\n            ('1_PERIOD_2_PERIOD_1_PERIOD_13_RXN_p_gc', 3),\n            (                'GAPOXNPHOSPHN_RXN_p_gc', 3),\n            (             '2OXOGLUTARATEDEH_RXN_m_gc', 3),\n            (                'GAPOXNPHOSPHN_RXN_c_gc', 3),\n            (                    'ISOCITDEH_RXN_c_gc', 3),\n            (                   'MALATE_DEH_RXN_c_gc', 3),\n            (                     'PYRUVDEH_RXN_m_gc', 3),\n            (             '6PGLUCONDEHYDROG_RXN_c_gc', 3),\n            (             '6PGLUCONDEHYDROG_RXN_p_gc', 3),\n            (                'GLU6PDEHYDROG_RXN_c_gc', 3),\n            (                'GLU6PDEHYDROG_RXN_p_gc', 3),\n            (   'MALATE_DEHYDROGENASE_NADPs_RXN_p_gc', 3),\n            (                   'MALATE_DEH_RXN_m_gc', 3),\n            (                   'MALATE_DEH_RXN_p_gc', 3),\n            (                   'MALIC_NADP_RXN_c_gc', 3),\n            (                       'NADPHox_c_tx_gc', 3),\n            (                       'NADPHox_p_tx_gc', 3)],\n           names=['Reaction', 'Phase'])\n\n\n\nnops_nadph_3_reactions = [i[0] for i in nops_nadph_3]\n\n\ndescriptions = []\nfor reaction in nops_nadph_3_reactions:\n    descriptions.append(colours_legend_iv[nadh_nadph_colours[reaction][0]].replace(\"\\n\", \"\"))\n\n\nnops_nadph_3_df.loc[:, \"Description\"] = descriptions\n\n\nnops_nadph_3_df\n\n\n\n\n\n\n\n\nATPase\nconstrained\nDescription\n\n\n\nStarch\nwt\nstarchko\n\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n1_PERIOD_18_PERIOD_1_PERIOD_2_RXN_p_gc\n3\n0.000000\n0.000000\nPlastid/Photosynthesis\n\n\nNADH_DEHYDROG_A_RXN_mi_gc\n3\n-0.579177\n-0.672074\nETC/MitochondrialATP Synthase\n\n\n1_PERIOD_2_PERIOD_1_PERIOD_13_RXN_p_gc\n3\n0.000000\n0.000000\nCarbon fixation\n\n\nGAPOXNPHOSPHN_RXN_p_gc\n3\n0.133320\n0.000000\nCarbon fixation\n\n\n2OXOGLUTARATEDEH_RXN_m_gc\n3\n0.087425\n0.106920\nCarbon degradation(Glycolysis, TCA etc.)\n\n\nGAPOXNPHOSPHN_RXN_c_gc\n3\n0.000000\n0.188385\nSucrose/Glucose synthesis\n\n\nISOCITDEH_RXN_c_gc\n3\n0.087425\n0.106920\nCarbon degradation(Glycolysis, TCA etc.)\n\n\nMALATE_DEH_RXN_c_gc\n3\n0.000000\n-0.188385\nOther e.g. shuttles, maintenance\n\n\nPYRUVDEH_RXN_m_gc\n3\n0.179216\n0.188385\nCarbon degradation(Glycolysis, TCA etc.)\n\n\n6PGLUCONDEHYDROG_RXN_c_gc\n3\n0.040594\n0.049394\nOther e.g. shuttles, maintenance\n\n\n6PGLUCONDEHYDROG_RXN_p_gc\n3\n0.020297\n0.024697\nOther e.g. shuttles, maintenance\n\n\nGLU6PDEHYDROG_RXN_c_gc\n3\n0.040594\n0.049394\nOther e.g. shuttles, maintenance\n\n\nGLU6PDEHYDROG_RXN_p_gc\n3\n0.020297\n0.024697\nOther e.g. shuttles, maintenance\n\n\nMALATE_DEHYDROGENASE_NADPs_RXN_p_gc\n3\n0.000000\n0.000000\nOther e.g. shuttles, maintenance\n\n\nMALATE_DEH_RXN_m_gc\n3\n0.312536\n0.376769\nOther e.g. shuttles, maintenance\n\n\nMALATE_DEH_RXN_p_gc\n3\n-0.133320\n0.000000\nOther e.g. shuttles, maintenance\n\n\nMALIC_NADP_RXN_c_gc\n3\n0.045896\n0.000000\nOther e.g. shuttles, maintenance\n\n\nNADPHox_c_tx_gc\n3\n-0.214507\n-0.205707\nOther e.g. shuttles, maintenance\n\n\nNADPHox_p_tx_gc\n3\n-0.040594\n-0.049394\nOther e.g. shuttles, maintenance\n\n\n\n\n\n\n\n\natp_budget_df_reordered_nmoles_gc.columns\n\nMultiIndex([( 'blue', 'unconstrained',       'wt'),\n            ( 'blue', 'unconstrained', 'starchko'),\n            ( 'blue',   'constrained',       'wt'),\n            ( 'blue',   'constrained', 'starchko'),\n            ('white',   'constrained',       'wt'),\n            ('white',   'constrained', 'starchko'),\n            ( 'nops',   'constrained',       'wt'),\n            ( 'nops',   'constrained', 'starchko')],\n           names=['Light', 'ATPase', 'Starch'])\n\n\n\ngc_carbon_production_consumption_nmoles_gc = gc_carbon_production_consumption_nmoles_gc.loc[:, gc_carbon_production_consumption_nmoles_gc.columns.get_level_values(1) != 'unconstrained']\n\n\ngc_carbon_production_consumption_nmoles_gc\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nconstrained\nconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\nGLC_ae_gc\n3\n11.832823\n11.832822\n10.896129\n11.734326\n11.305022\n11.832822\n\n\n2\n-0.000000\n-0.000000\n-0.000000\n-0.000000\n-0.000000\n-0.000000\n\n\nSUCROSE_ae_gc\n1\n-0.000000\n-0.000000\n-0.000000\n-0.000000\n-0.510755\n-0.636193\n\n\n3\n-5.989718\n-6.096542\n-4.672668\n-5.625923\n-11.530315\n-12.305836\n\n\n4\n-0.000000\n-0.000000\n-0.000000\n-0.000000\n-0.937958\n-0.636193\n\n\n\n\n\n\n\n\nmetabolites = [\"ATP\", \"NAD(P)H\"]\nphases = [\"Opening\", \"Day\"]\nhatches = {\"wt\": None, \"starchko\": \"//\"}\natpase_labelling = {\"unconstrained\": \"–\", \"constrained\": \"+\"}\n\nfig, ax = plt.subplots(1, 1, sharex=True, sharey=\"row\")\nplt.subplots_adjust(hspace=0.1)\n\ncolour_rectangles_thickness = 4 / (75 * 2)\n\ny_lim_for_hexose = 49\n\nfor x1, x2, colour in zip([-0.5, 1.5, 3.5], [1.5, 3.5, 5.5], [\"#004488\", \"white\", \"#DDDDDD\"]):\n    ax.fill_betweenx(\n        [30 - colour_rectangles_thickness * 30 * 2, 30],\n        x1,\n        x2,\n        alpha=1,\n        color=colour,\n        linewidth=0.5,\n        edgecolor=\"black\",\n    )\nfor i in range(6):\n    if i % 2 == 0:\n        ax.text(i-0.2, 30-4, \"WT\")\n    else:\n        ax.text(i-0.2, 30-4, \"KO\")\n\nphase = 3\nfor i, scenario in enumerate(gc_carbon_production_consumption_nmoles_gc.columns):\n    positive_bottom = 0\n    negative_top = 0\n    scenario_df = gc_carbon_production_consumption_nmoles_gc.xs(phase, level=\"Phase\").loc[:, scenario]\n    for reaction in scenario_df.index:\n        value = scenario_df.loc[reaction]\n        if value &gt; 0.00001:\n            ax.bar(\n                i,\n                value,\n                bottom=positive_bottom,\n                color=carbon_colours[reaction],\n                linewidth=0.1,\n                hatch=hatches[scenario[2]],\n                align=\"edge\",\n                width=-0.4,\n            )\n            positive_bottom += value\n        elif value &lt; 0.00001:\n            ax.bar(\n                i,\n                value,\n                bottom=negative_top,\n                color=carbon_colours[reaction],\n                linewidth=0.1,\n                hatch=hatches[scenario[2]],\n                align=\"edge\",\n                width=0.4,\n            )\n            negative_top += abs(value)\n    if positive_bottom == 0:\n        ax.bar(\n            i,\n            0.3,\n            bottom=0,\n            color=carbon_colours[reaction],\n            linewidth=0.1,\n            hatch=hatches[scenario[2]],\n            align=\"edge\",\n            width=-0.4,\n        )\n    if negative_top == 0:\n        ax.bar(\n            i,\n            0.3,\n            bottom=0,\n            color=carbon_colours[reaction],\n            linewidth=0.1,\n            hatch=hatches[scenario[2]],\n            align=\"edge\",\n            width=0.4,\n        )\n    if positive_bottom &gt; 0:\n        ax.text(\n            i - 0.2,\n            positive_bottom + 0.5,\n            f\"+{round(positive_bottom, 2)}\",\n            ha=\"center\",\n            va=\"bottom\",\n            size=\"small\",\n            #rotation=90,\n        )\n    if negative_top &gt; 0:\n        ax.text(\n            i + 0.2,\n            - negative_top - 2,\n            f\"–{round(negative_top, 2)}\",\n            ha=\"center\",\n            va=\"bottom\",\n            size=\"small\",\n            #rotation=90,\n        )\n    if positive_bottom &gt; 0 and negative_top &gt; 0:\n        net_value = round(positive_bottom - negative_top, 2)\n        if net_value &lt; 0:\n            ax.text(\n                i - 0.0,\n                22,\n                f\"–{abs(net_value)}\",\n                ha=\"center\",\n                va=\"center\",\n                size=\"small\",\n            )\n        else:\n            ax.text(\n                i - 0.0,\n                22,\n                f\"+{net_value}\",\n                ha=\"center\",\n                va=\"center\",\n                size=\"small\",\n            )\n    ax.text(-0.45, 22, \"Net:\", ha=\"center\", va=\"center\", size=\"small\")\n\n\npatchList = []\nfor key in legend_colours:\n    data_key = mpatches.Patch(color=legend_colours[key], label=key)\n    patchList.append(data_key)\n\nax.legend(handles=patchList, loc=\"center left\", bbox_to_anchor=(1.1, 0.5))\n\n\nax.set_xlim(-0.7, 5.7)\nax.set_ylim(-15, 30)\nax.spines[\"bottom\"].set_visible(False)\nax.spines[\"left\"].set_bounds(-15, 30)\nax.set_xticks([])  # range(len(budget_df.columns)))\nax.set_xticklabels([])  # [atpase_labelling[scenario[1]] for scenario in budget_df.columns])\n\nax.hlines(0, -0.5, 7.5, color=\"black\", linewidth=0.5)\n\nax.set_ylabel(\n    \"Hexose equivalents \\n exported (+) or imported (–) \\n by GC during the day phase \\n\" r\"(fmol$\\cdot$GC$^{-1}$)\",\n    labelpad=15,\n)\n\n#ax.set_title('Day', pad=10)\n\n# fig.text(-0.02,0.25, \"Hexose equivalents imported (+) \\n or exported (-) by GC \" r\"(nmoles$\\cdot$GC$^{-1}$)\", rotation=90, va=\"center\", ha=\"center\", size=\"large\")\n\nfig.savefig(f\"../plant_cell_paper/figure_6.svg\", bbox_inches=\"tight\")\nfig.savefig(f\"../plant_cell_paper/figure_6.png\", dpi=300, bbox_inches=\"tight\")\n\n\n\n\n\n\n\n\n\natp_budget_df_reordered_nmoles_gc = atp_budget_df_reordered_nmoles_gc.loc[:, atp_budget_df_reordered_nmoles_gc.columns.get_level_values(1) != 'unconstrained']\n\n\nnadh_nadph_budget_df_reordered_nmoles_gc = nadh_nadph_budget_df_reordered_nmoles_gc.loc[:, nadh_nadph_budget_df_reordered_nmoles_gc.columns.get_level_values(1) != 'unconstrained']\n\n\nmetabolites = [\"ATP\", \"NAD(P)H\"]\nphases = [\"Opening\", \"Day\"]\nhatches = {\"wt\": None, \"starchko\": \"//\"}\natpase_labelling = {\"unconstrained\": \"–\", \"constrained\": \"+\"}\n\nfig, axs = plt.subplots(2, 2, figsize=(8, 8), sharex=True, sharey=\"row\")\nplt.subplots_adjust(hspace=0.1)\n\ncolour_rectangles_thickness = 4 / (75 * 2)\n\nfor y, metabolite in enumerate([atp_budget_df_reordered_nmoles_gc, nadh_nadph_budget_df_reordered_nmoles_gc]):\n    for x, phase in enumerate([2, 3]):\n        budget_df = metabolite.xs(phase, level=\"Phase\")\n        ax = axs[y][x]\n   \n        if y == 0:\n            for x1, x2, colour in zip([-0.5, 1.5, 3.5], [1.5, 3.5, 5.5], [\"#004488\", \"white\", \"#DDDDDD\"]):\n                ax.fill_betweenx(\n                    [30 - colour_rectangles_thickness * 30 * 2, 30],\n                    x1,\n                    x2,\n                    alpha=1,\n                    color=colour,\n                    linewidth=0.5,\n                    edgecolor=\"black\",\n                )\n            for i in range(6):\n                if i % 2 == 0:\n                    ax.text(i-0.3, 30-5, \"WT\")\n                else:\n                    ax.text(i-0.3, 30-5, \"KO\")\n        if y == 1:\n            for x1, x2, colour in zip([-0.5, 1.5, 3.5], [1.5, 3.5, 5.5], [\"#004488\", \"white\", \"#DDDDDD\"]):\n                ax.fill_betweenx(\n                    [15 - colour_rectangles_thickness * 15 * 2, 15],\n                    x1,\n                    x2,\n                    alpha=1,\n                    color=colour,\n                    linewidth=0.5,\n                    edgecolor=\"black\",\n                )\n            for i in range(6):\n                if i % 2 == 0:\n                    ax.text(i-0.3, 15-5/2, \"WT\")\n                else:\n                    ax.text(i-0.3, 15-5/2, \"KO\")\n        for i, scenario in enumerate(budget_df.columns):\n            positive_bottom = 0\n            negative_top = 0\n            scenario_df = budget_df.loc[:, scenario]\n            for reaction in scenario_df.index:\n                value = scenario_df.loc[reaction]\n                if value &gt; 0.00001:\n                    ax.bar(\n                        i,\n                        value,\n                        bottom=positive_bottom,\n                        color=reaction_colours[reaction][1],\n                        linewidth=0.1,\n                        hatch=hatches[scenario[2]],\n                    )\n                    positive_bottom += value\n                elif value &lt; 0.00001:\n                    ax.bar(\n                        i,\n                        value,\n                        bottom=negative_top,\n                        color=reaction_colours[reaction][0],\n                        linewidth=0.1,\n                        hatch=hatches[scenario[2]],\n                    )\n                    negative_top += value\n\n        ax.set_xticks([])  # range(len(budget_df.columns)))\n        ax.set_xticklabels([])  # [atpase_labelling[scenario[1]] for scenario in budget_df.columns])\n\n        if y == 0:\n            ax.set_title(phases[x], pad=10)\n        if x == 0:\n            ax.set_ylabel(metabolites[y])\n\n        ax.set_xlim(-0.70, 5.7)\n        if y == 0:\n            ax.set_ylim(-30, 30)\n            ax.spines[\"bottom\"].set_visible(False)\n            ax.spines[\"left\"].set_bounds(-30, 30)\n            ax.yaxis.set_major_locator(MultipleLocator(10))\n        if y == 1:\n            ax.set_ylim(-15, 15)\n            ax.spines[\"bottom\"].set_visible(False)\n            ax.spines[\"left\"].set_bounds(-15, 15)\n            ax.yaxis.set_major_locator(MultipleLocator(5))\n\n        ax.hlines(0, -0.5, 5.5, color=\"black\", linewidth=0.5)\n        \n\n        \n#starch_condition = {\"wt\": \"WT\", \"starchko\": \"KO\"}[scenario_df.name[2]]\n#ax.text(i, -1.5, starch_condition, ha=\"center\", va=\"center\", size=\"small\")\n\nfig.text(\n    -0.02,\n    0.5,\n    r\"Rate of production/consumption of energy\" \"\\n\" \"and reducing power (fmol$\\cdot$GC$^{-1}\\cdot$h$^{-1}$)\",\n    rotation=90,\n    va=\"center\",\n    ha=\"center\",\n    size=\"large\",\n)\n\npatchList = []\nfor key in colours_legend:\n    data_key = mpatches.Patch(color=colours_legend[key], label=key)\n    patchList.append(data_key)\n\nfig.legend(handles=patchList, loc=\"center left\", bbox_to_anchor=(0.925, 0.53))\n\ni = 0\nfor y in range(2):\n    for x in range(2):\n        ax = axs[y][x]\n        letter = string.ascii_uppercase[i]\n        if x == 0:\n            ax.text(-0.3, 1, letter, size=\"x-large\", weight=\"bold\", transform=ax.transAxes)\n        elif x == 1:\n            ax.text(-0.1, 1, letter, size=\"x-large\", weight=\"bold\", transform=ax.transAxes)\n        i += 1\n\nfig.savefig(f\"../plant_cell_paper/figure_5.svg\", bbox_inches=\"tight\")\nfig.savefig(f\"../plant_cell_paper/figure_5.png\", dpi=300, bbox_inches=\"tight\")\n\n\n\n\n\n\n\n\n\nbudget_df.columns[2]\n\n('white', 'constrained', 'wt')\n\n\n\ncarbon_rank = gc_carbon_production_consumption_nmoles_gc.sum().rank(ascending=False)\n\n\natp_2_rank = abs(atp_budget_df_reordered_nmoles_gc).xs(2, level=\"Phase\").sum().rank(ascending=False)\natp_3_rank = abs(atp_budget_df_reordered_nmoles_gc).xs(3, level=\"Phase\").sum().rank(ascending=False)\natp_rank = (\n    (\n        abs(atp_budget_df_reordered_nmoles_gc).xs(3, level=\"Phase\") * 0.5\n        + abs(atp_budget_df_reordered_nmoles_gc).xs(3, level=\"Phase\") * 11.5\n    )\n    .sum()\n    .rank(ascending=False)\n)\n\n\nnad_2_rank = abs(nadh_nadph_budget_df_reordered_nmoles_gc).xs(2, level=\"Phase\").sum().rank(ascending=False)\nnad_3_rank = abs(nadh_nadph_budget_df_reordered_nmoles_gc).xs(3, level=\"Phase\").sum().rank(ascending=False)\nnad_rank = (\n    (\n        abs(nadh_nadph_budget_df_reordered_nmoles_gc).xs(3, level=\"Phase\") * 0.5\n        + abs(nadh_nadph_budget_df_reordered_nmoles_gc).xs(3, level=\"Phase\") * 11.5\n    )\n    .sum()\n    .rank(ascending=False)\n)\n\n\npd.concat(\n    [carbon_rank, atp_2_rank, atp_3_rank, atp_rank, nad_2_rank, nad_3_rank, nad_rank],\n    axis=1,\n    keys=[\"Carbon\", \"ATP 2\", \"ATP 3\", \"ATP Day\", \"NAD 2\", \"NAD 3\", \"NAD Day\"],\n).sort_values(\"Carbon\")\n\n\n\n\n\n\n\n\n\n\nCarbon\nATP 2\nATP 3\nATP Day\nNAD 2\nNAD 3\nNAD Day\n\n\nLight\nATPase\nStarch\n\n\n\n\n\n\n\n\n\n\n\nwhite\nconstrained\nwt\n1.0\n1.0\n3.0\n3.0\n1.0\n3.0\n3.0\n\n\nstarchko\n2.0\n3.0\n1.0\n1.0\n2.0\n1.0\n1.0\n\n\nblue\nconstrained\nwt\n3.0\n4.0\n4.0\n4.0\n4.0\n4.0\n4.0\n\n\nstarchko\n4.0\n6.0\n2.0\n2.0\n6.0\n2.0\n2.0\n\n\nnops\nconstrained\nwt\n5.0\n2.0\n6.0\n6.0\n3.0\n6.0\n6.0\n\n\nstarchko\n6.0\n5.0\n5.0\n5.0\n5.0\n5.0\n5.0\n\n\n\n\n\n\n\n\nStarch KO leads to lower carbon consumption and higher ATP and NAD turnover\nConstraining ATPase leads to lower efficiency and higher ATP and NAD turnover\nPS is more complicated because it’s both phases, so won’t include\n\nRemoving it vs blue eads to",
    "crumbs": [
      "Solving and analysing specific scenarios for paper",
      "Analysing solutions"
    ]
  },
  {
    "objectID": "2.2_analysingsolutions.html#bits-and-bobs-for-paper",
    "href": "2.2_analysingsolutions.html#bits-and-bobs-for-paper",
    "title": "Analysing solutions",
    "section": "Bits and bobs for paper",
    "text": "Bits and bobs for paper\n\nblue_constrained_wt_osmolytes = met_df_mm.loc[:, (\"blue\", \"constrained\", \"wt\", \"fluxes\")].unstack()\nos_fraction = (\n    (blue_constrained_wt_osmolytes.loc[6.5] - blue_constrained_wt_osmolytes.loc[6.0])\n    / (blue_constrained_wt_osmolytes.loc[6.5] - blue_constrained_wt_osmolytes.loc[6.0]).sum()\n    * 100\n)\nos_fraction\n\nReaction\nCIT        -4.552019\nCl         28.223095\nFRU        12.619461\nGLC        49.860068\nK          26.428299\nMAL         1.959532\nSTARCH     -0.009450\nSUCROSE   -14.528986\ndtype: float64\n\n\n\nblue_constrained_wt_osmolytes\n\n\n\n\n\n\n\nReaction\nCIT\nCl\nFRU\nGLC\nK\nMAL\nSTARCH\nSUCROSE\n\n\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\n1.555385\n13.391074\n0.659272\n0.000000\n20.798763\n9.601548\n0.005126\n7.881207\n\n\n6.0\n2.469230\n13.949171\n0.000000\n0.000000\n21.356860\n8.230780\n0.005126\n7.881207\n\n\n6.5\n0.000000\n29.258708\n6.845391\n27.046452\n35.692816\n9.293723\n0.000000\n0.000000\n\n\n18.0\n0.000000\n12.672379\n1.318969\n0.000000\n20.080068\n11.934624\n0.005126\n7.881207\n\n\n24.0\n1.555385\n13.391074\n0.659272\n0.000000\n20.798763\n9.601548\n0.005126\n7.881207\n\n\n\n\n\n\n\n\nPercentage of osmotic pressure from KCl in blue light WT\n\nos_fraction.loc[\"Cl\"] + os_fraction.loc[\"K\"]\n\n54.651393996518046\n\n\n\n\nChanges in concentrations of KCl and citrate in blue light WT\n\n(blue_constrained_wt_osmolytes.loc[6.5] - blue_constrained_wt_osmolytes.loc[6.0]).loc[\"Cl\"] + (\n    blue_constrained_wt_osmolytes.loc[6.5] - blue_constrained_wt_osmolytes.loc[6.0]\n).loc[\"K\"]\n\n29.645493064091305\n\n\n\n(blue_constrained_wt_osmolytes.loc[6.5] - blue_constrained_wt_osmolytes.loc[6.0]).loc[\"CIT\"]\n\n-2.469229739192378\n\n\n\nsolutions_df\n\n\n\n\n\n\n\n\nLight\nblue\n...\nnops\n\n\n\nATPase\nunconstrained\nconstrained\n...\nunconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\n...\nwt\nstarchko\nwt\nstarchko\n\n\n\nSolution\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\n...\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEX_X_pi_t_me\n1\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\n2\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\n3\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\n4\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nEX_X_pi_t_gc\n1\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nCl_total_pseudolinker\n4\n0.003642\nNaN\nNaN\n0.004839\nNaN\nNaN\n0.002951\nNaN\nNaN\n0.000158\n...\nNaN\n0.000654\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nCIT_total_pseudolinker\n1\n0.000559\n0.0\n0.010896\n0.000000\n0.0\n0.010896\n0.000544\n0.0\n0.010896\n0.000408\n...\n0.010896\n0.000534\n0.0\n0.010896\n0.000612\n0.0\n0.010896\n0.000543\n0.0\n0.010896\n\n\n2\n0.000000\n0.0\n0.011386\n0.000000\n0.0\n0.011386\n0.000000\n0.0\n0.011386\n0.000000\n...\n0.011386\n0.000000\n0.0\n0.011386\n0.000000\n0.0\n0.011386\n0.000000\n0.0\n0.009964\n\n\n3\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000534\nNaN\nNaN\n0.000612\nNaN\nNaN\n0.000543\nNaN\nNaN\n\n\n4\n0.000315\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000343\nNaN\nNaN\n0.000343\n...\nNaN\n0.000534\nNaN\nNaN\n0.000612\nNaN\nNaN\n0.000543\nNaN\nNaN\n\n\n\n\n7101 rows × 36 columns\n\n\n\n\n\nImport same amount of KCl from apoplast between wt and starchko for constrained ATPase\n\n(\n    solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"K_ec_gc\", 2), :]\n    + solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"Cl_PROTON_ec_gc\", 2), :]\n)\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.023791\n                      starchko    0.024396\n       constrained    wt          0.013050\n                      starchko    0.013050\nwhite  unconstrained  wt          0.024203\n                      starchko    0.024209\n       constrained    wt          0.013050\n                      starchko    0.013050\nnops   unconstrained  wt          0.022778\n                      starchko    0.022778\n       constrained    wt          0.013050\n                      starchko    0.013050\ndtype: float64\n\n\n\nblue_constrained_starchko_osmolytes = met_df_mm.loc[:, (\"blue\", \"constrained\", \"starchko\", \"fluxes\")].unstack()\nos_fraction = (\n    (blue_constrained_wt_osmolytes.loc[6.5] - blue_constrained_wt_osmolytes.loc[6.0])\n    / (blue_constrained_wt_osmolytes.loc[6.5] - blue_constrained_wt_osmolytes.loc[6.0]).sum()\n    * 100\n)\nos_fraction\n\nReaction\nCIT        -4.552019\nCl         28.223095\nFRU        12.619461\nGLC        49.860068\nK          26.428299\nMAL         1.959532\nSTARCH     -0.009450\nSUCROSE   -14.528986\ndtype: float64\n\n\n\n\nProportion of sucrose accumulation overnight between WT and starchko in blue light\n\nblue_constrained_starchko_osmolytes.loc[6.0].loc['SUCROSE']/blue_constrained_wt_osmolytes.loc[6.0].loc['SUCROSE']\n\n3.951044937318112\n\n\n\n\nConcentration of glucose & fructose in blue starch KO (all in v, no c)\n\nblue_constrained_starchko_osmolytes.loc[6.5].loc['GLC'] + blue_constrained_starchko_osmolytes.loc[6.5].loc['FRU']\n\n54.09289836861832\n\n\n\nblue_constrained_wt_osmolytes.loc[[6, 6.5]]\n\n\n\n\n\n\n\nReaction\nCIT\nCl\nFRU\nGLC\nK\nMAL\nSTARCH\nSUCROSE\n\n\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\n6.0\n2.46923\n13.949171\n0.000000\n0.000000\n21.356860\n8.230780\n0.005126\n7.881207\n\n\n6.5\n0.00000\n29.258708\n6.845391\n27.046452\n35.692816\n9.293723\n0.000000\n0.000000\n\n\n\n\n\n\n\n\n\nCompare sucrose accumulation between starch KO and WT in blue light\n\nblue_constrained_starchko_osmolytes.loc[6.0].loc['SUCROSE']/blue_constrained_wt_osmolytes.loc[6.0].loc['SUCROSE']\n\n3.951044937318112\n\n\n\nwhite_constrained_wt_osmolytes = met_df_mm.loc[:, (\"white\", \"constrained\", \"wt\", \"fluxes\")].unstack()\nwhite_constrained_starchko_osmolytes = met_df_mm.loc[:, (\"white\", \"constrained\", \"starchko\", \"fluxes\")].unstack()\n\n\nwhite_constrained_wt_osmolytes.loc[[6, 6.5]]\n\n\n\n\n\n\n\nReaction\nCIT\nCl\nFRU\nGLC\nK\nMAL\nSTARCH\nSUCROSE\n\n\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\n6.0\n0.0\n4.731174\n0.000000\n0.000000\n4.731174\n0.0\n0.005417\n6.148247\n\n\n6.5\n0.0\n21.252220\n7.481205\n24.905437\n21.252220\n0.0\n0.000000\n0.000000\n\n\n\n\n\n\n\n\nnops_constrained_wt_osmolytes = met_df_mm.loc[:, (\"nops\", \"constrained\", \"wt\", \"fluxes\")].unstack()\nnops_constrained_starchko_osmolytes = met_df_mm.loc[:, (\"nops\", \"constrained\", \"starchko\", \"fluxes\")].unstack()\n\n\nnops_constrained_wt_osmolytes.loc[[6, 6.5]]\n\n\n\n\n\n\n\nReaction\nCIT\nCl\nFRU\nGLC\nK\nMAL\nSTARCH\nSUCROSE\n\n\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\n6.0\n2.77789\n0.000000\n0.000000\n0.000000\n8.333669\n0.000000\n0.002569\n18.787893\n\n\n6.5\n0.00000\n17.142857\n16.318627\n25.840051\n24.381244\n3.619193\n0.000000\n0.000000\n\n\n\n\n\n\n\n\nnops_constrained_starchko_osmolytes.loc[[6, 6.5]]\n\n\n\n\n\n\n\nReaction\nCIT\nCl\nFRU\nGLC\nK\nMAL\nSTARCH\nSUCROSE\n\n\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\n6.0\n2.465388\n0.000000\n0.000000\n0.000000\n7.396173\n8.217966\n0.0\n31.139004\n\n\n6.5\n0.000000\n17.142857\n27.046449\n27.046449\n23.566961\n9.279256\n0.0\n0.000000\n\n\n\n\n\n\n\n\n\nCompare sucrose and starch between white and blue light in WT\n\n(white_constrained_wt_osmolytes.loc[6.0].loc['SUCROSE']/blue_constrained_wt_osmolytes.loc[6.0].loc['SUCROSE'])-1\n\n-0.2198850653158203\n\n\n\n(white_constrained_wt_osmolytes.loc[6.0].loc['STARCH']/blue_constrained_wt_osmolytes.loc[6.0].loc['STARCH'])-1\n\n0.0568466742650342\n\n\n\n\nAmount of C fixed in photosynthesis vs starch accumulation in WT white light\n\nwhite_wt_rubisco = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"RIBULOSE_BISPHOSPHATE_CARBOXYLASE_RXN_p_gc\", 2), :].loc['white'].loc['constrained'].loc['wt']\nwhite_ko_rubisco = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"RIBULOSE_BISPHOSPHATE_CARBOXYLASE_RXN_p_gc\", 2), :].loc['white'].loc['constrained'].loc['starchko']\n\n\nwhite_wt_rubisco/(white_constrained_wt_osmolytes.loc[6.0].loc['STARCH']*6)\n\n0.0334281119955182\n\n\n\n\nCompare K and Cl import into vacuole in white light WT vs starch KO\n\nwhite_wt_k_cv = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"K_PROTON_cv_gc\", 2), :].loc['white'].loc['constrained'].loc['wt']\nwhite_ko_k_cv = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"K_PROTON_cv_gc\", 2), :].loc['white'].loc['constrained'].loc['starchko']\nwhite_wt_cl_cv = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"Cl_cv_gc\", 2), :].loc['white'].loc['constrained'].loc['wt']\nwhite_ko_cl_cv = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"Cl_cv_gc\", 2), :].loc['white'].loc['constrained'].loc['starchko']\n\n\n(white_ko_k_cv+white_ko_cl_cv)/(white_wt_k_cv+white_wt_cl_cv) - 1\n\n-0.5473616726045913\n\n\n\n\nCompare vacuolar sucrose degradation in white light WT vs starch KO\n\n(white_constrained_starchko_osmolytes.loc[6.0].loc['SUCROSE']-white_constrained_starchko_osmolytes.loc[6.5].loc['SUCROSE'])/(white_constrained_wt_osmolytes.loc[6.0].loc['SUCROSE']-white_constrained_wt_osmolytes.loc[6.5].loc['SUCROSE'])\n\n4.985920298831731\n\n\n\n\nCompare C fixation in white light WT vs starch KO\n\nwhite_ko_rubisco/white_wt_rubisco - 1\n\n0.2618307571821368\n\n\n\n\nSource of glucose in No PS WT\n\nnops_wt_glc_c = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"GLC_c_gc_Linker\", 2), :].loc['nops'].loc['constrained'].loc['wt']\nnops_wt_glc_v = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"GLC_v_gc_Linker\", 2), :].loc['nops'].loc['constrained'].loc['wt']\n\n\nnops_wt_glc_c/(nops_wt_glc_c+nops_wt_glc_v)\n\n0.7721610472841978\n\n\n\nnops_wt_suc_c = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"SUCROSE_c_gc_Linker\", 1), :].loc['nops'].loc['constrained'].loc['wt']\nnops_wt_suc_v = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"SUCROSE_v_gc_Linker\", 1), :].loc['nops'].loc['constrained'].loc['wt']\nnops_wt_starch_c = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"STARCH_p_gc_Linker\", 1), :].loc['nops'].loc['constrained'].loc['wt']\n\n\nnops_wt_starch_c / nops_wt_glc_c\n\n0.5074317369423402\n\n\n\nnops_wt_glc_from_suc = nops_wt_glc_c + nops_wt_glc_v - nops_wt_starch_c\n\n\n1 - nops_wt_glc_v / nops_wt_glc_from_suc\n\n0.6253763916642779\n\n\n\nnops_wt_inv_c = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"RXN_1461_c_gc\", 2), :].loc['nops'].loc['constrained'].loc['wt']\nnops_wt_inv_v = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"RXN_1461_v_gc\", 2), :].loc['nops'].loc['constrained'].loc['wt']\nnops_wt_inv_c / (nops_wt_inv_c + nops_wt_inv_v)\n\n0.6392239144307732\n\n\n\n\nMaltose brakdown in No PS WT\n\nnops_wt_starch_deg = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"RXN_1827_p_gc\", 2), :].loc['nops'].loc['constrained'].loc['wt']\nnops_wt_maltose_deg = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"MALTODEG_RXN_c_gc\", 2), :].loc['nops'].loc['constrained'].loc['wt']\nnops_wt_maltose_deg / nops_wt_starch_deg\n\n0.11915483203166444\n\n\n\n\nProportional of K+ imported in No PS starch KO remains in cytosol during Opening\n\nnops_ko_k_v_2 = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"K_v_gc_Linker\", 2), :].loc['nops'].loc['constrained'].loc['starchko']\nnops_ko_k_c_2 = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"K_c_gc_Linker\", 2), :].loc['nops'].loc['constrained'].loc['starchko']\nnops_ko_k_v_1 = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"K_v_gc_Linker\", 1), :].loc['nops'].loc['constrained'].loc['starchko']\nnops_ko_k_c_1 = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"K_c_gc_Linker\", 1), :].loc['nops'].loc['constrained'].loc['starchko']\n\n\nkv = (nops_ko_k_v_2 - nops_ko_k_v_1)\nkc = (nops_ko_k_c_2 - nops_ko_k_c_1)\nkc / (kc+kv)\n\n0.7078404702955794\n\n\n\n\nInvertase in starch KO vs WT in No PS\n\nnops_wt_inv2_v = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"RXN_1781_v_gc\", 2), :].loc['nops'].loc['constrained'].loc['wt']\nnops_wt_inv_v = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"RXN_1461_v_gc\", 2), :].loc['nops'].loc['constrained'].loc['wt']\nnops_ko_inv2_v = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"RXN_1781_v_gc\", 2), :].loc['nops'].loc['constrained'].loc['starchko']\nnops_ko_inv_v = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"RXN_1461_v_gc\", 2), :].loc['nops'].loc['constrained'].loc['starchko']\n(nops_ko_inv_v + nops_ko_inv2_v) / (nops_wt_inv_v + nops_wt_inv2_v)\n\n3.2287468012696294\n\n\n\n#nops_wt_inv2_c = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"RXN_1781_c_gc\", 2), :].loc['nops'].loc['constrained'].loc['wt']\nnops_wt_inv_c = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"RXN_1461_c_gc\", 2), :].loc['nops'].loc['constrained'].loc['wt']\n#nops_ko_inv2_c = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"RXN_1781_c_gc\", 2), :].loc['nops'].loc['constrained'].loc['starchko']\nnops_ko_inv_c = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"RXN_1461_c_gc\", 2), :].loc['nops'].loc['constrained'].loc['starchko']\n#(nops_ko_inv_c + nops_ko_inv2_c) / (nops_wt_inv_c + nops_wt_inv2_c)\nnops_ko_inv_c/nops_wt_inv_c\n\n0.770532431827499\n\n\n\nnops_wt_hatp_v = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"PROTONATP_rev_vc_gc\", 2), :].loc['nops'].loc['constrained'].loc['wt']\nnops_ko_hatp_v = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"PROTONATP_rev_vc_gc\", 2), :].loc['nops'].loc['constrained'].loc['starchko']\n(nops_ko_hatp_v - nops_wt_hatp_v) / nops_wt_hatp_v\n\n-0.25981376726817995\n\n\n\nblue_constrained_starchko_osmolytes.loc[[6, 6.5]]\n\n\n\n\n\n\n\nReaction\nCIT\nCl\nFRU\nGLC\nK\nMAL\nSTARCH\nSUCROSE\n\n\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\n6.0\n1.849573\n1.121672\n0.000000\n0.000000\n6.670390\n6.165242\n0.0\n31.139004\n\n\n6.5\n0.000000\n18.117110\n27.046449\n27.046449\n22.936568\n6.961439\n0.0\n0.000000\n\n\n\n\n\n\n\n\nwhite_constrained_starchko_osmolytes.loc[[6, 6.5]]\n\n\n\n\n\n\n\nReaction\nCIT\nCl\nFRU\nGLC\nK\nMAL\nSTARCH\nSUCROSE\n\n\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\n6.0\n0.0\n0.658664\n0.000000\n0.000000\n0.658664\n0.0\n0.0\n30.879805\n\n\n6.5\n0.0\n17.714954\n26.821316\n26.821316\n17.714954\n0.0\n0.0\n0.225133\n\n\n\n\n\n\n\n\nmet_df.loc[:, (\"white\", \"constrained\")].xs(\"fluxes\", level=\"Solution\", axis=1).loc[([6.0, 6.5], \"STARCH\"), :]\n\n/tmp/ipykernel_5280/1419630875.py:1: PerformanceWarning: indexing past lexsort depth may impact performance.\n  met_df.loc[:, (\"white\", \"constrained\")].xs(\"fluxes\", level=\"Solution\", axis=1).loc[([6.0, 6.5], \"STARCH\"), :]\n\n\n\n\n\n\n\n\n\nStarch\nwt\nstarchko\n\n\nPhase\nReaction\n\n\n\n\n\n\n6.0\nSTARCH\n0.005417\n0.0\n\n\n6.5\nSTARCH\n0.000000\n0.0\n\n\n\n\n\n\n\n\n(0.005417 * 10**-3 / arabidopsis_supermodel.N_gcs) * 10**15\n\n9.339655172413792\n\n\n\n27.828905 * 2\n\n55.65781\n\n\n\nmet_df.loc[:, (\"blue\", \"constrained\")].xs(\"fluxes\", level=\"Solution\", axis=1).loc[([6.0, 6.5], \"STARCH\"), :]\n\n/tmp/ipykernel_5280/2596957767.py:1: PerformanceWarning: indexing past lexsort depth may impact performance.\n  met_df.loc[:, (\"blue\", \"constrained\")].xs(\"fluxes\", level=\"Solution\", axis=1).loc[([6.0, 6.5], \"STARCH\"), :]\n\n\n\n\n\n\n\n\n\nStarch\nwt\nstarchko\n\n\nPhase\nReaction\n\n\n\n\n\n\n6.0\nSTARCH\n0.005126\n0.0\n\n\n6.5\nSTARCH\n0.000000\n0.0\n\n\n\n\n\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"PROTON_ATPase_c_gc\", 2), :]\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.007930\n                      starchko    0.008132\n       constrained    wt          0.004350\n                      starchko    0.004350\nwhite  unconstrained  wt          0.008068\n                      starchko    0.008070\n       constrained    wt          0.004350\n                      starchko    0.004350\nnops   unconstrained  wt          0.008348\n                      starchko    0.008348\n       constrained    wt          0.004350\n                      starchko    0.004350\nName: (PROTON_ATPase_c_gc, 2), dtype: float64\n\n\n\npm_proton_pump = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"PROTONATP_rev_vc_gc\", 2), :]\nfor value in pm_proton_pump.values:\n    print(\"{0:.10f}\".format(value))\n\n0.0041802388\n0.0036862060\n0.0043404882\n0.0019368152\n0.0032286510\n0.0032122774\n0.0053927508\n0.0018125633\n0.0052209173\n0.0052208545\n0.0058439202\n0.0043255893\n\n\n\ntonoplast_proton_pump = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"PROTON_PPi_rev_vc_gc\", 2), :]\ntonoplast_proton_pump\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.000357\n                      starchko    0.000588\n       constrained    wt          0.000000\n                      starchko    0.000000\nwhite  unconstrained  wt          0.001561\n                      starchko    0.001568\n       constrained    wt          0.000000\n                      starchko    0.001257\nnops   unconstrained  wt          0.000000\n                      starchko    0.000000\n       constrained    wt          0.000000\n                      starchko    0.000000\nName: (PROTON_PPi_rev_vc_gc, 2), dtype: float64\n\n\n\n(pm_proton_pump + tonoplast_proton_pump).plot.bar()\n\n\n\n\n\n\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"PHOSGLYPHOS_RXN_c_gc\", 2), :]\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.000476\n                      starchko    0.000784\n       constrained    wt          0.000000\n                      starchko    0.000000\nwhite  unconstrained  wt          0.000000\n                      starchko    0.000000\n       constrained    wt          0.000000\n                      starchko    0.000000\nnops   unconstrained  wt         -0.000262\n                      starchko   -0.000262\n       constrained    wt         -0.000612\n                      starchko    0.000000\nName: (PHOSGLYPHOS_RXN_c_gc, 2), dtype: float64\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"2PGADEHYDRAT_RXN_c_gc\", 2), :]\n\nLight  ATPase         Starch  \nblue   unconstrained  wt         -0.000476\n                      starchko   -0.000784\n       constrained    wt          0.000000\n                      starchko    0.000000\nwhite  unconstrained  wt         -0.000499\n                      starchko   -0.001138\n       constrained    wt          0.000000\n                      starchko    0.000000\nnops   unconstrained  wt          0.000262\n                      starchko    0.000262\n       constrained    wt          0.000612\n                      starchko    0.000000\nName: (2PGADEHYDRAT_RXN_c_gc, 2), dtype: float64\n\n\nMALATE_DEH_RXN_c_gc## Fraction is ATPase vs PPi for tonoplast\n\npm_proton_pump / (pm_proton_pump + tonoplast_proton_pump) * 100\n\nLight  ATPase         Starch  \nblue   unconstrained  wt           92.128349\n                      starchko     86.237209\n       constrained    wt          100.000000\n                      starchko    100.000000\nwhite  unconstrained  wt           67.407580\n                      starchko     67.194792\n       constrained    wt          100.000000\n                      starchko     59.053306\nnops   unconstrained  wt          100.000000\n                      starchko    100.000000\n       constrained    wt          100.000000\n                      starchko    100.000000\ndtype: float64\n\n\n\nplastidatp_reactions = [\n    reaction.id[:-2] for reaction in arabidopsis_supermodel.fba_model.metabolites.ATP_p_gc_2.reactions\n]\nplastidatp_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(plastidatp_reactions, 2), :]\nplastidatp_df = plastidatp_df.loc[~(abs(plastidatp_df) &lt; 0.0000000001).all(axis=1)]\nplastidatp_df.mask(abs(plastidatp_df) &lt; 0.0000000001, 0).drop(\n    [(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1\n)\n\n/tmp/ipykernel_5280/2746888614.py:6: PerformanceWarning: indexing past lexsort depth may impact performance.\n  plastidatp_df.mask(abs(plastidatp_df) &lt; 0.0000000001, 0).drop(\n\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\nPlastidial_ATP_Synthase_p_gc\n2\n0.0\n0.0\n0.0\n0.0\n0.001968\n0.001968\n0.0\n0.0\n\n\nPHOSGLYPHOS_RXN_p_gc\n2\n0.0\n0.0\n0.0\n0.0\n0.002173\n0.002742\n0.0\n0.0\n\n\nPHOSPHORIBULOKINASE_RXN_p_gc\n2\n0.0\n0.0\n0.0\n0.0\n0.001087\n0.001371\n0.0\n0.0\n\n\nATP_ADP_Pi_pc_gc\n2\n0.0\n0.0\n0.0\n0.0\n0.002646\n0.001792\n0.0\n0.0\n\n\n\n\n\n\n\n\nplastidatp_reactions = [\n    reaction.id[:-2] for reaction in arabidopsis_supermodel.fba_model.metabolites.ATP_p_gc_2.reactions\n]\nplastidatp_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(plastidatp_reactions, 3), :]\nplastidatp_df = plastidatp_df.loc[~(abs(plastidatp_df) &lt; 0.0000000001).all(axis=1)]\nplastidatp_df.mask(abs(plastidatp_df) &lt; 0.0000000001, 0).drop(\n    [(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1\n)\n\n/tmp/ipykernel_5280/3411159466.py:6: PerformanceWarning: indexing past lexsort depth may impact performance.\n  plastidatp_df.mask(abs(plastidatp_df) &lt; 0.0000000001, 0).drop(\n\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\nGLUC1PADENYLTRANS_RXN_p_gc\n3\n0.000049\n0.000000\n0.000446\n0.000000\n0.000471\n0.000000\n0.000213\n0.0\n\n\nPEPDEPHOS_RXN_p_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000077\n0.0\n\n\nPlastidial_ATP_Synthase_p_gc\n3\n0.001968\n0.001968\n0.001968\n0.001968\n0.001968\n0.001968\n0.000000\n0.0\n\n\nPHOSGLYPHOS_RXN_p_gc\n3\n0.004054\n0.004049\n0.003958\n0.003864\n0.003975\n0.003881\n-0.000077\n0.0\n\n\nPHOSPHORIBULOKINASE_RXN_p_gc\n3\n0.002054\n0.002059\n0.001991\n0.001941\n0.001988\n0.001940\n0.000000\n0.0\n\n\nATP_ADP_Pi_pc_gc\n3\n-0.000251\n-0.000202\n-0.000489\n0.000101\n-0.000528\n0.000084\n-0.000059\n0.0\n\n\n\n\n\n\n\n\nplastidatp_reactions = [\n    reaction.id[:-2] for reaction in arabidopsis_supermodel.fba_model.metabolites.ATP_c_gc_3.reactions\n]\nplastidatp_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(plastidatp_reactions, 3), :]\nplastidatp_df = plastidatp_df.loc[~(abs(plastidatp_df) &lt; 0.0000000001).all(axis=1)]\nplastidatp_df.mask(abs(plastidatp_df) &lt; 0.0000000001, 0).drop(\n    [(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1\n)\n\n/tmp/ipykernel_5280/3582217826.py:6: PerformanceWarning: indexing past lexsort depth may impact performance.\n  plastidatp_df.mask(abs(plastidatp_df) &lt; 0.0000000001, 0).drop(\n\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\nATP_ADP_Pi_pc_gc\n3\n-0.000251\n-0.000202\n-0.000489\n0.000101\n-0.000528\n0.000084\n-0.000059\n0.000000\n\n\nATPase_tx_gc\n3\n0.000534\n0.000534\n0.000534\n0.000534\n0.000534\n0.000534\n0.000444\n0.000444\n\n\nATP_ADP_mc_gc\n3\n0.000918\n0.000891\n0.001300\n0.001601\n0.001320\n0.001603\n0.001150\n0.001343\n\n\nPYRUVATEORTHOPHOSPHATE_DIKINASE_RXN_c_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\nPROTONATP_rev_vc_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\n6PFRUCTPHOS_RXN_c_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\nATP_AMP_mc_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\nPEPDEPHOS_RXN_c_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000109\n\n\nPROTON_ATPase_c_gc\n3\n0.000000\n0.000000\n0.000151\n0.000154\n0.000118\n0.000142\n0.000291\n0.000310\n\n\nUDPKIN_RXN_c_gc\n3\n0.000133\n0.000154\n0.000000\n0.000443\n0.000000\n0.000445\n0.000033\n0.000249\n\n\nPHOSGLYPHOS_RXN_c_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n-0.000109\n\n\nFRUCTOKINASE_RXN_c_gc\n3\n0.000000\n0.000000\n0.000126\n0.000572\n0.000140\n0.000567\n0.000324\n0.000559\n\n\n\n\n\n\n\n\nplastidatp_reactions = [\n    reaction.id[:-2] for reaction in arabidopsis_supermodel.fba_model.metabolites.NADPH_p_gc_2.reactions\n]\nplastidatp_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(plastidatp_reactions, 3), :]\nplastidatp_df = plastidatp_df.loc[~(abs(plastidatp_df) &lt; 0.0000000001).all(axis=1)]\nplastidatp_df.mask(abs(plastidatp_df) &lt; 0.0000000001, 0).drop(\n    [(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1\n)\n\n/tmp/ipykernel_5280/2111125671.py:6: PerformanceWarning: indexing past lexsort depth may impact performance.\n  plastidatp_df.mask(abs(plastidatp_df) &lt; 0.0000000001, 0).drop(\n\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\nGLU6PDEHYDROG_RXN_p_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000012\n0.000014\n\n\n6PGLUCONDEHYDROG_RXN_p_gc\n3\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000012\n0.000014\n\n\n1_PERIOD_18_PERIOD_1_PERIOD_2_RXN_p_gc\n3\n0.004593\n0.004593\n0.004593\n0.004593\n0.004593\n0.004593\n0.000000\n0.000000\n\n\nMALATE_DEHYDROGENASE_NADPs_RXN_p_gc\n3\n0.000361\n0.000366\n0.000457\n0.000551\n0.000440\n0.000534\n0.000000\n0.000000\n\n\nNADPHox_p_tx_gc\n3\n0.000178\n0.000178\n0.000178\n0.000178\n0.000178\n0.000178\n0.000024\n0.000029\n\n\n1_PERIOD_2_PERIOD_1_PERIOD_13_RXN_p_gc\n3\n0.004054\n0.004049\n0.003958\n0.003864\n0.003975\n0.003881\n0.000000\n0.000000\n\n\n\n\n\n\n\n\nsolutions_df\n\n\n\n\n\n\n\n\nLight\nblue\n...\nnops\n\n\n\nATPase\nunconstrained\nconstrained\n...\nunconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\n...\nwt\nstarchko\nwt\nstarchko\n\n\n\nSolution\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\n...\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEX_X_pi_t_me\n1\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\n2\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\n3\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\n4\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nEX_X_pi_t_gc\n1\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nCl_total_pseudolinker\n4\n0.003642\nNaN\nNaN\n0.004839\nNaN\nNaN\n0.002951\nNaN\nNaN\n0.000158\n...\nNaN\n0.000654\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nCIT_total_pseudolinker\n1\n0.000559\n0.0\n0.010896\n0.000000\n0.0\n0.010896\n0.000544\n0.0\n0.010896\n0.000408\n...\n0.010896\n0.000534\n0.0\n0.010896\n0.000612\n0.0\n0.010896\n0.000543\n0.0\n0.010896\n\n\n2\n0.000000\n0.0\n0.011386\n0.000000\n0.0\n0.011386\n0.000000\n0.0\n0.011386\n0.000000\n...\n0.011386\n0.000000\n0.0\n0.011386\n0.000000\n0.0\n0.011386\n0.000000\n0.0\n0.009964\n\n\n3\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000534\nNaN\nNaN\n0.000612\nNaN\nNaN\n0.000543\nNaN\nNaN\n\n\n4\n0.000315\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000343\nNaN\nNaN\n0.000343\n...\nNaN\n0.000534\nNaN\nNaN\n0.000612\nNaN\nNaN\n0.000543\nNaN\nNaN\n\n\n\n\n7101 rows × 36 columns\n\n\n\n\nplastidatp_reactions = [\n    reaction.id[:-2] for reaction in arabidopsis_supermodel.fba_model.metabolites.NADH_c_gc_2.reactions\n]\nplastidatp_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(plastidatp_reactions, 2), :]\nplastidatp_df = plastidatp_df.loc[~(abs(plastidatp_df) &lt; 0.0000000001).all(axis=1)]\nplastidatp_df.mask(abs(plastidatp_df) &lt; 0.0000000001, 0).drop(\n    [(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1\n)\n\n/tmp/ipykernel_5280/1101100446.py:6: PerformanceWarning: indexing past lexsort depth may impact performance.\n  plastidatp_df.mask(abs(plastidatp_df) &lt; 0.0000000001, 0).drop(\n\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\nMALATE_DEH_RXN_c_gc\n2\n0.000476\n0.000784\n0.0\n0.0\n0.0\n0.0\n-0.000612\n0.0\n\n\nGAPOXNPHOSPHN_RXN_c_gc\n2\n-0.000476\n-0.000784\n0.0\n0.0\n0.0\n0.0\n0.000612\n0.0\n\n\n\n\n\n\n\n\n0.003478 - 0.002659\n\n0.0008190000000000003\n\n\n\n0.020457 + 0.010742\n\n0.031198999999999998\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"PROTON_ATPase_c_gc\", 2), :]\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.007930\n                      starchko    0.008132\n       constrained    wt          0.004350\n                      starchko    0.004350\nwhite  unconstrained  wt          0.008068\n                      starchko    0.008070\n       constrained    wt          0.004350\n                      starchko    0.004350\nnops   unconstrained  wt          0.008348\n                      starchko    0.008348\n       constrained    wt          0.004350\n                      starchko    0.004350\nName: (PROTON_ATPase_c_gc, 2), dtype: float64\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"MALATE_DEHYDROGENASE_NADPs_RXN_p_gc\", 2), :]\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.000000\n                      starchko    0.000000\n       constrained    wt          0.000000\n                      starchko    0.000000\nwhite  unconstrained  wt          0.002010\n                      starchko    0.002001\n       constrained    wt          0.002242\n                      starchko    0.001673\nnops   unconstrained  wt          0.000000\n                      starchko    0.000000\n       constrained    wt          0.000000\n                      starchko    0.000000\nName: (MALATE_DEHYDROGENASE_NADPs_RXN_p_gc, 2), dtype: float64\n\n\n\nfig, ax = plt.subplots()\n\ntonoplast_proton_transport_df = (\n    solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1)\n    .loc[([\"PROTON_PPi_rev_vc_gc\", \"PROTONATP_rev_vc_gc\"], 2), :]\n    .drop([(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1)\n)\ntonoplast_proton_transport_df.index = [\"PPi Pump\", \"ATPase Pump\"]\ntonoplast_proton_transport_df.T.plot(kind=\"bar\", stacked=True, ax=ax)\n\nax.set_ylabel(\"Flux (mmoles$\\cdot$m$^{-2}$$\\cdot$h$^{-1}$)\")\n\n/tmp/ipykernel_5280/377450841.py:4: PerformanceWarning: indexing past lexsort depth may impact performance.\n  solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1)\n\n\nText(0, 0.5, 'Flux (mmoles$\\\\cdot$m$^{-2}$$\\\\cdot$h$^{-1}$)')\n\n\n\n\n\n\n\n\n\n\ntonoplast_proton_transport_df\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\nATPase\nunconstrained\nconstrained\nconstrained\nconstrained\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\n\n\nPPi Pump\n0.000357\n0.000588\n0.00000\n0.000000\n0.000000\n0.001257\n0.000000\n0.000000\n\n\nATPase Pump\n0.004180\n0.003686\n0.00434\n0.001937\n0.005393\n0.001813\n0.005844\n0.004326\n\n\n\n\n\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[([\"PROTON_PPi_rev_vc_gc\", \"PROTONATP_rev_vc_gc\"], 2), :].drop(\n    [(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1\n).sum().plot.bar()\n\n/tmp/ipykernel_5280/1652154496.py:1: PerformanceWarning: indexing past lexsort depth may impact performance.\n  solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[([\"PROTON_PPi_rev_vc_gc\", \"PROTONATP_rev_vc_gc\"], 2), :].drop(\n\n\n\n\n\n\n\n\n\n\nppi_reactions = [reaction.id[:-2] for reaction in arabidopsis_supermodel.fba_model.metabolites.PPI_c_gc_2.reactions]\nppi_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(ppi_reactions, 2), :]\nppi_df = ppi_df.loc[~(abs(ppi_df) &lt; 0.0000000001).all(axis=1)]\nppi_df.mask(abs(ppi_df) &lt; 0.0000000001, 0).drop([(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1)\n\n/tmp/ipykernel_5280/4224157383.py:4: PerformanceWarning: indexing past lexsort depth may impact performance.\n  ppi_df.mask(abs(ppi_df) &lt; 0.0000000001, 0).drop([(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1)\n\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\nPROTON_PPi_rev_vc_gc\n2\n0.000357\n0.000588\n0.0\n0.0\n0.000000\n0.001257\n0.0\n0.0\n\n\nPYRUVATEORTHOPHOSPHATE_DIKINASE_RXN_c_gc\n2\n0.000000\n0.000000\n0.0\n0.0\n0.000000\n0.000000\n0.0\n0.0\n\n\nGLUC1PURIDYLTRANS_RXN_c_gc\n2\n0.000119\n0.000196\n0.0\n0.0\n-0.000905\n0.000114\n0.0\n0.0\n\n\n2_PERIOD_7_PERIOD_1_PERIOD_90_RXN_c_gc\n2\n-0.000238\n-0.000392\n0.0\n0.0\n-0.000905\n-0.001143\n0.0\n0.0\n\n\n\n\n\n\n\n\nppi_reactions = [reaction.id[:-2] for reaction in arabidopsis_supermodel.fba_model.metabolites.PPI_p_gc_2.reactions]\nppi_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(ppi_reactions, 2), :]\nppi_df = ppi_df.loc[~(abs(ppi_df) &lt; 0.0000000001).all(axis=1)]\nppi_df.mask(abs(ppi_df) &lt; 0.0000000001, 0).drop([(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1)\n\n/tmp/ipykernel_5280/1298146970.py:4: PerformanceWarning: indexing past lexsort depth may impact performance.\n  ppi_df.mask(abs(ppi_df) &lt; 0.0000000001, 0).drop([(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1)\n\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nboundary_reactions = [\n    reaction.id[:-2] for reaction in arabidopsis_supermodel.fba_model.reactions if \"_tx\" in reaction.id\n]\nnitrate_uptake = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"NITRATE_a_tx\", slice(None)), :]\nnitrate_uptake\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nunconstrained\nconstrained\nunconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNITRATE_a_tx\n1\n0.017802\n0.017802\n0.017802\n0.017802\n0.018684\n0.018684\n0.018684\n0.018684\n0.018683\n0.018683\n0.018683\n0.018683\n\n\n2\n0.053405\n0.053405\n0.053405\n0.053405\n0.236743\n0.236743\n0.236743\n0.236742\n0.236733\n0.236733\n0.236732\n0.236732\n\n\n3\n0.288754\n0.288754\n0.288754\n0.288754\n0.295351\n0.295351\n0.295350\n0.295350\n0.295338\n0.295338\n0.295337\n0.295337\n\n\n4\n0.012081\n0.012081\n0.012081\n0.012081\n0.012419\n0.012419\n0.012419\n0.012419\n0.012418\n0.012418\n0.012418\n0.012418\n\n\n\n\n\n\n\n\nfrom mmon_gcm.analysing import get_phase_lengths\n\n\nphase_lengths = get_phase_lengths(arabidopsis_supermodel.fba_model)\nphase_lengths\n\n[6.0, 0.5, 11.5, 6.0]\n\n\n\nfor i, phase_length in zip([1, 2, 3, 4], phase_lengths):\n    nitrate_uptake.loc[(\"NITRATE_a_tx\", i), :] = nitrate_uptake.loc[(\"NITRATE_a_tx\", i), :] * phase_length\nnitrate_uptake\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nunconstrained\nconstrained\nunconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNITRATE_a_tx\n1\n0.106810\n0.106810\n0.106810\n0.106810\n0.112106\n0.112106\n0.112106\n0.112106\n0.112101\n0.112101\n0.112101\n0.112101\n\n\n2\n0.026703\n0.026703\n0.026703\n0.026703\n0.118371\n0.118371\n0.118371\n0.118371\n0.118366\n0.118366\n0.118366\n0.118366\n\n\n3\n3.320676\n3.320676\n3.320673\n3.320670\n3.396533\n3.396533\n3.396529\n3.396526\n3.396386\n3.396386\n3.396377\n3.396376\n\n\n4\n0.072484\n0.072484\n0.072484\n0.072484\n0.074511\n0.074511\n0.074511\n0.074511\n0.074508\n0.074508\n0.074508\n0.074508\n\n\n\n\n\n\n\n\nnitrate_uptake_day = nitrate_uptake.loc[(slice(None), [2, 3]), :].sum()\nnitrate_uptake_night = nitrate_uptake.loc[(slice(None), [1, 4]), :].sum()\n\n\nnitrate_uptake_day\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          3.347379\n                      starchko    3.347379\n       constrained    wt          3.347375\n                      starchko    3.347373\nwhite  unconstrained  wt          3.514904\n                      starchko    3.514904\n       constrained    wt          3.514900\n                      starchko    3.514897\nnops   unconstrained  wt          3.514752\n                      starchko    3.514752\n       constrained    wt          3.514743\n                      starchko    3.514742\ndtype: float64\n\n\n\nnitrate_uptake_night\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.179294\n                      starchko    0.179294\n       constrained    wt          0.179294\n                      starchko    0.179294\nwhite  unconstrained  wt          0.186617\n                      starchko    0.186617\n       constrained    wt          0.186617\n                      starchko    0.186617\nnops   unconstrained  wt          0.186609\n                      starchko    0.186609\n       constrained    wt          0.186609\n                      starchko    0.186608\ndtype: float64\n\n\n\nnitrate_uptake_day / nitrate_uptake_night\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          18.669741\n                      starchko    18.669741\n       constrained    wt          18.669741\n                      starchko    18.669741\nwhite  unconstrained  wt          18.834845\n                      starchko    18.834845\n       constrained    wt          18.834845\n                      starchko    18.834845\nnops   unconstrained  wt          18.834845\n                      starchko    18.834845\n       constrained    wt          18.834845\n                      starchko    18.834845\ndtype: float64\n\n\n\nnitrate_uptake = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"NITRATE_a_Linker\", slice(None)), :]\nnitrate_uptake\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nunconstrained\nconstrained\nunconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNITRATE_a_Linker\n1\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n\n\n2\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n\n\n3\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n\n\n4\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n\n\n\n\n\n\n\n\nnitrate_uptake = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"NITRATE_ae_me\", slice(None)), :]\nnitrate_uptake\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nunconstrained\nconstrained\nunconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNITRATE_ae_me\n1\n0.017802\n0.017802\n0.017802\n0.017802\n0.018684\n0.018684\n0.018684\n0.018684\n0.018683\n0.018683\n0.018683\n0.018683\n\n\n2\n0.053405\n0.053405\n0.053405\n0.053405\n0.236743\n0.236743\n0.236743\n0.236742\n0.236733\n0.236733\n0.236732\n0.236732\n\n\n3\n0.288754\n0.288754\n0.288754\n0.288754\n0.295351\n0.295351\n0.295350\n0.295350\n0.295338\n0.295338\n0.295337\n0.295337\n\n\n4\n0.012081\n0.012081\n0.012081\n0.012081\n0.012419\n0.012419\n0.012419\n0.012419\n0.012418\n0.012418\n0.012418\n0.012418\n\n\n\n\n\n\n\n\narabidopsis_supermodel.fba_model.metabolites.NITRATE_e_gc_2\n\n\n        \n\n\n\nMetabolite identifier\nNITRATE_e_gc_2\n\n\nName\nNITRATE_gc_2\n\n\nMemory address\n0x7562383d04c0\n\n\nFormula\nN1O3\n\n\nCompartment\ne\n\n\nIn 2 reaction(s)\nNITRATE_ae_gc_2, Nitrate_ec_gc_2\n\n\n\n\n\n\nfiltered_reactions = [\n    reaction.id[:-2] for reaction in arabidopsis_supermodel.fba_model.metabolites.NADH_c_gc_2.reactions\n]\nfiltered_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(filtered_reactions, 2), :]\nfiltered_df = filtered_df.loc[~(abs(filtered_df) &lt; 0.0000000001).all(axis=1)]\nfiltered_df.mask(abs(filtered_df) &lt; 0.0000000001, 0).drop(\n    [(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1\n)\n\n/tmp/ipykernel_5280/2808846299.py:6: PerformanceWarning: indexing past lexsort depth may impact performance.\n  filtered_df.mask(abs(filtered_df) &lt; 0.0000000001, 0).drop(\n\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\nMALATE_DEH_RXN_c_gc\n2\n0.000476\n0.000784\n0.0\n0.0\n0.0\n0.0\n-0.000612\n0.0\n\n\nGAPOXNPHOSPHN_RXN_c_gc\n2\n-0.000476\n-0.000784\n0.0\n0.0\n0.0\n0.0\n0.000612\n0.0\n\n\n\n\n\n\n\n\nfiltered_reactions = [\n    reaction.id[:-2] for reaction in arabidopsis_supermodel.fba_model.metabolites.ATP_c_gc_2.reactions\n]\nfiltered_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(filtered_reactions, 2), :]\nfiltered_df = filtered_df.loc[~(abs(filtered_df) &lt; 0.0000000001).all(axis=1)]\nfiltered_df.mask(abs(filtered_df) &lt; 0.0000000001, 0).drop(\n    [(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1\n)\n\n/tmp/ipykernel_5280/3469620016.py:6: PerformanceWarning: indexing past lexsort depth may impact performance.\n  filtered_df.mask(abs(filtered_df) &lt; 0.0000000001, 0).drop(\n\n\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\n\nATPase\nunconstrained\nconstrained\nconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nReaction\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\nATPase_tx_gc\n2\n0.000444\n0.000444\n0.000444\n0.000444\n0.000534\n0.000534\n0.000444\n0.000444\n\n\nATP_ADP_mc_gc\n2\n0.013626\n0.014027\n0.009134\n0.006731\n0.006726\n0.005019\n0.010332\n0.009119\n\n\nPYRUVATEORTHOPHOSPHATE_DIKINASE_RXN_c_gc\n2\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\n6PFRUCTPHOS_RXN_c_gc\n2\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000306\n0.000000\n\n\nATP_AMP_mc_gc\n2\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\nPEPCARBOXYKIN_RXN_c_gc\n2\n0.000566\n0.000784\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\nPROTONATP_rev_vc_gc\n2\n0.004180\n0.003686\n0.004340\n0.001937\n0.005393\n0.001813\n0.005844\n0.004326\n\n\nPEPDEPHOS_RXN_c_gc\n2\n0.000090\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\nPROTON_ATPase_c_gc\n2\n0.007930\n0.008132\n0.004350\n0.004350\n0.004350\n0.004350\n0.004350\n0.004350\n\n\nUDPKIN_RXN_c_gc\n2\n0.000119\n0.000196\n0.000000\n0.000000\n-0.000905\n0.000114\n0.000000\n0.000000\n\n\nPHOSGLYPHOS_RXN_c_gc\n2\n0.000476\n0.000784\n0.000000\n0.000000\n0.000000\n0.000000\n-0.000612\n0.000000\n\n\nATP_ADP_Pi_pc_gc\n2\n0.000000\n0.000000\n0.000000\n0.000000\n0.002646\n0.001792\n0.000000\n0.000000\n\n\n\n\n\n\n\n\nfiltered_reactions = [\n    reaction.id[:-2] for reaction in arabidopsis_supermodel.fba_model.metabolites.ATP_c_gc_2.reactions\n]\nfiltered_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(filtered_reactions, 2), :]\nfiltered_df = filtered_df.loc[~(abs(filtered_df) &lt; 0.0000000001).all(axis=1)]\nfiltered_df.mask(abs(filtered_df) &lt; 0.0000000001, 0).loc[:, (\"white\", \"constrained\", \"wt\")]\n\nReaction                                  Phase\nATPase_tx_gc                              2        0.000534\nATP_ADP_mc_gc                             2        0.006726\nPYRUVATEORTHOPHOSPHATE_DIKINASE_RXN_c_gc  2        0.000000\n6PFRUCTPHOS_RXN_c_gc                      2        0.000000\nATP_AMP_mc_gc                             2        0.000000\nPEPCARBOXYKIN_RXN_c_gc                    2        0.000000\nPROTONATP_rev_vc_gc                       2        0.005393\nPEPDEPHOS_RXN_c_gc                        2        0.000000\nPROTON_ATPase_c_gc                        2        0.004350\nUDPKIN_RXN_c_gc                           2       -0.000905\nPHOSGLYPHOS_RXN_c_gc                      2        0.000000\nATP_ADP_Pi_pc_gc                          2        0.002646\nName: (white, constrained, wt), dtype: float64\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"PEPCARBOXYKIN_RXN_c_gc\", 2), :].drop(\n    [(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")]\n)\n\n/tmp/ipykernel_5280/42660494.py:1: PerformanceWarning: indexing past lexsort depth may impact performance.\n  solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"PEPCARBOXYKIN_RXN_c_gc\", 2), :].drop(\n\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.000566\n                      starchko    0.000784\n       constrained    wt          0.000000\n                      starchko    0.000000\nwhite  constrained    wt          0.000000\n                      starchko    0.000000\nnops   constrained    wt          0.000000\n                      starchko    0.000000\nName: (PEPCARBOXYKIN_RXN_c_gc, 2), dtype: float64\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"PEPCARBOXYKIN_RXN_c_gc\", 2), :].drop(\n    [(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")]\n)\n\n/tmp/ipykernel_5280/42660494.py:1: PerformanceWarning: indexing past lexsort depth may impact performance.\n  solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"PEPCARBOXYKIN_RXN_c_gc\", 2), :].drop(\n\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.000566\n                      starchko    0.000784\n       constrained    wt          0.000000\n                      starchko    0.000000\nwhite  constrained    wt          0.000000\n                      starchko    0.000000\nnops   constrained    wt          0.000000\n                      starchko    0.000000\nName: (PEPCARBOXYKIN_RXN_c_gc, 2), dtype: float64\n\n\n\nphloem_outputs = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"Phloem_tx_overall\", np.nan), :]\n\n\nphloem_outputs\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          14.258841\n                      starchko    14.258841\n       constrained    wt          14.258825\n                      starchko    14.258816\nwhite  unconstrained  wt          14.965776\n                      starchko    14.965776\n       constrained    wt          14.965758\n                      starchko    14.965748\nnops   unconstrained  wt          14.965131\n                      starchko    14.965131\n       constrained    wt          14.965090\n                      starchko    14.965084\nName: (Phloem_tx_overall, nan), dtype: float64\n\n\n\nphloem_outputs_dict = {}\nfor name, value in phloem_outputs.items():\n    phloem_outputs_dict[name] = (phloem_outputs / value * 100).round(3)\n\n\nphloem_outputs_comparison_table = pd.DataFrame.from_dict(phloem_outputs_dict)\nphloem_outputs_comparison_table.to_csv(\"../outputs/efficiency_comparisons/phloem_outputs_compare.csv\")\nphloem_outputs_comparison_table\n\n\n\n\n\n\n\n\n\n\nblue\nwhite\nnops\n\n\n\n\n\nunconstrained\nconstrained\nunconstrained\nconstrained\nunconstrained\nconstrained\n\n\n\n\n\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nLight\nATPase\nStarch\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nblue\nunconstrained\nwt\n100.000\n100.000\n100.000\n100.000\n95.276\n95.276\n95.276\n95.277\n95.280\n95.280\n95.281\n95.281\n\n\nstarchko\n100.000\n100.000\n100.000\n100.000\n95.276\n95.276\n95.276\n95.276\n95.280\n95.280\n95.281\n95.281\n\n\nconstrained\nwt\n100.000\n100.000\n100.000\n100.000\n95.276\n95.276\n95.276\n95.276\n95.280\n95.280\n95.281\n95.281\n\n\nstarchko\n100.000\n100.000\n100.000\n100.000\n95.276\n95.276\n95.276\n95.276\n95.280\n95.280\n95.281\n95.281\n\n\nwhite\nunconstrained\nwt\n104.958\n104.958\n104.958\n104.958\n100.000\n100.000\n100.000\n100.000\n100.004\n100.004\n100.005\n100.005\n\n\nstarchko\n104.958\n104.958\n104.958\n104.958\n100.000\n100.000\n100.000\n100.000\n100.004\n100.004\n100.005\n100.005\n\n\nconstrained\nwt\n104.958\n104.958\n104.958\n104.958\n100.000\n100.000\n100.000\n100.000\n100.004\n100.004\n100.004\n100.005\n\n\nstarchko\n104.958\n104.958\n104.958\n104.958\n100.000\n100.000\n100.000\n100.000\n100.004\n100.004\n100.004\n100.004\n\n\nnops\nunconstrained\nwt\n104.953\n104.953\n104.953\n104.954\n99.996\n99.996\n99.996\n99.996\n100.000\n100.000\n100.000\n100.000\n\n\nstarchko\n104.953\n104.953\n104.953\n104.954\n99.996\n99.996\n99.996\n99.996\n100.000\n100.000\n100.000\n100.000\n\n\nconstrained\nwt\n104.953\n104.953\n104.953\n104.953\n99.995\n99.995\n99.996\n99.996\n100.000\n100.000\n100.000\n100.000\n\n\nstarchko\n104.953\n104.953\n104.953\n104.953\n99.995\n99.995\n99.995\n99.996\n100.000\n100.000\n100.000\n100.000\n\n\n\n\n\n\n\n\n100 - 99.980\n\n0.01999999999999602\n\n\n\nphloem_outputs_blue = phloem_outputs.loc[\"blue\"]\nphloem_outputs_blue / phloem_outputs_blue.iloc[0] * 100\n\nATPase         Starch  \nunconstrained  wt          100.000000\n               starchko     99.999999\nconstrained    wt           99.999888\n               starchko     99.999825\nName: (Phloem_tx_overall, nan), dtype: float64\n\n\n\nphloem_outputs_white = phloem_outputs.drop(\"blue\")\nphloem_outputs_white = phloem_outputs_white / phloem_outputs_white.iloc[0] * 100\nphloem_outputs_white\n\n/tmp/ipykernel_5280/3118140255.py:1: PerformanceWarning: dropping on a non-lexsorted multi-index without a level parameter may impact performance.\n  phloem_outputs_white = phloem_outputs.drop(\"blue\")\n\n\nLight  ATPase         Starch  \nwhite  unconstrained  wt          100.000000\n                      starchko    100.000000\n       constrained    wt           99.999883\n                      starchko     99.999814\nnops   unconstrained  wt           99.995690\n                      starchko     99.995690\n       constrained    wt           99.995422\n                      starchko     99.995379\nName: (Phloem_tx_overall, nan), dtype: float64\n\n\n\nphloem_outputs.drop(\"blue\")\n\n/tmp/ipykernel_5280/4124221444.py:1: PerformanceWarning: dropping on a non-lexsorted multi-index without a level parameter may impact performance.\n  phloem_outputs.drop(\"blue\")\n\n\nLight  ATPase         Starch  \nwhite  unconstrained  wt          14.965776\n                      starchko    14.965776\n       constrained    wt          14.965758\n                      starchko    14.965748\nnops   unconstrained  wt          14.965131\n                      starchko    14.965131\n       constrained    wt          14.965090\n                      starchko    14.965084\nName: (Phloem_tx_overall, nan), dtype: float64\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"Phloem_tx_overall\", np.nan), :].plot.bar()\n\n\n\n\n\n\n\n\n\narabidopsis_supermodel.get_prop_gc()\n\n0.0030263085626407423\n\n\n\n5.17 * arabidopsis_supermodel.get_prop_gc() * 0.3\n\n0.004693804580655791\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"Cl_cv_gc\", 2), :]\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.023144\n                      starchko    0.026064\n       constrained    wt          0.014849\n                      starchko    0.008494\nwhite  unconstrained  wt          0.025841\n                      starchko    0.025940\n       constrained    wt          0.010786\n                      starchko    0.004882\nnops   unconstrained  wt          0.016494\n                      starchko    0.016494\n       constrained    wt          0.008700\n                      starchko    0.008700\nName: (Cl_cv_gc, 2), dtype: float64\n\n\n\n0.004882/0.010786\n\n0.45262377155572037\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"K_PROTON_cv_gc\", 2), :]\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.008718\n                      starchko    0.007961\n       constrained    wt          0.008681\n                      starchko    0.003874\nwhite  unconstrained  wt          0.008018\n                      starchko    0.007993\n       constrained    wt          0.010786\n                      starchko    0.004882\nnops   unconstrained  wt          0.010442\n                      starchko    0.010442\n       constrained    wt          0.008700\n                      starchko    0.002542\nName: (K_PROTON_cv_gc, 2), dtype: float64\n\n\n\n0.004882/0.010786\n\n0.45262377155572037\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"RXN_1461_v_gc\", 2), :]\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.000000\n                      starchko    0.000000\n       constrained    wt          0.003474\n                      starchko    0.013726\nwhite  unconstrained  wt          0.000000\n                      starchko    0.000000\n       constrained    wt          0.001805\n                      starchko    0.013612\nnops   unconstrained  wt          0.000000\n                      starchko    0.000000\n       constrained    wt          0.002988\n                      starchko    0.009647\nName: (RXN_1461_v_gc, 2), dtype: float64\n\n\n\n0.013612/0.001805\n\n7.541274238227148\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"K_ec_gc\", 2), :]\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.015860\n                      starchko    0.016264\n       constrained    wt          0.008700\n                      starchko    0.008700\nwhite  unconstrained  wt          0.016135\n                      starchko    0.016140\n       constrained    wt          0.008700\n                      starchko    0.008700\nnops   unconstrained  wt          0.015185\n                      starchko    0.015185\n       constrained    wt          0.008700\n                      starchko    0.008700\nName: (K_ec_gc, 2), dtype: float64\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"ISOCITDEH_RXN_c_gc\", 3), :]\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.000000\n                      starchko    0.000000\n       constrained    wt          0.000000\n                      starchko    0.000000\nwhite  unconstrained  wt          0.000000\n                      starchko    0.000000\n       constrained    wt          0.000000\n                      starchko    0.000000\nnops   unconstrained  wt          0.000000\n                      starchko    0.000000\n       constrained    wt          0.000051\n                      starchko    0.000062\nName: (ISOCITDEH_RXN_c_gc, 3), dtype: float64\n\n\n\nmet_df_mm\n\n\n\n\n\n\n\n\nLight\nblue\n...\nnops\n\n\n\nATPase\nunconstrained\nconstrained\n...\nunconstrained\nconstrained\n\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\n...\nwt\nstarchko\nwt\nstarchko\n\n\n\nSolution\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\n...\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\nfluxes\nminimum\nmaximum\n\n\nPhase\nReaction\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\nK\n24.135299\nNaN\nNaN\n21.955092\nNaN\nNaN\n20.798763\nNaN\nNaN\n6.267413\n...\nNaN\n10.238928\nNaN\nNaN\n8.333669\nNaN\nNaN\n7.396173\nNaN\nNaN\n\n\nCl\n16.524279\nNaN\nNaN\n21.954453\nNaN\nNaN\n13.391074\nNaN\nNaN\n0.718695\n...\nNaN\n2.969559\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nSUCROSE\n0.000000\nNaN\nNaN\n0.098507\nNaN\nNaN\n7.881207\nNaN\nNaN\n31.139004\n...\nNaN\n0.637511\nNaN\nNaN\n18.115847\nNaN\nNaN\n30.149261\nNaN\nNaN\n\n\nGLC\n0.633834\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nFRU\n0.000000\nNaN\nNaN\n0.458382\nNaN\nNaN\n0.659272\nNaN\nNaN\n0.658861\n...\nNaN\n0.637511\nNaN\nNaN\n0.672046\nNaN\nNaN\n0.989743\nNaN\nNaN\n\n\nMAL\n20.910624\nNaN\nNaN\n24.158592\nNaN\nNaN\n9.601548\nNaN\nNaN\n6.606525\n...\nNaN\n8.077077\nNaN\nNaN\n0.000000\nNaN\nNaN\n8.217966\nNaN\nNaN\n\n\nCIT\n1.431237\nNaN\nNaN\n0.000000\nNaN\nNaN\n1.555385\nNaN\nNaN\n1.555385\n...\nNaN\n2.423123\nNaN\nNaN\n2.777890\nNaN\nNaN\n2.465388\nNaN\nNaN\n\n\nSTARCH\n0.000244\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.005126\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.002569\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\n6.0\nK\n24.135299\n0.0\n140.262888\n22.233537\n0.0\n140.262888\n21.356860\n0.0\n140.262888\n6.670390\n...\n140.262888\n10.238928\n0.0\n140.262888\n8.333669\n0.0\n140.262888\n7.396173\n0.0\n133.708937\n\n\nCl\n16.524279\n0.0\n89.290671\n22.232898\n0.0\n89.290671\n13.949171\n0.0\n89.290671\n1.121672\n...\n89.290671\n2.969559\n0.0\n89.290671\n0.000000\n0.0\n89.290671\n0.000000\n0.0\n80.403347\n\n\nSUCROSE\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n7.881207\n0.0\n178.581341\n31.139004\n...\n178.581341\n0.000000\n0.0\n178.581341\n18.787893\n0.0\n178.581341\n31.139004\n0.0\n178.581341\n\n\nGLC\n1.268503\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n...\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n160.500964\n\n\nFRU\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n...\n178.581341\n1.275022\n0.0\n178.581341\n0.000000\n0.0\n178.581341\n0.000000\n0.0\n160.500964\n\n\nMAL\n19.251970\n0.0\n64.494321\n24.158592\n0.0\n64.494321\n8.230780\n0.0\n64.494321\n6.165242\n...\n64.494321\n8.077077\n0.0\n64.494321\n0.000000\n0.0\n64.494321\n8.217966\n0.0\n64.494321\n\n\nCIT\n2.537007\n0.0\n49.435142\n0.000000\n0.0\n49.435142\n2.469230\n0.0\n49.435142\n1.849573\n...\n49.435142\n2.423123\n0.0\n49.435142\n2.777890\n0.0\n49.435142\n2.465388\n0.0\n49.435142\n\n\nSTARCH\n0.000000\n0.0\n1000.000000\n0.000000\n0.0\n0.000000\n0.005126\n0.0\n0.285304\n0.000000\n...\n1000.000000\n0.000000\n0.0\n0.000000\n0.002569\n0.0\n0.232884\n0.000000\n0.0\n0.000000\n\n\n6.5\nK\n52.215252\n0.0\n152.876211\n51.358083\n0.0\n152.876211\n35.692816\n0.0\n138.971194\n22.936568\n...\n152.876211\n38.815143\n0.0\n152.876211\n24.381244\n0.0\n138.971194\n23.566961\n0.0\n133.278620\n\n\nCl\n45.604537\n0.0\n108.221407\n51.357528\n0.0\n108.221407\n29.258708\n0.0\n94.698182\n18.117110\n...\n108.221407\n32.501177\n0.0\n108.221407\n17.142857\n0.0\n94.698182\n17.142857\n0.0\n86.978907\n\n\nSUCROSE\n0.234594\n0.0\n216.442814\n0.386397\n0.0\n216.442814\n0.000000\n0.0\n216.442814\n0.000000\n...\n216.442814\n1.230198\n0.0\n216.442814\n0.000000\n0.0\n216.442814\n0.000000\n0.0\n138.990025\n\n\nGLC\n1.101786\n0.0\n216.442814\n0.000000\n0.0\n216.442814\n27.046452\n0.0\n216.442814\n27.046449\n...\n216.442814\n0.000000\n0.0\n216.442814\n25.840051\n0.0\n216.442814\n27.046449\n0.0\n216.442814\n\n\nFRU\n0.000000\n0.0\n216.442814\n0.000000\n0.0\n216.442814\n6.845391\n0.0\n216.442814\n27.046449\n...\n216.442814\n1.365608\n0.0\n216.442814\n16.318627\n0.0\n216.442814\n27.046449\n0.0\n216.442814\n\n\nMAL\n17.518812\n0.0\n65.116825\n17.835708\n0.0\n65.116825\n9.293723\n0.0\n65.116825\n6.961439\n...\n65.116825\n9.120173\n0.0\n65.116825\n3.619193\n0.0\n65.116825\n9.279256\n0.0\n62.386555\n\n\nCIT\n0.000000\n0.0\n44.869080\n0.000000\n0.0\n44.869080\n0.000000\n0.0\n44.869080\n0.000000\n...\n44.869080\n0.000000\n0.0\n44.869080\n0.000000\n0.0\n44.869080\n0.000000\n0.0\n39.265593\n\n\nSTARCH\n0.000000\n0.0\n0.000000\n0.000000\n0.0\n0.000000\n0.000000\n0.0\n0.000000\n0.000000\n...\n0.000000\n0.000000\n0.0\n0.000000\n0.000000\n0.0\n0.099952\n0.000000\n0.0\n0.000000\n\n\n18.0\nK\n24.135299\nNaN\nNaN\n21.909632\nNaN\nNaN\n20.080068\nNaN\nNaN\n5.548718\n...\nNaN\n10.238928\nNaN\nNaN\n8.333669\nNaN\nNaN\n7.396173\nNaN\nNaN\n\n\nCl\n16.524279\nNaN\nNaN\n21.908994\nNaN\nNaN\n12.672379\nNaN\nNaN\n0.000000\n...\nNaN\n2.969559\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nSUCROSE\n0.000000\nNaN\nNaN\n0.647915\nNaN\nNaN\n7.881207\nNaN\nNaN\n31.139004\n...\nNaN\n1.275022\nNaN\nNaN\n16.881692\nNaN\nNaN\n29.159518\nNaN\nNaN\n\n\nGLC\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nFRU\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n1.318969\nNaN\nNaN\n1.318558\n...\nNaN\n0.000000\nNaN\nNaN\n1.906201\nNaN\nNaN\n1.979486\nNaN\nNaN\n\n\nMAL\n23.057480\nNaN\nNaN\n24.158273\nNaN\nNaN\n11.934624\nNaN\nNaN\n8.939601\n...\nNaN\n8.077077\nNaN\nNaN\n0.000000\nNaN\nNaN\n8.217966\nNaN\nNaN\n\n\nCIT\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n2.423123\nNaN\nNaN\n2.777890\nNaN\nNaN\n2.465388\nNaN\nNaN\n\n\nSTARCH\n0.000559\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.005126\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.002455\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\n24.0\nK\n24.135299\nNaN\nNaN\n21.955092\nNaN\nNaN\n20.798763\nNaN\nNaN\n6.267413\n...\nNaN\n10.238928\nNaN\nNaN\n8.333669\nNaN\nNaN\n7.396173\nNaN\nNaN\n\n\nCl\n16.524279\nNaN\nNaN\n21.954453\nNaN\nNaN\n13.391074\nNaN\nNaN\n0.718695\n...\nNaN\n2.969559\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nSUCROSE\n0.000000\nNaN\nNaN\n0.098507\nNaN\nNaN\n7.881207\nNaN\nNaN\n31.139004\n...\nNaN\n0.637511\nNaN\nNaN\n18.115847\nNaN\nNaN\n30.149261\nNaN\nNaN\n\n\nGLC\n0.633834\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\nFRU\n0.000000\nNaN\nNaN\n0.458382\nNaN\nNaN\n0.659272\nNaN\nNaN\n0.658861\n...\nNaN\n0.637511\nNaN\nNaN\n0.672046\nNaN\nNaN\n0.989743\nNaN\nNaN\n\n\nMAL\n20.910624\nNaN\nNaN\n24.158592\nNaN\nNaN\n9.601548\nNaN\nNaN\n6.606525\n...\nNaN\n8.077077\nNaN\nNaN\n0.000000\nNaN\nNaN\n8.217966\nNaN\nNaN\n\n\nCIT\n1.431237\nNaN\nNaN\n0.000000\nNaN\nNaN\n1.555385\nNaN\nNaN\n1.555385\n...\nNaN\n2.423123\nNaN\nNaN\n2.777890\nNaN\nNaN\n2.465388\nNaN\nNaN\n\n\nSTARCH\n0.000244\nNaN\nNaN\n0.000000\nNaN\nNaN\n0.005126\nNaN\nNaN\n0.000000\n...\nNaN\n0.000000\nNaN\nNaN\n0.002569\nNaN\nNaN\n0.000000\nNaN\nNaN\n\n\n\n\n40 rows × 36 columns\n\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[\"Phloem_tx_overall\"]\n\n\n\n\n\n\n\nLight\nblue\nwhite\nnops\n\n\nATPase\nunconstrained\nconstrained\nunconstrained\nconstrained\nunconstrained\nconstrained\n\n\nStarch\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\nwt\nstarchko\n\n\nPhase\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNaN\n14.258841\n14.258841\n14.258825\n14.258816\n14.965776\n14.965776\n14.965758\n14.965748\n14.965131\n14.965131\n14.96509\n14.965084\n\n\n\n\n\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"RXN_2141_p_gc\", 2), :]\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.000000\n                      starchko    0.000000\n       constrained    wt          0.005126\n                      starchko    0.000000\nwhite  unconstrained  wt          0.000000\n                      starchko    0.000000\n       constrained    wt          0.005417\n                      starchko    0.000000\nnops   unconstrained  wt          0.000000\n                      starchko    0.000000\n       constrained    wt          0.002263\n                      starchko    0.000000\nName: (RXN_2141_p_gc, 2), dtype: float64\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"SUCROSE_SYNTHASE_RXN_c_gc\", 2), :]\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.000000\n                      starchko    0.000000\n       constrained    wt          0.000000\n                      starchko    0.000000\nwhite  unconstrained  wt          0.000000\n                      starchko    0.000000\n       constrained    wt          0.001992\n                      starchko    0.000000\nnops   unconstrained  wt          0.000131\n                      starchko    0.000131\n       constrained    wt          0.000000\n                      starchko    0.000000\nName: (SUCROSE_SYNTHASE_RXN_c_gc, 2), dtype: float64\n\n\n\n0.001992/0.005417\n\n0.36773121654052054\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"PEPCARBOX_RXN_c_gc\", 2), :]\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.000000\n                      starchko    0.000000\n       constrained    wt          0.000000\n                      starchko    0.000000\nwhite  unconstrained  wt          0.000000\n                      starchko    0.000000\n       constrained    wt          0.000000\n                      starchko    0.000000\nnops   unconstrained  wt          0.000000\n                      starchko    0.000000\n       constrained    wt          0.000612\n                      starchko    0.000000\nName: (PEPCARBOX_RXN_c_gc, 2), dtype: float64\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"PROTONATP_rev_vc_gc\", 2), :]\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.004180\n                      starchko    0.003686\n       constrained    wt          0.004340\n                      starchko    0.001937\nwhite  unconstrained  wt          0.003229\n                      starchko    0.003212\n       constrained    wt          0.005393\n                      starchko    0.001813\nnops   unconstrained  wt          0.005221\n                      starchko    0.005221\n       constrained    wt          0.005844\n                      starchko    0.004326\nName: (PROTONATP_rev_vc_gc, 2), dtype: float64",
    "crumbs": [
      "Solving and analysing specific scenarios for paper",
      "Analysing solutions"
    ]
  },
  {
    "objectID": "2.2_analysingsolutions.html#analysis-on-guard-cell-photon-scan",
    "href": "2.2_analysingsolutions.html#analysis-on-guard-cell-photon-scan",
    "title": "Analysing solutions",
    "section": "Analysis on Guard Cell Photon Scan",
    "text": "Analysis on Guard Cell Photon Scan\n\ngc_photon_scan = pd.read_csv(\"../outputs/scans/gc_photon_scan.csv\")\n\n\ngc_photon_scan.set_index(\"Unnamed: 0\", inplace=True)\n\n\nglycolysis_c = gc_photon_scan.loc['3PGAREARR_RXN_c_gc_2']\nglycolysis_p = gc_photon_scan.loc['3PGAREARR_RXN_p_gc_2']\nglycolysis = glycolysis_c + glycolysis_p\n\n\nsum(abs(gc_photon_scan.loc['3PGAREARR_RXN_p_gc_2'])&gt;1e-7)\n\n0\n\n\n\nsum(abs(gc_photon_scan.loc['3PGAREARR_RXN_p_me_2'])&gt;1e-7)\n\n151\n\n\n\nsum(abs(gc_photon_scan.loc['3PGAREARR_RXN_c_me_2'])&gt;1e-7)\n\n0\n\n\n\nglycolysis_nmoles_gc = glycolysis.apply(\n    convert_fluxes_to_per_guard_cell, args=[arabidopsis_supermodel, units]\n)\n\n\nglycolysis_nmoles_gc\n\n0      1.055598e+00\n1      1.043212e+00\n2      1.030826e+00\n3      1.018441e+00\n4      1.006055e+00\n           ...     \n146    0.000000e+00\n147    2.046696e-14\n148    9.912093e-15\n149   -1.465877e-13\n150    0.000000e+00\nLength: 151, dtype: float64\n\n\n\n(abs(glycolysis) &lt; 1e-7).idxmax() # First PPFD with 0 glycolytic flux\n\n'39'\n\n\n\nparameters_df = pd.read_csv(\"../inputs/arabidopsis_parameters.csv\", index_col=0)\npm = parameters_df.loc[:, \"Value\"]\n\n\nV_l = pm.T_l * pm.A_l  # volume of leaf is area x thickness\nV_l = V_l * 10**3  # (Total leaf volume) m3 -&gt; dm3 = 10**3\n\nV_gc = pm.V_gc_ind * pm.N_gcs  # total volume of gc in leaf\n\n# volume of meosphyll is leaf that isn't epidermis or air\nV_me = V_l * (1 - pm.L_epidermis) * (1 - pm.L_air)\n\nv_prop_gc = V_gc / V_me  # volume of gc is negligable\n\n\nme_photon = gc_photon_scan.loc['Photon_tx_me_2']\nme_photon_per_vol = me_photon / V_me\ngc_photon = gc_photon_scan.loc['Photon_tx_gc_2']\ngc_photon_per_vol = gc_photon / V_gc\ngc_me_photon_percent_per_vol = gc_photon_per_vol / me_photon_per_vol * 100\n\n\n# GC photosynthesis as a % of MC photosynthesis per cell volume\ngc_me_photon_percent_per_vol.iloc[int((abs(glycolysis) &lt; 1e-7).idxmax())]\n\n0.3247833564048949\n\n\n\nplt.plot(gc_me_photon_percent_per_vol, glycolysis_nmoles_gc, color='b', linestyle='-')\n\n# Add axis labels\nplt.xlabel('Guard cell photosynthesis as a percentage of\\nmesophyll photosynthesis per cell volume (%)')\nplt.ylabel('Guard cell glycolytic flux\\nduring opening (fmol$\\cdot$GC$^{-1}\\cdot$h$^{-1}$)')\n\n# Set x and y axis limits to start from 0\nplt.xlim(left=0)\nplt.ylim(bottom=0)\n\nplt.savefig(f\"../plant_cell_paper/supplemental_figure_4.svg\", bbox_inches=\"tight\")\nplt.savefig(f\"../plant_cell_paper/supplemental_figure_4.png\", dpi=300, bbox_inches=\"tight\")\n\n# Show the plot\nplt.show()",
    "crumbs": [
      "Solving and analysing specific scenarios for paper",
      "Analysing solutions"
    ]
  },
  {
    "objectID": "1.3_atpase_constraint.html",
    "href": "1.3_atpase_constraint.html",
    "title": "Is H+ATPase limiting?",
    "section": "",
    "text": "Jezek et al. (2019) wrote a follow-up OnGuard paper, where they added a constraint-relaxation-recovery mechanism into the model. The justification for this was:\nThey therefore added a the CRR mechanism into the model which was able to reconcile the kinetics of stomatal conductance experimentally and in the model.\nDespite this, they also say in the discussion:\nFlutsch et al (2020) investigated the kinetics of stomatal opening in amy3bam1 and aha1 knockouts. The amy3bam1 mutant cannot degrade starch and the aha1 mutant can’t pump protons out of the guard cell, which drives K+/Mal/Cl uptake into the guard cell. It also is part of the starch signaling pathway. They found that there was no impact on the H+-ATPase or kinetics of K+/Cl- uptake in the amy3bam1 knockout, suggesting that starch is not degraded to power the H+-ATPase pump, but rather it is a source of osmoticum in the form of glucose. However, the amy3bam1 mutants had slower opening kinetics.\nThis would be consistent with a H+-ATPase that is not able to provide osmoticum at a sufficient rate for opening. It is saturated regardless of whether or not starch is available. As our model does not degrade starch, instead meeting all the osmotic requirements of opening using K+/Cl- uptake, we wanted to see what would happen if we added a constraint on the rate of the H+-ATPase. This notebook explores the experimental rate of the H+-ATPase that Flutsch et al (2020) estimated and compares it to the rate in the model that is required for the Guard Cell to open, in order to see whether adding a constraint would affect the model.",
    "crumbs": [
      "Building model and defining parameters",
      "Is H+ATPase limiting?"
    ]
  },
  {
    "objectID": "1.3_atpase_constraint.html#setup",
    "href": "1.3_atpase_constraint.html#setup",
    "title": "Is H+ATPase limiting?",
    "section": "Setup",
    "text": "Setup\n\nimport cobra\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nfrom mmon_gcm.supermodel import SuperModel\n\n\nfour_stage_GC_model = cobra.io.sbml.read_sbml_model(\"../models/4_stage_GC.xml\")  # read model\n\nNo objective coefficients in model. Unclear what should be optimized\n\n\n\nsolution = pd.read_csv(\"../outputs/model_solutions/blue_unconstrained_starchko.csv\", index_col=0)\n\n\nparameters_df = pd.read_csv(\"../inputs/arabidopsis_parameters.csv\", index_col=0)",
    "crumbs": [
      "Building model and defining parameters",
      "Is H+ATPase limiting?"
    ]
  },
  {
    "objectID": "1.3_atpase_constraint.html#calculating-h-atpase-flux-in-the-model-in-fmolesgch-1",
    "href": "1.3_atpase_constraint.html#calculating-h-atpase-flux-in-the-model-in-fmolesgch-1",
    "title": "Is H+ATPase limiting?",
    "section": "Calculating H+-ATPase flux in the model in fmoles/gc/h-1",
    "text": "Calculating H+-ATPase flux in the model in fmoles/gc/h-1\n\natpase_flux = solution.loc[\"PROTON_ATPase_c_gc_2\", \"fluxes\"]\nprint(f\"ATPase flux is {atpase_flux} mmoles m-2 leaf h-1\")\n\nATPase flux is 0.0069318825380567 mmoles m-2 leaf h-1\n\n\n\nn_gcs = parameters_df.loc[\"N_gcs\", \"Value\"]\n\n\nflux_per_gc_moles = atpase_flux / n_gcs * 10**-3\n\n\nflux_per_gc_fmoles = flux_per_gc_moles * 10**15\nflux_per_gc_fmoles_rounded = flux_per_gc_fmoles.round(1)\nprint(f\"Rate of H+-ATPase is {flux_per_gc_fmoles_rounded} fmoles gc-1 h-1\")\n\nRate of H+-ATPase is 12.0 fmoles gc-1 h-1",
    "crumbs": [
      "Building model and defining parameters",
      "Is H+ATPase limiting?"
    ]
  },
  {
    "objectID": "1.3_atpase_constraint.html#comparing-with-flutsch",
    "href": "1.3_atpase_constraint.html#comparing-with-flutsch",
    "title": "Is H+ATPase limiting?",
    "section": "Comparing with Flutsch",
    "text": "Comparing with Flutsch\nAccording to their Supplemental file 1, Flutsch et al say that guard cells can provide 17 fmoles H+ h-1 (0.017 pmoles).",
    "crumbs": [
      "Building model and defining parameters",
      "Is H+ATPase limiting?"
    ]
  },
  {
    "objectID": "1.3_atpase_constraint.html#comparing-with-papanatsiou-et-al-2019",
    "href": "1.3_atpase_constraint.html#comparing-with-papanatsiou-et-al-2019",
    "title": "Is H+ATPase limiting?",
    "section": "Comparing with Papanatsiou et al 2019",
    "text": "Comparing with Papanatsiou et al 2019\n(From supplementary methods of Papanatsiou et al., 2019:) &gt;“Between the fully closed and fully open state of the stoma, the osmotic content of an Arabidopsis guard cell rises by approximately 200 to 300 mM on a cell volume basis (5). Roughly half of this osmotic content is made up of K+ transported across the plasma membrane and translates to approximately 70 fmol of K+ per guard cell.”\n5 - Engineer, C. B. et al. (2016) ‘CO2 Sensing and CO2 Regulation of Stomatal Conductance: Advances and Open Questions’, Trends in Plant Science. Elsevier Ltd, 21(1), pp. 16–30. doi: 10.1016/j.tplants.2015.08.014.\nBut there is nothing in the Engineer paper that references this…",
    "crumbs": [
      "Building model and defining parameters",
      "Is H+ATPase limiting?"
    ]
  },
  {
    "objectID": "1.3_atpase_constraint.html#comparing-with-onguard",
    "href": "1.3_atpase_constraint.html#comparing-with-onguard",
    "title": "Is H+ATPase limiting?",
    "section": "Comparing with OnGuard",
    "text": "Comparing with OnGuard\nI ran the default model that comes with OnGuard version 3 ‘RCA5-wt-191120-wt’ using the Summer 2022 release of OnGuard. Modifying it by unticking the ‘CRR’ box. I ran it for 24 hours and exported the results as a csv:\n\n# import csv and tidy up\nonguard_df = pd.read_csv(\"../inputs/RCA5-wt-191120-wt-001.csv\")\nonguard_df = onguard_df.set_index(\"Time /hr\")\nonguard_df\n\n\n\n\n\n\n\n\nTime /s\nTime /min\nTime /d\nVpm /mV\nVtp /mV\nVT /pL\nVac %-age\nSA /um\nTP /atm\nUnnamed: 10\n...\nVPD/KPa\nUnnamed: 140\nCRR Value\nCRR Recovery\nUnnamed: 143\nCiso(0) /mM\n'Mott' (*1000)\nCiso' /mM\nOsm[Cyt] /mM\nUnnamed: 148\n\n\nTime /hr\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.00000\n0.0\n0.00000\n0.00000\n-62.1\n-35.5\n0.381\n79.172\n1.629\n4.303\nNaN\n...\n-0.943\nNaN\n1\n2.630280e-25\nNaN\n23.1003\n5.73262\n28.8329\n204.713\nNaN\n\n\n0.00639\n23.0\n0.38342\n0.00027\n-62.9\n-35.5\n0.381\n79.162\n1.629\n4.303\nNaN\n...\n-0.943\nNaN\n1\n2.630280e-25\nNaN\n23.0992\n5.73783\n28.8370\n204.752\nNaN\n\n\n0.01306\n47.0\n0.78353\n0.00054\n-63.7\n-35.4\n0.381\n79.161\n1.629\n4.303\nNaN\n...\n-0.943\nNaN\n1\n2.630280e-25\nNaN\n23.0991\n5.73811\n28.8372\n204.793\nNaN\n\n\n0.01881\n67.7\n1.12838\n0.00078\n-64.3\n-35.4\n0.381\n79.164\n1.629\n4.303\nNaN\n...\n-0.943\nNaN\n1\n2.630280e-25\nNaN\n23.0990\n5.73851\n28.8375\n204.829\nNaN\n\n\n0.02486\n89.5\n1.49185\n0.00104\n-64.9\n-35.4\n0.381\n79.168\n1.629\n4.303\nNaN\n...\n-0.943\nNaN\n1\n2.630280e-25\nNaN\n23.0990\n5.73911\n28.8381\n204.867\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n23.97191\n86298.9\n1438.31476\n0.99883\n-59.9\n-36.4\n0.380\n79.641\n1.609\n4.287\nNaN\n...\n-0.943\nNaN\n1\n2.630280e-25\nNaN\n23.1004\n5.66717\n28.7675\n204.079\nNaN\n\n\n23.97842\n86322.3\n1438.70519\n0.99910\n-59.9\n-36.4\n0.380\n79.642\n1.609\n4.287\nNaN\n...\n-0.943\nNaN\n1\n2.630280e-25\nNaN\n23.1004\n5.66763\n28.7680\n204.084\nNaN\n\n\n23.98431\n86343.5\n1439.05839\n0.99935\n-60.0\n-36.4\n0.380\n79.642\n1.609\n4.287\nNaN\n...\n-0.943\nNaN\n1\n2.630280e-25\nNaN\n23.1004\n5.66814\n28.7685\n204.089\nNaN\n\n\n23.99081\n86366.9\n1439.44890\n0.99962\n-59.9\n-36.4\n0.380\n79.643\n1.609\n4.287\nNaN\n...\n-0.943\nNaN\n1\n2.630280e-25\nNaN\n23.1004\n5.66859\n28.7690\n204.094\nNaN\n\n\n23.99670\n86388.1\n1439.80211\n0.99986\n-60.0\n-36.4\n0.380\n79.643\n1.609\n4.287\nNaN\n...\n-0.943\nNaN\n1\n2.630280e-25\nNaN\n23.1004\n5.66910\n28.7695\n204.099\nNaN\n\n\n\n\n3905 rows × 148 columns\n\n\n\nWhere did their original kinetics for the H+-ATPase come from?\nFrom Hills et al (2012):\n\nH+-ATPase: The parameters are fully constrained by experimental analysis of the Vicia guard cell H+-ATPase (Blatt 1987a; Blatt 1988a; Blatt and Clint 1989; Clint and Blatt 1989) and equivalent analysis of the Chara H+-ATPase (Blatt et al. 1990a), the latter providing expansion to a 4-state carrier cycle to describe its pH dependence explicitly. The model incorporates [Ca2+]i sensitivity as an inhibitory ligand (Ki, 400 nM and nh, 3 to give &gt;90% inhibition at 1 μM [Ca2+]i; see Kinoshita, et al. (1995) and light as a stimulatory ligand [K1/2, 50 μmol m-2 s-1 and nh, 1, 20-fold enhancement over dark activity; see Goh, et al. (1995) and Kinoshita and Shimazaki (Kinoshita and Shimazaki 1999)].\n\n\n4-State H+-ATPase [3000000 units] (4-State ‘Slayman’ Pump) #‘H’ Stoichiometry = +1; binds at 4-&gt;1 (in) and 3-&gt;2 (ex); K12 = 2000, K23 = 50000, K34 = 500, K41 = 2e+09, K21 = 100, K32 = 1e+08, K43 = 10, K14 = 200; Light-Sensitive: Yes: L1⁄2 = 50 μEinsteins, Fmin = 5% Ligand-Gates: Ca-inhibited (cytosol): Kd= 2.5e-07, Hill= 3;",
    "crumbs": [
      "Building model and defining parameters",
      "Is H+ATPase limiting?"
    ]
  },
  {
    "objectID": "1.3_atpase_constraint.html#stomatal-aperture-sanity-check",
    "href": "1.3_atpase_constraint.html#stomatal-aperture-sanity-check",
    "title": "Is H+ATPase limiting?",
    "section": "Stomatal aperture sanity check",
    "text": "Stomatal aperture sanity check\nFirst, a sanity check on the stomatal aperture:\n\nonguard_df[\"SA /um\"].plot(ylabel=\"Aperture (µm)\")\n\n\n\n\n\n\n\n\n\nonguard_df[onguard_df.index &lt; 1][\"SA /um\"].plot(ylabel=\"Aperture (µm)\")\n\n\n\n\n\n\n\n\nOur aperture is 1.6-2.75, so pretty similar over half an hour to what they are seeing over one hour\n\nOsmolarity sanity check\n\ncyt_df = onguard_df.filter(regex=\"mM\").filter(regex=\"Cyt\")\nvac_df = onguard_df.filter(regex=\"mM\").filter(regex=\"Vac\")\n\n\ndef just_inside_brackets(string_to_be_pruned):\n    return string_to_be_pruned.split(\"]\")[0][1:]\n\n\nvac_df.columns = [just_inside_brackets(col) + \" mM\" for col in vac_df.columns]\ncyt_df.columns = [just_inside_brackets(col) + \" mM\" for col in cyt_df.columns]\n\n\nvac_frac = 79.2589 / 100\n\n\ntotal_df = vac_df * vac_frac + cyt_df * (1 - vac_frac)\n\n\ntotal_df[onguard_df.index &lt; 1].sum(axis=1).plot(ylabel=\"Total osmolytes\")\n\n\n\n\n\n\n\n\nOur osmolarities go from 178mM to 215mM for the same aperture range, so there’s something not quite right somewhere maybe…\n\n\nH\\(^+\\)-ATPase flux\nNow, let’s see what the H+-ATPase flux is doing:\n\n# get the flux of the H+-ATPase in units of fmoles/h\natpase_h = onguard_df[\"HATP[H]\"] * 3600\natpase_h.plot()\n\n\n\n\n\n\n\n\nThe flux through the H+-ATPASe increases over the first hour or so, but we are only interested in the first half an hour ish:\n\nfrom scipy import stats\n\nlinreg = stats.linregress(x=onguard_df[onguard_df.index &lt; 0.5].index, y=atpase_h[onguard_df.index &lt; 0.5])\n\n\nplt.plot(onguard_df[onguard_df.index &lt; 1].index, atpase_h[onguard_df.index &lt; 1])\nplt.plot(onguard_df[onguard_df.index &lt; 0.5].index,\n         (onguard_df[onguard_df.index &lt; 0.5].index) * linreg.slope + linreg.intercept)\nplt.ylabel(\"H+-ATPase flux (fmol/h)\")\n\nText(0, 0.5, 'H+-ATPase flux (fmol/h)')\n\n\n\n\n\n\n\n\n\nAs the increase in flux through the H+-ATPase looks pretty linear from 0 to 0.5 hours, we can take the average over this time period and use it as our constraint\n\natpase_h[onguard_df.index &lt; 0.5].mean()\n\n7.499933868292683",
    "crumbs": [
      "Building model and defining parameters",
      "Is H+ATPase limiting?"
    ]
  },
  {
    "objectID": "1.3_atpase_constraint.html#conclusions",
    "href": "1.3_atpase_constraint.html#conclusions",
    "title": "Is H+ATPase limiting?",
    "section": "Conclusions",
    "text": "Conclusions\nSo even though the Flutsch value is higher (17 fmoles/h), it looks like this value from the OnGuard model might be a good value to use as our constraint, as it will about half the H+-ATPase rate for us (7.5 fmoles/h vs 13.9 fmoles/h).",
    "crumbs": [
      "Building model and defining parameters",
      "Is H+ATPase limiting?"
    ]
  }
]